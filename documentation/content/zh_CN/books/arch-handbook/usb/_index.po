# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2025-05-01 19:56-0300\n"
"PO-Revision-Date: 2021-06-03 00:09+0000\n"
"Last-Translator: Anonymous <noreply@weblate.org>\n"
"Language-Team: Chinese (Simplified) <https://translate-dev.freebsd.org/"
"projects/documentation/booksarch-handbookusb_index/zh_CN/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.6.2\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:1
#, fuzzy, no-wrap
#| msgid "USB Devices"
msgid "USB Devices in FreeBSD"
msgstr "USB设备"

#. type: YAML Front Matter: title
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:1
#, no-wrap
msgid "Chapter 13. USB Devices"
msgstr ""

#. type: Title =
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:14
#, no-wrap
msgid "USB Devices"
msgstr "USB设备"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:52
#, no-wrap
msgid "Introduction"
msgstr "介绍"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:55
msgid ""
"The Universal Serial Bus (USB) is a new way of attaching devices to personal "
"computers. The bus architecture features two-way communication and has been "
"developed as a response to devices becoming smarter and requiring more "
"interaction with the host. USB support is included in all current PC "
"chipsets and is therefore available in all recently built PCs. Apple's "
"introduction of the USB-only iMac has been a major incentive for hardware "
"manufacturers to produce USB versions of their devices. The future PC "
"specifications specify that all legacy connectors on PCs should be replaced "
"by one or more USB connectors, providing generic plug and play capabilities. "
"Support for USB hardware was available at a very early stage in NetBSD and "
"was developed by Lennart Augustsson for the NetBSD project. The code has "
"been ported to FreeBSD and we are currently maintaining a shared code base. "
"For the implementation of the USB subsystem a number of features of USB are "
"important."
msgstr ""
"通用串行总线(USB)是将设备连接到个人计算机的一种新方法。总线 结构突出了双向通"
"信的特色，并且其开发充分考虑到了设备正逐渐智能化 和需要与host进行更多交互的现"
"实。对USB的支持包含在当前所有芯片中, 因此在新近制造的PC中都可用。苹果(Apple)"
"引入仅带USB的iMac对硬件 制造商生产他们USB版本的设备是一个很大的激励。未来的PC"
"规范指定 PC上的所有老连接器应当由一个或多个USB连接器取代，提供通用的 即插即用"
"能力。对USB硬件的支持在NetBSD的相当早期就有了，它是由 Lennart Augustsson为"
"NetBSD项目开发的。代码已经被移植到FreeBSD上， 我们目前维护着一个底层共享代"
"码。对USB子系统的实现来说，许多USB的 特性很重要。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:57
#, fuzzy
msgid ""
"_Lennart Augustsson has done most of the implementation of the USB support "
"for the NetBSD project. Many thanks for this incredible amount of work. Many "
"thanks also to Ardy and Dirk for their comments and proofreading of this "
"paper._"
msgstr ""
"<emphasis>Lennart Augustsson已经完成了NetBSD项目中USB支持的 大部分实现。十分"
"感谢这项工作量惊人的工作。也十分感谢Ardy和Dirk 对本文稿的评论和校对。</"
"emphasis>"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:59
msgid ""
"Devices connect to ports on the computer directly or on devices called hubs, "
"forming a treelike device structure."
msgstr ""
"设备直接连接到计算机上的端口，或者连接到称为 集中器的设备，形成树型设备结构。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:60
msgid "The devices can be connected and disconnected at run time."
msgstr "设备可在运行时连接或断开。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:61
msgid "Devices can suspend themselves and trigger resumes of the host system"
msgstr "设备可以挂起自身并触发host系统的重新投入运行。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:62
msgid ""
"As the devices can be powered from the bus, the host software has to keep "
"track of power budgets for each hub."
msgstr "由于设备可由总线供电，因此host软件必须跟踪每个 集中器的电源预算。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:63
msgid ""
"Different quality of service requirements by the different device types "
"together with the maximum of 126 devices that can be connected to the same "
"bus, require proper scheduling of transfers on the shared bus to take full "
"advantage of the 12Mbps bandwidth available. (over 400Mbps with USB 2.0)"
msgstr ""
"不同设备类型需要不同的服务质量，并且同一总线 可以连接最多126个设备，这就需要"
"恰当地调度总线上的传输以充分 利用12Mbps的可用带宽。（USB 2.0超过400Mbps）"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:64
msgid ""
"Devices are intelligent and contain easily accessible information about "
"themselves"
msgstr "设备智能化并包含很容易访问到的关于自身的信息。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:66
msgid ""
"The development of drivers for the USB subsystem and devices connected to it "
"is supported by the specifications that have been developed and will be "
"developed. These specifications are publicly available from the USB home "
"pages. Apple has been very strong in pushing for standards based drivers, by "
"making drivers for the generic classes available in their operating system "
"MacOS and discouraging the use of separate drivers for each new device. This "
"chapter tries to collate essential information for a basic understanding of "
"the USB 2.0 implementation stack in FreeBSD/NetBSD. It is recommended "
"however to read it together with the relevant 2.0 specifications and other "
"developer resources:"
msgstr ""
"为USB子系统以及连接到它的设备开发驱动程序受已开发或将要开发的 规范的支持。这"
"些规范可以从USB主页公开获得。苹果(Apple)通过使得 通用类驱动程序可从其操作系统"
"MacOS中获得，而且不鼓励为每种新设备 使用单独的驱动程序来强烈推行基于标准的驱"
"动程序。本章试图整理基本 信息以便对FreeBSD/NetBSD中USB栈的当前实现有个基本的"
"了解。然而， 建议将下面参考中提及的相关规范与本章同时阅读："

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:68
msgid ""
"USB 2.0 Specification (http://www.usb.org/developers/docs/usb20_docs/[http://"
"www.usb.org/developers/docs/usb20_docs/])"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:69
msgid ""
"Universal Host Controller Interface (UHCI) Specification (link:ftp://ftp."
"netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf[ftp://ftp.netbsd.org/pub/NetBSD/"
"misc/blymn/uhci11d.pdf)]"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:70
msgid ""
"Open Host Controller Interface (OHCI) Specification(link:ftp://ftp.compaq."
"com/pub/supportinformation/papers/hcir1_0a.pdf[ftp://ftp.compaq.com/pub/"
"supportinformation/papers/hcir1_0a.pdf])"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:71
msgid ""
"Developer section of USB home page (http://www.usb.org/developers/[http://"
"www.usb.org/developers/])"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:72
#, no-wrap
msgid "Structure of the USB Stack"
msgstr "USB栈的结构"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:75
msgid ""
"The USB support in FreeBSD can be split into three layers. The lowest layer "
"contains the host controller driver, providing a generic interface to the "
"hardware and its scheduling facilities. It supports initialisation of the "
"hardware, scheduling of transfers and handling of completed and/or failed "
"transfers. Each host controller driver implements a virtual hub providing "
"hardware independent access to the registers controlling the root ports on "
"the back of the machine."
msgstr ""
"FreeBSD中的USB支持可被分为三层。最底层包含主控器，向硬件 及其调度设施提供一个"
"通用接口。它支持硬件初始化，对传输进行调度， 处理已完成/失败的传输。每个主控"
"器驱动程序实现一个虚拟hub， 以硬件无关方式提供对控制机器背面根端口的寄存器的"
"访问。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:77
msgid ""
"The middle layer handles the device connection and disconnection, basic "
"initialisation of the device, driver selection, the communication channels "
"(pipes) and does resource management. This services layer also controls the "
"default pipes and the device requests transferred over them."
msgstr ""
"中间层处理设备连接和断开，设备的基本初始化，驱动程序的选择， 通信通道（管道）"
"和资源管理。这个服务层也控制默认管道和其上传输的 设备请求。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:79
msgid ""
"The top layer contains the individual drivers supporting specific (classes "
"of) devices. These drivers implement the protocol that is used over the "
"pipes other than the default pipe. They also implement additional "
"functionality to make the device available to other parts of the kernel or "
"userland. They use the USB driver interface (USBDI) exposed by the services "
"layer."
msgstr ""
"顶层包含支持特定（类）设备的各个驱动程序。这些驱动程序实现 除默认管道外的其他"
"管道上使用的协议。他们也实现额外功能，使得设备 对内核或用户空间是可见的。他们"
"使用服务层暴露出的USB驱动程序接口 (USBDI)。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:81
#, no-wrap
msgid "Host Controllers"
msgstr "主控器"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:84
msgid ""
"The host controller (HC) controls the transmission of packets on the bus. "
"Frames of 1 millisecond are used. At the start of each frame the host "
"controller generates a Start of Frame (SOF) packet."
msgstr ""
"主控器（HC）控制总线上包的传输。使用1毫秒的帧。在每帧开始 时，主控器产生一个"
"帧开始（SOF, Start of Frame）包。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:86
msgid ""
"The SOF packet is used to synchronise to the start of the frame and to keep "
"track of the frame number. Within each frame packets are transferred, either "
"from host to device (out) or from device to host (in). Transfers are always "
"initiated by the host (polled transfers). Therefore there can only be one "
"host per USB bus. Each transfer of a packet has a status stage in which the "
"recipient of the data can return either ACK (acknowledge reception), NAK "
"(retry), STALL (error condition) or nothing (garbled data stage, device not "
"available or disconnected). Section 8.5 of the USB 2.0 Specification "
"explains the details of packets in more detail. Four different types of "
"transfers can occur on a USB bus: control, bulk, interrupt and isochronous. "
"The types of transfers and their characteristics are described below."
msgstr ""
"SOF包用于同步帧的开始和跟踪帧的数目。包在帧中被传输，或由host 到设备（out），"
"或由设备到host（in）。传输总是由host发起（轮询传输）。 因此每条USB总线只能有"
"一个host。每个包的传输都有一个状态阶段， 数据接收者可以在其中返回ACK（应答接"
"收），NAK（重试），STALL（错误 条件）或什么也没有（混乱数据阶段，设备不可用或"
"已断开）。USB规范 <link xlink:href=\"http://www.usb.org/developers/docs.html"
"\">USB specification</link>的第8.5节更详细地解释了包的细节。USB总线 上可以出"
"现四中不同类型的传输：控制(control)， 大块(bulk)， 中断 (interrupt)和同步"
"(isochronous)。传输的类型和他们的特性在下面 描述（`管道'子节中）。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:88
msgid ""
"Large transfers between the device on the USB bus and the device driver are "
"split up into multiple packets by the host controller or the HC driver."
msgstr ""
"USB总线上的设备和设备驱动程序间的大型传输被主控器或HC 驱动程序分割为多个包。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:90
#, fuzzy
msgid ""
"Device requests (control transfers) to the default endpoints are special. "
"They consist of two or three phases: SETUP, DATA (optional) and STATUS. The "
"set-up packet is sent to the device. If there is a data phase, the direction "
"of the data packet(s) is given in the set-up packet. The direction in the "
"status phase is the opposite of the direction during the data phase, or IN "
"if there was no data phase. The host controller hardware also provides "
"registers with the current status of the root ports and the changes that "
"have occurred since the last reset of the status change register. Access to "
"these registers is provided through a virtualised hub as suggested in the "
"USB specification. The virtual hub must comply with the hub device class "
"given in chapter 11 of that specification. It must provide a default pipe "
"through which device requests can be sent to it. It returns the standard "
"andhub class specific set of descriptors. It should also provide an "
"interrupt pipe that reports changes happening at its ports. There are "
"currently two specifications for host controllers available: Universal Host "
"Controller Interface (UHCI) from Intel and Open Host Controller Interface "
"(OHCI) from Compaq, Microsoft, and National Semiconductor. The UHCI "
"specification has been designed to reduce hardware complexity by requiring "
"the host controller driver to supply a complete schedule of the transfers "
"for each frame. OHCI type controllers are much more independent by providing "
"a more abstract interface doing a lot of work themselves."
msgstr ""
"到默认端点的设备请求（控制传输）有些特殊。它们由两或三个阶段 组成：启动"
"（SETUP），数据（DATA，可选）和状态（STATUS）。设置（set-up） 包被发送到设"
"备。如果存在数据阶段，数据包的方向在设置包中给出。 状态阶段中的方向与数据阶段"
"期间的方向相反，或者当没有数据阶段时 为IN。主控器硬件也提供寄存器，用于保存根"
"端口的当前状态和自从 状态改变寄存器最后一次复位以来所发生的改变。USB规范[2]建"
"议使用一个 虚拟hub来提供对这些寄存器的访问。虚拟hub必须符合规范第11章中给出"
"的 hub设备类。它必须提供一个默认管道使得设备请求可以发送给它。它返回 标准和"
"hub类特定的一组描述符。它也应当提供一个中断管道用来报告其 端口发生的变化。当"
"前可用的主控器规范有两个：通用主控器接口（<acronym>UHCI</acronym>；英特尔）和"
"开放主控器接口（<acronym>OHCI</acronym>；康柏，微软，国家半导体）。 "
"<acronym>UHCI</acronym>规范的设计通过要求主控器驱动程序为每帧的传输提供完整的"
"调度， 从而减少了硬件复杂性。OHCI类型的控制器自身提供一个更抽象的接口来 完成"
"很多工作，从而更加独立。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:91
#, no-wrap
msgid "UHCI"
msgstr "UHCI"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:94
msgid ""
"The UHCI host controller maintains a framelist with 1024 pointers to per "
"frame data structures. It understands two different data types: transfer "
"descriptors (TD) and queue heads (QH). Each TD represents a packet to be "
"communicated to or from a device endpoint. QHs are a means to groupTDs (and "
"QHs) together."
msgstr ""
"UHCI主控器维护着带有1024个指向每帧数据结构的帧列表。 它理解两种不同的数据类"
"型：传输描述符（TD）和队列头（QH）。每个 TD表示表示与设备端点进行通信的一个"
"包。QH是将一些TD（和QH）划分 成组的一种方法。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:96
msgid ""
"Each transfer consists of one or more packets. The UHCI driver splits large "
"transfers into multiple packets. For every transfer, apart from isochronous "
"transfers, a QH is allocated. For every type of transfer these QHs are "
"collected at a QH for that type. Isochronous transfers have to be executed "
"first because of the fixed latency requirement and are directly referred to "
"by the pointer in the framelist. The last isochronous TD refers to the QH "
"for interrupt transfers for that frame. All QHs for interrupt transfers "
"point at the QH for control transfers, which in turn points at the QH for "
"bulk transfers. The following diagram gives a graphical overview of this:"
msgstr ""
"每个传输由一个或多个包组成。UHCI驱动程序将大的传输分割成 多个包。除同步传输"
"外，每个传输都会分配一个QH。对于每种类型的 传输，都有一个与此类型对应的QH，所"
"有这些QH都会被集中到这个QH上。 由于有固定的时延需求，同步传输必须首先执行，它"
"是通过帧列表中的 指针直接引用的。最后的同步TD传输引用那一帧的中断传输的QH。中"
"断 传输的所有QH指向控制传输的QH，控制传输的QH又指向大块传输的QH。 下面的图表"
"给出了一个图形概览："

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:98
#, fuzzy
#| msgid ""
#| "This results in the following schedule being run in each frame. After "
#| "fetching the pointer for the current frame from the framelist the "
#| "controller first executes the TDs for all the isochronous packets in that "
#| "frame. The last of these TDs refers to the QH for the interrupt transfers "
#| "for thatframe. The host controller will then descend from that QH to the "
#| "QHs for the individual interrupt transfers. After finishing that queue, "
#| "the QH for the interrupt transfers will refer the controller to the QH "
#| "for all control transfers. It will execute all the subqueues scheduled "
#| "there, followed by all the transfers queued at the bulk QH. To facilitate "
#| "the handling of finished or failed transfers different types of "
#| "interrupts are generated by the hardware at the end of each frame. In the "
#| "last TD for a transfer the Interrupt-On Completion bit is set by the HC "
#| "driver to flag an interrupt when the transfer has completed. An error "
#| "interrupt is flagged if a TD reaches its maximum error count. If the "
#| "short packet detect bit is set in a TD and less than the set packet "
#| "length is transferred this interrupt is flagged to notify the controller "
#| "driver of the completed transfer. It is the host controller driver's task "
#| "to find out which transfer has completed or produced an error. When "
#| "called the interrupt service routine will locate all the finished "
#| "transfers and call their callbacks."
msgid ""
"This results in the following schedule being run in each frame. After "
"fetching the pointer for the current frame from the framelist the controller "
"first executes the TDs for all the isochronous packets in that frame. The "
"last of these TDs refers to the QH for the interrupt transfers for that "
"frame. The host controller will then descend from that QH to the QHs for the "
"individual interrupt transfers. After finishing that queue, the QH for the "
"interrupt transfers will refer the controller to the QH for all control "
"transfers. It will execute all the subqueues scheduled there, followed by "
"all the transfers queued at the bulk QH. To facilitate the handling of "
"finished or failed transfers different types of interrupts are generated by "
"the hardware at the end of each frame. In the last TD for a transfer the "
"Interrupt-On Completion bit is set by the HC driver to flag an interrupt "
"when the transfer has completed. An error interrupt is flagged if a TD "
"reaches its maximum error count. If the short packet detect bit is set in a "
"TD and less than the set packet length is transferred this interrupt is "
"flagged to notify the controller driver of the completed transfer. It is the "
"host controller driver's task to find out which transfer has completed or "
"produced an error. When called the interrupt service routine will locate all "
"the finished transfers and call their callbacks."
msgstr ""
"这导致下面的调度会在每帧中运行。控制器从帧列表中取得当前帧 的指针后，首先为那"
"一帧中的所有的同步(isochronous)包执行TD。 这些TD的最后一个 引用那一帧的中断传"
"输的QH。然后主控器将从那个QH下行到各个 中断传输的QH。完成那一队列后，中断传输"
"的QH会将控制器指向到所有 控制传输的QH。它将执行在那儿等待调度的所有子队列，然"
"后是在大块QH中 排队的所有传输。为了方便处理已完成或失败的传输，硬件会在每帧末"
"尾 产生不同类型的中断。在传输的最后一个TD中，HC驱动程序设置 Interrupt-On-"
"Completion位来标记传输完成时的一个中断。如果TD达到了 其最大错误数，就标记错误"
"中断。如果在TD中设置短包侦测位，且传输了 小于所设置的包长度（的包），就会标记"
"此中断以通知控制器驱动程序传输 已完成。找出哪个传输已完成或产生错误是主控器驱"
"动程序的任务。 当中断服务例程被调用时，它将定位所有已完成的传输并调用它们的回"
"调。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:100
msgid "Refer to the UHCI Specification for a more elaborate description."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:101
#, no-wrap
msgid "OHCI"
msgstr "OHCI"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:104
msgid ""
"Programming an OHCI host controller is much simpler. The controller assumes "
"that a set of endpoints is available, and is aware of scheduling priorities "
"and the ordering of the types of transfers in a frame. The main data "
"structure used by the host controller is the endpoint descriptor (ED) to "
"which a queue of transfer descriptors (TDs) is attached. The ED contains the "
"maximum packet size allowed for an endpoint and the controller hardware does "
"the splitting into packets. The pointers to the data buffers are updated "
"after each transfer and when the start and end pointer are equal, the TD is "
"retired to the done-queue. The four types of endpoints (interrupt, "
"isochronous, control, and bulk) have their own queues. Control and bulk "
"endpoints are queued each at their own queue. Interrupt EDs are queued in a "
"tree, with the level in the tree defining the frequency at which they run."
msgstr ""
"对OHCI主控器进行编程要容易得多。控制器假设有一组端点(endpoint)可用， 并知道帧"
"中不同传输类型的调度优先级和排序。主控器使用的主要 数据结构是端点描述符"
"（ED），它上面连接着一个传输描述符（TD）的队列。 ED包含端点所允许的最大的包大"
"小，控制器硬件完成包的分割。每次传输 后都会更新指向数据缓冲区的指针，当起始和"
"终止指针相等时，TD就退归 到完成队列(done-queue)。四种类型的端点各有其自己的队"
"列。控制和 大块(bulk)端点分别在它们自己的队列排队。中断ED在树中排队，在树中的"
"深度 定义了它们运行的频度。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:106
msgid ""
"The schedule being run by the host controller in each frame looks as "
"follows. The controller will first run the non-periodic control and bulk "
"queues, up to a time limit set by the HC driver. Then the interrupt "
"transfers for that frame number are run, by using the lower five bits of the "
"frame number as an index into level 0 of the tree of interrupts EDs. At the "
"end of this tree the isochronous EDs are connected and these are traversed "
"subsequently. The isochronous TDs contain the frame number of the first "
"frame the transfer should be run in. After all the periodic transfers have "
"been run, the control and bulk queues are traversed again. Periodically the "
"interrupt service routine is called to process the done queue and call the "
"callbacks for each transfer and reschedule interrupt and isochronous "
"endpoints."
msgstr ""
"主控器在每帧中运行的调度看起来如下。控制器首先运行非 周期性控制和大块队列，最"
"长可到HC驱动程序设置的一个时间限制。 然后以帧编号低5位作为中断ED树上深度为0的"
"那一层中的索引，运行 那个帧编号的中断传输。在这个树的末尾，同步ED被连接，并随"
"后被 遍历。同步TD包含了传输应当运行其中的第一个帧的帧编号。所有周期 性的传输"
"运行过以后，控制和大块队列再次被遍历。中断服务例程会被 周期性地调用，来处理完"
"成的队列，为每个传输调用回调，并重新调度 中断和同步端点。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:108
#, fuzzy
msgid ""
"See the UHCI Specification for a more elaborate description. The middle "
"layer provides access to the device in a controlled way and maintains "
"resources in use by the different drivers and the services layer. The layer "
"takes care of the following aspects:"
msgstr ""
"更详尽的描述请看<acronym>UHCI</acronym>标准描述。服务层，即中间层，提供了以可"
"控的方式 对设备进行访问，并维护着由不同驱动程序和服务层所使用的资源。 此层处"
"理下面几方面："

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:110
msgid "The device configuration information"
msgstr "设备配置信息"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:111
msgid "The pipes to communicate with a device"
msgstr "与设备进行通信的管道"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:112
msgid "Probing and attaching and detaching form a device."
msgstr "探测和连接设备，以及从设备分离(detach)。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:114
#, no-wrap
msgid "USB Device Information"
msgstr "USB设备信息"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:116
#, no-wrap
msgid "Device Configuration Information"
msgstr "设备配置信息"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:119
msgid ""
"Each device provides different levels of configuration information. Each "
"device has one or more configurations, of which one is selected during probe/"
"attach. A configuration provides power and bandwidth requirements. Within "
"each configuration there can be multiple interfaces. A device interface is a "
"collection of endpoints. For example USB speakers can have an interface for "
"the audio data (Audio Class) and an interface for the knobs, dials and "
"buttons (HID Class). All interfaces in a configuration are active at the "
"same time and can be attached to by different drivers. Each interface can "
"have alternates, providing different quality of service parameters. In for "
"example cameras this is used to provide different frame sizes and numbers of "
"frames per second."
msgstr ""
"每个设备提供了不同级别的配置信息。每个设备具有一个或多个 配置，探测/连接期间"
"从其中选定一个。配置提供功率和带宽要求。 每个配置中可以有多个接口。设备接口是"
"端点的汇集(collection)。 例如，USB扬声器可以有一个音频接口（音频类），和对旋"
"钮(knob)、 拨号盘(dial)和按钮的接口（HID类）。 一个配置中的所有接口可以同时有"
"效，并可被不同的 驱动程序连接。每个接口可以有备用接口，以提供不同质量的服务参"
"数。 例如，在照相机中，这用来提供不同的帧大小以及每秒帧数。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:121
msgid ""
"Within each interface, 0 or more endpoints can be specified. Endpoints are "
"the unidirectional access points for communicating with a device. They "
"provide buffers to temporarily store incoming or outgoing data from the "
"device. Each endpoint has a unique address within a configuration, the "
"endpoint's number plus its direction. The default endpoint, endpoint 0, is "
"not part of any interface and available in all configurations. It is managed "
"by the services layer and not directly available to device drivers."
msgstr ""
"每个接口中可以指定0或多个端点。端点是与设备进行通信的单向 访问点。它们提供缓"
"冲区来临时存储从设备而来的，或外出到设备的数据。 每个端点在配置中有唯一地址，"
"即端点号加上其方向。默认端点，即 端点0，不是任何接口的一部分，并且在所有配置"
"中可用。它由服务层 管理，并且设备驱动程序不能直接使用。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:123
msgid ""
"This hierarchical configuration information is described in the device by a "
"standard set of descriptors (see section 9.6 of the USB specification). They "
"can be requested through the Get Descriptor Request. The services layer "
"caches these descriptors to avoid unnecessary transfers on the USB bus. "
"Access to the descriptors is provided through function calls."
msgstr ""
"这种层次化配置信息在设备中通过标准的一组描述符来描述（参看 USB规范[2]第9.6"
"节）。它们可以通过Get Descriptor Request来请求。 服务层缓存这些描述符以避免在"
"USB总线上进行不必要的传输。对这些 描述符的访问是通过函数调用来提供的。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:125
msgid ""
"Device descriptors: General information about the device, like Vendor, "
"Product and Revision Id, supported device class, subclass and protocol if "
"applicable, maximum packet size for the default endpoint, etc."
msgstr ""
"设备描述符：关于设备的通用信息，如供应商，产品 和修订ID，支持的设备类、子类和"
"适用的协议，默认端点的最大包大小 等。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:126
msgid ""
"Configuration descriptors: The number of interfaces in this configuration, "
"suspend and resume functionality supported and power requirements."
msgstr "配置描述符：此配置中的接口数，支持的挂起和 恢复能力，以及功率要求。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:127
msgid ""
"Interface descriptors: interface class, subclass and protocol if applicable, "
"number of alternate settings for the interface and the number of endpoints."
msgstr "接口描述符：接口类、子类和适用的协议，接口备用 配置的数目和端点数目。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:128
msgid ""
"Endpoint descriptors: Endpoint address, direction and type, maximum packet "
"size supported and polling frequency if type is interrupt endpoint. There is "
"no descriptor for the default endpoint (endpoint 0) and it is never counted "
"in an interface descriptor."
msgstr ""
"端点描述符：端点地址、方向和类型，支持的最大包 大小，如果是中断类型的端点则还"
"包括轮询频率。默认端点（端点0） 没有描述符，而且从不被计入接口描述符中。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:129
msgid ""
"String descriptors: In the other descriptors string indices are supplied for "
"some fields.These can be used to retrieve descriptive strings, possibly in "
"multiple languages."
msgstr ""
"字符串描述符：在其他描述符中会为某些字段提供 字符串索引。它们可被用来检取描述"
"性字符串，可能以多种语言 的形式提供。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:131
msgid ""
"Class specifications can add their own descriptor types that are available "
"through the GetDescriptor Request."
msgstr ""
"类说明(specification)可以添加它们自己的描述符类型，这些描述符 也可以通过"
"GetDescriptor Request来获得。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:133
msgid ""
"Pipes Communication to end points on a device flows through so-called pipes. "
"Drivers submit transfers to endpoints to a pipe and provide a callback to be "
"called on completion or failure of the transfer (asynchronous transfers) or "
"wait for completion (synchronous transfer). Transfers to an endpoint are "
"serialised in the pipe. A transfer can either complete, fail or time-out (if "
"a time-out has been set). There are two types of time-outs for transfers. "
"Time-outs can happen due to time-out on the USBbus (milliseconds). These "
"time-outs are seen as failures and can be due to disconnection of the "
"device. A second form of time-out is implemented in software and is "
"triggered when a transfer does not complete within a specified amount of "
"time (seconds). These are caused by a device acknowledging negatively (NAK) "
"the transferred packets. The cause for this is the device not being ready to "
"receive data, buffer under- or overrun or protocol errors."
msgstr ""
"管道与设备上端点的通信，流经所谓的管道。驱动程序将到端点的 传输提交到管道，并"
"提供传输（异步传输）失败或完成时调用的回调， 或等待完成（同步传输）。到端点的"
"传输在管道中被串行化。传输或者完成， 或者失败，或者超时（如果设置了超时）。对"
"于传输有两种类型的超时。 超时的发生可能由于USB总线上的超时（毫秒）。这些超时"
"被视为失败， 可能是由于设备断开连接引起的。另一种超时在软件中实现，当传输没"
"有 在指定的时间（秒）内完成时触发。这是由于设备对传输的包否定应答引起的。 其"
"原因是由于设备还没有准备好接收数据，缓冲区欠载或超载，或协议错误。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:135
msgid ""
"If a transfer over a pipe is larger than the maximum packet size specified "
"in the associated endpoint descriptor, the host controller (OHCI) or the HC "
"driver (UHCI) will split the transfer into packets of maximum packet size, "
"with the last packet possibly smaller than the maximum packet size."
msgstr ""
"如果管道上的传输大于关联的端点描述符中指定的最大包大小，主 控器（OHCI）或HC驱"
"动程序（UHCI）将按最大包大小分割传输，并且最后 一个包可能小于最大包的大小。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:137
msgid ""
"Sometimes it is not a problem for a device to return less data than "
"requested. For example abulk-in-transfer to a modem might request 200 bytes "
"of data, but the modem has only 5 bytes available at that time. The driver "
"can set the short packet (SPD) flag. It allows the host controller to accept "
"a packet even if the amount of data transferred is less than requested. This "
"flag is only valid for in-transfers, as the amount of data to be sent to a "
"device is always known beforehand. If an unrecoverable error occurs in a "
"device during a transfer the pipe is stalled. Before any more data is "
"accepted or sent the driver needs to resolve the cause of the stall and "
"clear the endpoint stall condition through send the clear endpoint halt "
"device request over the default pipe. The default endpoint should never "
"stall."
msgstr ""
"有时候对设备来说返回少于所请求的数据并不是个问题。例如， 到调制解调器的大块in"
"传输可能请求200字节的数据，但调制解调器 那时只有5个字节可用。驱动程序可以设置"
"短包(SPD)标志。它允许主 控器即使在传输的数据量少于所请求的数据量的情况下也接"
"受包。 这个标志只在in传输中有效，因为将要被发送到设备的数据量总是事先 知道"
"的。如果传输过程中设备出现不可恢复的错误，管道会被停顿。 接受或发送更多数据以"
"前，驱动程序需要确定停顿的原因，并通过在 默认管道上发送清除端点挂起设备请求"
"(clear endpoint halt device request)来清除端点停顿条件。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:139
msgid ""
"There are four different types of endpoints and corresponding pipes: - "
"Control pipe / default pipe: There is one control pipe per device, connected "
"to the default endpoint (endpoint 0). The pipe carries the device requests "
"and associated data. The difference between transfers over the default pipe "
"and other pipes is that the protocol for the transfers is described in the "
"USB specification. These requests are used to reset and configure the "
"device. A basic set of commands that must be supported by each device is "
"provided in chapter 9 of the USB specification. The commands supported on "
"this pipe can be extended by a device class specification to support "
"additional functionality."
msgstr ""
"有四种不同类型的端点和对应的管道： -控制管道/默认管道： 每个设备有一个控制管"
"道，连接到默认端点（端点0）。此管道运载设备 请求和关联的数据。默认管道和其他"
"管道上的传输的区别在于传输所 使用的协议，协议在USB规范[2]中描述。这些请求用于"
"复位和配置设备。 每个设备必须支持USB规范[2]的第9章中提供的一组基本命令。管道"
"上 支持的命令可以通过设备类规范扩展，以支持额外的功能。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:141
msgid "Bulk pipe: This is the USB equivalent to a raw transmission medium."
msgstr "大块(bulk)管道：这是USB与原始传输媒体对应的等价物。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:142
msgid ""
"Interrupt pipe: The host sends a request for data to the device and if the "
"device has nothing to send, it will NAK the data packet. Interrupt transfers "
"are scheduled at a frequency specified when creating the pipe."
msgstr ""
"中断管道：host向设备发送数据请求，如果设备没有 东西发送，则将NAK（否定应答）"
"数据包。中断传输按创建管道时指定的 频率被调度。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:143
msgid ""
"Isochronous pipe: These pipes are intended for isochronous data, for example "
"video or audio streams, with fixed latency, but no guaranteed delivery. Some "
"support for pipes of this type is available in the current implementation. "
"Packets in control, bulk and interrupt transfers are retried if an error "
"occurs during transmission or the device acknowledges the packet negatively "
"(NAK) due to for example lack of buffer space to store the incoming data. "
"Isochronous packets are however not retried in case of failed delivery or "
"NAK of a packet as this might violate the timing constraints."
msgstr ""
"同步管道：这些管道用于具有固定时延的同步数据， 例如视频或音频流，但不保证一定"
"传输。当前实现中已经有对这种类型 管道的某些支持。当传输期间出现错误，或者由"
"于，例如缺乏缓冲区空间 来存储进入的数据而引起的设备否定应答包（NAK）时，控"
"制、大块和中断 管道中的包会被重试。而同步包在传递失败或对包NAK时不会重试，因"
"为 那样可能违反同步约束。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:145
msgid ""
"The availability of the necessary bandwidth is calculated during the "
"creation of the pipe. Transfers are scheduled within frames of 1 "
"millisecond. The bandwidth allocation within a frame is prescribed by the "
"USB specification, section 5.6 [ 2]. Isochronous and interrupt transfers are "
"allowed to consume up to 90% of the bandwidth within a frame. Packets for "
"control and bulk transfers are scheduled after all isochronous and interrupt "
"packets and will consume all the remaining bandwidth."
msgstr ""
"所需带宽的可用性在管道的创建期间被计算。传输在1毫秒的帧内 进行调度。帧中的带"
"宽分配由USB规范的第5.6节规定。同步和中断传输被 允许消耗帧中多达90%的带宽。控"
"制和大块传输的包在所有同步和中断包 之后进行调度，并将消耗所有剩余带宽。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:147
msgid ""
"More information on scheduling of transfers and bandwidth reclamation can be "
"found in chapter 5 of the USB specification, section 1.3 of the UHCI "
"specification, and section 3.4.2 of the OHCI specification."
msgstr ""
"关于传输调度和带宽回收的更多信息可以在USB规范[2]的第5章， UHCI规范[3]的的第"
"1.3节，OHCI规范[4]的3.4.2节中找到。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:149
#, no-wrap
msgid "Device Probe and Attach"
msgstr "设备的探测和连接"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:152
msgid ""
"After the notification by the hub that a new device has been connected, the "
"service layer switches on the port, providing the device with 100 mA of "
"current. At this point the device is in its default state and listening to "
"device address 0. The services layer will proceed to retrieve the various "
"descriptors through the default pipe. After that it will send a Set Address "
"request to move the device away from the default device address (address 0). "
"Multiple device drivers might be able to support the device. For example a "
"modem driver might be able to support an ISDN TA through the AT "
"compatibility interface. A driver for that specific model of the ISDN "
"adapter might however be able to provide much better support for this "
"device. To support this flexibility, the probes return priorities indicating "
"their level of support. Support for a specific revision of a product ranks "
"the highest and the generic driver the lowest priority. It might also be "
"that multiple drivers could attach to one device if there are multiple "
"interfaces within one configuration. Each driver only needs to support a "
"subset of the interfaces."
msgstr ""
"集中器(hub)通知新设备已连接后，服务层给端口加电(switch on)， 为设备提供100mA"
"的电流。 此时设备处于其默认状态，并监听设备地址0。服务层会通过默认 管道继续检"
"取各种描述符。此后它将向设备发送Set Address请求，将设备 从默认设备地址(地址0)"
"移开。可能有多个设备驱动程序支持此设备。例如， 一个调制解调器可能通过AT兼容接"
"口支持ISDN TA。然而，特定型号的ISDN 适配器的驱动程序可能提供对此设备的更好支"
"持。为了支持这样的灵活性， 探测会返回优先级，指示他们的支持级别。支持产品的特"
"定版本会具有最高 优先级，通用驱动程序具有最低优先级。如果一个配置内有多个接"
"口，也可能 多个驱动程序会连接到一个设备。每个驱动程序只需支持所有接口的一个子"
"集。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:154
msgid ""
"The probing for a driver for a newly attached device checks first for device "
"specific drivers. If not found, the probe code iterates over all supported "
"configurations until a driver attaches in a configuration. To support "
"devices with multiple drivers on different interfaces, the probe iterates "
"over all interfaces in a configuration that have not yet been claimed by a "
"driver. Configurations that exceed the power budget for the hub are ignored. "
"During attach the driver should initialise the device to its proper state, "
"but not reset it, as this will make the device disconnect itself from the "
"bus and restart the probing process for it. To avoid consuming unnecessary "
"bandwidth should not claim the interrupt pipe at attach time, but should "
"postpone allocating the pipe until the file is opened and the data is "
"actually used. When the file is closed the pipe should be closed again, even "
"though the device might still be attached."
msgstr ""
"为新连接的设备探测驱动程序时，首先探测设备特定的驱动程序。 如果没有发现，则探"
"测代码在所有支持的配置上重复探测过程，直到 在一个配置中连接到一个驱动程序。为"
"了支持不同接口上使用多个驱动 程序的设备，探测会在一个配置中的所有尚未被驱动程"
"序声明(claim)的 接口上重复进行。超出集中器功率预算的配置会被忽略。连接期间，"
"驱动 程序应当把设备初始化到适当状态，但不能复位，因为那样会使得设备将 它自己"
"从总线上断开，并重新启动探测过程。为了避免消耗不必要的带宽， 不应当在连接时声"
"明中断管道，而应当延迟分配管道，直到打开文件并真的 使用数据。当关闭文件时，管"
"道也应当被再次关闭，尽管设备可能仍然 连接着。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:155
#, no-wrap
msgid "Device Disconnect and Detach"
msgstr "设备断开连接(disconnect)和分离(detach)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:158
msgid ""
"A device driver should expect to receive errors during any transaction with "
"the device. The design of USB supports and encourages the disconnection of "
"devices at any point in time. Drivers should make sure that they do the "
"right thing when the device disappears."
msgstr ""
"设备驱动程序与设备进行任何事务期间，应当预期会接收到错误。 USB的设计支持并鼓"
"励设备在任何点及时断开连接。驱动程序应当确保 当设备不在时做正确的事情。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:160
msgid ""
"Furthermore a device that has been disconnected and reconnected will not be "
"reattached at the same device instance. This might change in the future when "
"more devices support serial numbers (see the device descriptor) or other "
"means of defining an identity for a device have been developed."
msgstr ""
"此外，断开连接(disconnect)后又重新连接(reconnect)的设备不会 被重新连接"
"(reattach)为相同的设备实例。 将来当更多的设备支持序列号（参看设备描述符）， "
"或开发出其他定义设备标识的方法的时候，这种情况可能会改变。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:162
msgid ""
"The disconnection of a device is signaled by a hub in the interrupt packet "
"delivered to the hub driver. The status change information indicates which "
"port has seen a connection change. The device detach method for all device "
"drivers for the device connected on that port are called and the structures "
"cleaned up. If the port status indicates that in the mean time a device has "
"been connected to that port, the procedure for probing and attaching the "
"device will be started. A device reset will produce a disconnect-connect "
"sequence on the hub and will be handled as described above."
msgstr ""
"设备断开连接是由集中器在传递到集中器驱动程序的中断包中发 信号通知(signal)的。"
"状态改变信息指示哪个端口发现了连接改变。 连接到那个端口上的设备的所有设备驱动"
"程序共用的设备分离方法被调用， 结构被彻底清理。如果端口状态指示同时一个设备已"
"经连接(connect)到那个 端口，则探测和连接设备的过程将被启动。设备复位将在集中"
"器上产生 一个断开-连接序列，并将按上面所述进行处理。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:164
#, no-wrap
msgid "USB Drivers Protocol Information"
msgstr "USB驱动程序的协议信息"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:167
msgid ""
"The protocol used over pipes other than the default pipe is undefined by the "
"USB specification. Information on this can be found from various sources. "
"The most accurate source is the developer's section on the USB home pages. "
"From these pages, a growing number of deviceclass specifications are "
"available. These specifications specify what a compliant device should look "
"like from a driver perspective, basic functionality it needs to provide and "
"the protocol that is to be used over the communication channels. The USB "
"specification includes the description of the Hub Class. A class "
"specification for Human Interface Devices (HID) has been created to cater "
"for keyboards, tablets, bar-code readers, buttons, knobs, switches, etc. A "
"third example is the class specification for mass storage devices. For a "
"full list of device classes see the developers section on the USB home pages."
msgstr ""
"USB规范没有定义除默认管道外其他管道上使用的协议。这方面的信息 可以从各种来源"
"获得。最准确的来源是USB主页[1]上的开发者部分。从这些 页面上可以得到数目不断增"
"长的设备类的规范。这些规范指定从驱动程序 角度看起来兼容设备应当怎样，它需要提"
"供的基本功能和通信通道上使用的 协议。USB规范[2]包括了集中器类的描述。人机界面"
"设备(HID)的类规范已经 创建出来，以迎合对键盘、数字输入板、条形码阅读器、按"
"钮、旋钮(手柄knob)、 开关等的要求。另一个例子是用于大容量存储设备的类规范。设"
"备类的完整列表 参看USB主页[1]的开发者部分。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:169
msgid ""
"For many devices the protocol information has not yet been published "
"however. Information on the protocol being used might be available from the "
"company making the device. Some companies will require you to sign a Non -"
"Disclosure Agreement (NDA) before giving you the specifications. This in "
"most cases precludes making the driver open source."
msgstr ""
"然而, 许多设备的协议信息还没有被公布。关于所用协议的信息 可能可以从制造设备的"
"公司获得。一些公司会在给你规范之前要求你签署 保密协议(Non-Disclosure "
"Agreement, NDA)。大多数情况下，这会阻止 将驱动程序开放源代码。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:171
msgid ""
"Another good source of information is the Linux driver sources, as a number "
"of companies have started to provide drivers for Linux for their devices. It "
"is always a good idea to contact the authors of those drivers for their "
"source of information."
msgstr ""
"另一个信息的很好来源是Linux驱动程序源代码，因为很多公司已经 开始为他们的设备"
"提供Linux下的驱动程序。联系那些驱动程序作者询问 他们的信息来源总是一个好主"
"意。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:173
msgid ""
"Example: Human Interface Devices The specification for the Human Interface "
"Devices like keyboards, mice, tablets, buttons, dials,etc. is referred to in "
"other device class specifications and is used in many devices."
msgstr ""
"例子：人机界面设备。如键盘、鼠标、数字输入板、 按钮、拨号盘等的规范被其他设备"
"类规范引用，并在很多设备中使用。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:175
msgid ""
"For example audio speakers provide endpoints to the digital to analogue "
"converters and possibly an extra pipe for a microphone. They also provide a "
"HID endpoint in a separate interface for the buttons and dials on the front "
"of the device. The same is true for the monitor control class. It is "
"straightforward to build support for these interfaces through the available "
"kernel and userland libraries together with the HID class driver or the "
"generic driver. Another device that serves as an example for interfaces "
"within one configuration driven by different device drivers is a cheap "
"keyboard with built-in legacy mouse port. To avoid having the cost of "
"including the hardware for a USB hub in the device, manufacturers combined "
"the mouse data received from the PS/2 port on the back of the keyboard and "
"the key presses from the keyboard into two separate interfaces in the same "
"configuration. The mouse and keyboard drivers each attach to the appropriate "
"interface and allocate the pipes to the two independent endpoints."
msgstr ""
"例如，音频扬声器提供到数模转换器的端点，可能还提供额外管道 用于麦克风。它们也"
"为设备前面的按钮和拨号盘在单独的接口中提供HID 端点。监视器控制类也是如此。通"
"过可用的内核和用户空间的库，与HID 类驱动程序或通用驱动程序一起可以简单直接地"
"创建对这些接口的支持。 另一个设备可以作为在一个配置中的多个接口由不同的设备驱"
"动程序驱动 的例子，这个设备是一种便宜的键盘，带有老的鼠标接口。为了避免在 设"
"备中为USB集中器包括一个硬件而导致的成本上升，制造商将从键盘背面的 PS/2端口接"
"收到的鼠标数据与来自键盘的按键组合成在同一个配置中的 两个单独的接口。鼠标和键"
"盘驱动程序各自连接到适当的接口，并分配到 两个独立端点的管道."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:177
msgid ""
"Example: Firmware download Many devices that have been developed are based "
"on a general purpose processor with an additional USB core added to it. "
"Since the development of drivers and firmware for USB devices is still very "
"new, many devices require the downloading of the firmware after they have "
"been connected."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:179
msgid ""
"The procedure followed is straightforward. The device identifies itself "
"through a vendor and product Id. The first driver probes and attaches to it "
"and downloads the firmware into it. After that the device soft resets itself "
"and the driver is detached. After a short pause the device announces its "
"presence on the bus. The device will have changed its vendor/product/"
"revision Id to reflect the fact that it has been supplied with firmware and "
"as a consequence a second driver will probe it and attach to it."
msgstr ""
"下面的步骤非常简明直接。设备通过供应商和产品ID标识自身。第一 个驱动程序探测并"
"连接到它，并将固件下载到其中。此后设备自己软复位， 驱动程序分离。短暂的暂停之"
"后设备宣布它在总线上的存在。设备将改变 其供应商/产品/版本的ID以反映其提供有固"
"件的事实，因此另一个驱动程序 将探测它并连接(attach)到它。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:181
msgid ""
"An example of these types of devices is the ActiveWire I/O board, based on "
"the EZ-USB chip. For this chip a generic firmware downloader is available. "
"The firmware downloaded into the ActiveWire board changes the revision Id. "
"It will then perform a soft reset of the USB part of the EZ-USB chip to "
"disconnect from the USB bus and again reconnect."
msgstr ""
"这些类型的设备的一个例子是基于EZ-USB的ActiveWire I/O板。这个 芯片有一个通用固"
"件下载器。下载到ActiveWire板子上的固件改变版本ID。 然后它将执行EZ-USB芯片的"
"USB部分的软复位，从USB总线上断开，并再次 重新连接。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:183
msgid ""
"Example: Mass Storage Devices Support for mass storage devices is mainly "
"built around existing protocols. The Iomega USB Zipdrive is based on the "
"SCSI version of their drive. The SCSI commands and status messages are "
"wrapped in blocks and transferred over the bulk pipes to and from the "
"device, emulating a SCSI controller over the USB wire. ATAPI and UFI "
"commands are supported in a similar fashion."
msgstr ""
"例子：大容量存储设备。对大容量存储设备的支持主要围绕现有的 协议构建。Iomega "
"USB Zip驱动器是基于SCSI版本的驱动器。SCSI命令和 状态信息被包装到块中，在大块"
"(bulk)管道上传输到/来自设备，在USB线 上模拟SCSI控制器。ATAPI和UFI命令以相似的"
"方式被支持。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:185
msgid ""
"The Mass Storage Specification supports 2 different types of wrapping of the "
"command block.The initial attempt was based on sending the command and "
"status through the default pipe and using bulk transfers for the data to be "
"moved between the host and the device. Based on experience a second approach "
"was designed that was based on wrapping the command and status blocks and "
"sending them over the bulk out and in endpoint. The specification specifies "
"exactly what has to happen when and what has to be done in case an error "
"condition is encountered. The biggest challenge when writing drivers for "
"these devices is to fit USB based protocol into the existing support for "
"mass storage devices. CAM provides hooks to do this in a fairly straight "
"forward way. ATAPI is less simple as historically the IDE interface has "
"never had many different appearances."
msgstr ""
"大容量存储规范支持两种不同类型的对命令块的包装。最初的尝试 基于通过默认管道发"
"送命令和状态信息，使用大块传输在host和设备之间 移动数据。在经验基础上设计出另"
"一种方法，这种方法基于包装命令和 状态块，并在大块out和in端点上发送它们。规范"
"精确地指定了何时必须 发生什么，以及在碰到错误条件的情况下应该做什么。为这些设"
"备编写 驱动程序的最大挑战是协调基于USB的协议，让它适合已有的对大容量存储设备 "
"的支持。CAM提供了钩子，以相当直接了当的方式来完成这个。ATAPI就 没有这么简单"
"了，因为历史上IDE接口从未有过多种不同的表现方式。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/usb/_index.adoc:186
msgid ""
"The support for the USB floppy from Y-E Data is again less straightforward "
"as a new command set has been designed."
msgstr ""
"来自Y-E Data的对USB软盘的支持也不是那么直观，因为设计了一套 新的命令集。"
