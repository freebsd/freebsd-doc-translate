# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2025-05-01 19:56-0300\n"
"PO-Revision-Date: 2021-06-03 00:09+0000\n"
"Last-Translator: Anonymous <noreply@weblate.org>\n"
"Language-Team: Chinese (Simplified) <https://translate-dev.freebsd.org/"
"projects/documentation/booksarch-handbooksmp_index/zh_CN/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.6.2\n"

#. type: Title =
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:1
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:14
#, no-wrap
msgid "SMPng Design Document"
msgstr "SMPng 设计文档"

#. type: YAML Front Matter: title
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:1
#, no-wrap
msgid "Chapter 8. SMPng Design Document"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:52
#, no-wrap
msgid "Introduction"
msgstr "介绍"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:55
msgid ""
"This document presents the current design and implementation of the SMPng "
"Architecture. First, the basic primitives and tools are introduced. Next, a "
"general architecture for the FreeBSD kernel's synchronization and execution "
"model is laid out. Then, locking strategies for specific subsystems are "
"discussed, documenting the approaches taken to introduce fine-grained "
"synchronization and parallelism for each subsystem. Finally, detailed "
"implementation notes are provided to motivate design choices, and make the "
"reader aware of important implications involving the use of specific "
"primitives."
msgstr ""
"这份文档对目前 SMPng 架构的设计与实现进行了介绍。它首先介绍了基本的原语和相关"
"工具， 其后是关于FreeBSD 内核的同步与执行模型， 接下来讨论了具体系统中的锁策"
"略，并描述了在各个子系统中引入细粒度的同步和实现并行化的步骤，最后是详细的实"
"现说明， 用以解释最初做出某些设计决策的动机，并使读者了解使用特定的原语所可能"
"产生的重大影响。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:57
msgid ""
"This document is a work-in-progress, and will be updated to reflect on-going "
"design and implementation activities associated with the SMPng Project. Many "
"sections currently exist only in outline form, but will be fleshed out as "
"work proceeds. Updates or suggestions regarding the document may be directed "
"to the document editors."
msgstr ""
"这份文档仍在撰写当中， 并将不断更新以反映与 SMPng项目有关的最新设计与实现的情"
"况。 其中有许多小节目前还只是提纲，但我们会逐渐为其充实内容。 关于这份文档的"
"更新和建议，请发给文档编辑。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:63
#, fuzzy
msgid ""
"The goal of SMPng is to allow concurrency in the kernel. The kernel is "
"basically one rather large and complex program. To make the kernel multi-"
"threaded we use some of the same tools used to make other programs multi-"
"threaded. These include mutexes, shared/exclusive locks, semaphores, and "
"condition variables. For the definitions of these and other SMP-related "
"terms, please see the crossref:smp[smp-glossary, Glossary] section of this "
"article."
msgstr ""
"SMPng 的目标是使内核能够并发执行。 基本上，内核是一个很大而复杂的程序。 要让"
"内核能够多线程地执行，我们需要使用某些其它多线程程序在实现时所用到的工具，这"
"包括互斥体(mutex)、 共享/排他锁(shared/exclusive lock)、信号量(semaphores) 和"
"条件变量(condition variable)。如果希望了解它们以及其它 SMP 术语，请参阅本文"
"的 <xref linkend=\"smp-glossary\"/> 一节。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:65
#, no-wrap
msgid "Basic Tools and Locking Fundamentals"
msgstr "基本工具与上锁的基础知识"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:67
#, no-wrap
msgid "Atomic Instructions and Memory Barriers"
msgstr "原子操作指令和内存栅"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:70
msgid ""
"There are several existing treatments of memory barriers and atomic "
"instructions, so this section will not include a lot of detail. To put it "
"simply, one can not go around reading variables without a lock if a lock is "
"used to protect writes to that variable. This becomes obvious when you "
"consider that memory barriers simply determine relative order of memory "
"operations; they do not make any guarantee about timing of memory "
"operations. That is, a memory barrier does not force the contents of a CPU's "
"local cache or store buffer to flush. Instead, the memory barrier at lock "
"release simply ensures that all writes to the protected data will be visible "
"to other CPU's or devices if the write to release the lock is visible. The "
"CPU is free to keep that data in its cache or store buffer as long as it "
"wants. However, if another CPU performs an atomic instruction on the same "
"datum, the first CPU must guarantee that the updated value is made visible "
"to the second CPU along with any other operations that memory barriers may "
"require."
msgstr ""
"关于内存栅和原子操作指令已经有很多介绍材料，因此这一节并不打算对其进行详尽的"
"介绍。 简而言之， 如果有对某一变量上写锁，就不能在不获得相应的锁时对其进行读"
"取操作。 也就是说，内存栅的作用在于保证内存操作的相对顺序， 但并不保证内存操"
"作的严格时序。换言之， 内存栅并不保证 CPU 将本地快取缓存或存储缓冲的内容刷写"
"回内存，而是在锁释放时确保其所保护的数据， 对于能看到刚释放的那个锁的 CPU或设"
"备可见。 持有内存栅的 CPU可以在其快取缓存或存储缓冲中将数据保持其所希望的、 "
"任意长的时间，但如果其它 CPU 在同一数据元上执行原子操作， 则第一个 CPU 必须保"
"证，其所更新的数据值， 以及内存栅所要求的任何其它操作， 对第二个 CPU 可见。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:72
msgid ""
"For example, assuming a simple model where data is considered visible when "
"it is in main memory (or a global cache), when an atomic instruction is "
"triggered on one CPU, other CPU's store buffers and caches must flush any "
"writes to that same cache line along with any pending operations behind a "
"memory barrier."
msgstr ""
"例如， 假设在一简单模型中， 认为在主存 (或某一全局快取缓存)中的数据是可见"
"的， 当某一 CPU 上触发原子操作时， 其它 CPU的存储缓冲和快取缓存就必须对同一快"
"取缓存线上的全部写操作，以及内存栅之后的全部未完成操作进行刷写。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:74
msgid ""
"This requires one to take special care when using an item protected by "
"atomic instructions. For example, in the sleep mutex implementation, we have "
"to use an `atomic_cmpset` rather than an `atomic_set` to turn on the "
"`MTX_CONTESTED` bit. The reason is that we read the value of `mtx_lock` into "
"a variable and then make a decision based on that read. However, the value "
"we read may be stale, or it may change while we are making our decision. "
"Thus, when the `atomic_set` executed, it may end up setting the bit on "
"another value than the one we made the decision on. Thus, we have to use an "
"`atomic_cmpset` to set the value only if the value we made the decision on "
"is up-to-date and valid."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:76
msgid ""
"Finally, atomic instructions only allow one item to be updated or read. If "
"one needs to atomically update several items, then a lock must be used "
"instead. For example, if two counters must be read and have values that are "
"consistent relative to each other, then those counters must be protected by "
"a lock rather than by separate atomic instructions."
msgstr ""
"最后， 原子操作只允许一次更新或读一个内存单元。需要原子地更新多个单元时， 就"
"必须使用锁来代替它了。例如， 如果需要更新两个相互关联的计数器时，就必须使用"
"锁， 而不是两次单独的原子操作了。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:77
#, no-wrap
msgid "Read Locks Versus Write Locks"
msgstr "读锁与写锁"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:80
msgid ""
"Read locks do not need to be as strong as write locks. Both types of locks "
"need to ensure that the data they are accessing is not stale. However, only "
"write access requires exclusive access. Multiple threads can safely read a "
"value. Using different types of locks for reads and writes can be "
"implemented in a number of ways."
msgstr ""
"读锁并不需要像写锁那样强。 这两种类型的锁，都需要确保通过它们访问的不是过时的"
"数据。 然而，只有写操作必须是排他的， 而多个线程则可以安全地读同一变量的值。"
"使用不同类型的锁用于读和写操作有许多各自不同的实现方式。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:82
msgid ""
"First, sx locks can be used in this manner by using an exclusive lock when "
"writing and a shared lock when reading. This method is quite straightforward."
msgstr ""
"第一种方法是用 sx 锁， 它可以用于实现写时使用的排他锁，而读时则作为共享锁。 "
"这种方法十分简单明了。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:84
#, fuzzy
msgid ""
"A second method is a bit more obscure. You can protect a datum with multiple "
"locks. Then for reading that data you simply need to have a read lock of one "
"of the locks. However, to write to the data, you need to have a write lock "
"of all of the locks. This can make writing rather expensive but can be "
"useful when data is accessed in various ways. For example, the parent "
"process pointer is protected by both the `proctree_lock` sx lock and the per-"
"process mutex. Sometimes the proc lock is easier as we are just checking to "
"see who a parent of a process is that we already have locked. However, other "
"places such as `inferior` need to walk the tree of processes via parent "
"pointers and locking each process would be prohibitive as well as a pain to "
"guarantee that the condition you are checking remains valid for both the "
"check and the actions taken as a result of the check."
msgstr ""
"第二种方法则略显晦涩。 可以用多个锁来保护同一数据元。读时， 只需锁其中的一个"
"读锁即可。 然而， 如果要写数据的话，则需要首先上所有的写锁。 这会大大提高写操"
"作的代价，但当可能以多种方式访问数据时却可能非常有用。 例如，父进程指针是同时"
"受<varname>proctree_lock</varname> sx 锁和进程 mutex 保护的。在只希望检查已锁"
"进程的父进程时， 用 proc 锁更为方便。但是， 其它一些地方， 例如"
"<function>inferior</function> 这类需要通过父指针在进程树上进行搜索，并对每个"
"进程上锁的地方就不能这样做了，否则， 将无法保证在对我们所获得的结果执行操作"
"时，之前检查时的状况依旧有效。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:85
#, no-wrap
msgid "Locking Conditions and Results"
msgstr "上锁状态和结果"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:88
msgid ""
"If you need a lock to check the state of a variable so that you can take an "
"action based on the state you read, you can not just hold the lock while "
"reading the variable and then drop the lock before you act on the value you "
"read. Once you drop the lock, the variable can change rendering your "
"decision invalid. Thus, you must hold the lock both while reading the "
"variable and while performing the action as a result of the test."
msgstr ""
"如果您需要使用锁来保持所检查变量的状态， 并据此执行某些操作时，是不能仅仅在读"
"变量之前对其上锁， 并在执行操作之前解锁的。过早解锁将使变量再次可变， 这可能"
"会导致之前所做的决策失效。因此， 在所做检测引发的动作结束之前， 必须继续保持"
"上锁状态。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:90
#, no-wrap
msgid "General Architecture and Design"
msgstr "架构与设计概览"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:92
#, no-wrap
msgid "Interrupt Handling"
msgstr "对中断的处理"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:95
msgid ""
"Following the pattern of several other multi-threaded UNIX(R) kernels, "
"FreeBSD deals with interrupt handlers by giving them their own thread "
"context. Providing a context for interrupt handlers allows them to block on "
"locks. To help avoid latency, however, interrupt threads run at real-time "
"kernel priority. Thus, interrupt handlers should not execute for very long "
"to avoid starving other kernel threads. In addition, since multiple handlers "
"may share an interrupt thread, interrupt handlers should not sleep or use a "
"sleepable lock to avoid starving another interrupt handler."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:97
msgid ""
"The interrupt threads currently in FreeBSD are referred to as heavyweight "
"interrupt threads. They are called this because switching to an interrupt "
"thread involves a full context switch. In the initial implementation, the "
"kernel was not preemptive and thus interrupts that interrupted a kernel "
"thread would have to wait until the kernel thread blocked or returned to "
"userland before they would have an opportunity to run."
msgstr ""
"目前在 FreeBSD 中的中断线程是指重量级中断线程。这样称呼它们的原因在于， 转到"
"中断线程需要执行一次完整的上下文切换操作。在最初的实现中， 内核不允许抢占， "
"因此中断在打断内核线程之前，必须等待内核线程阻塞或返回用户态之后才能执行。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:99
msgid ""
"To deal with the latency problems, the kernel in FreeBSD has been made "
"preemptive. Currently, we only preempt a kernel thread when we release a "
"sleep mutex or when an interrupt comes in. However, the plan is to make the "
"FreeBSD kernel fully preemptive as described below."
msgstr ""
"为了解决响应时间问题， FreeBSD 内核现在采用了抢占式调度策略。目前， 只有释放"
"休眠 mutex 或发生中断时才能抢断内核线程，但最终目标是在 FreeBSD 上实现下面所"
"描述的全抢占式调度策略。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:101
#, fuzzy
msgid ""
"Not all interrupt handlers execute in a thread context. Instead, some "
"handlers execute directly in primary interrupt context. These interrupt "
"handlers are currently misnamed \"fast\" interrupt handlers since the "
"`INTR_FAST` flag used in earlier versions of the kernel is used to mark "
"these handlers. The only interrupts which currently use these types of "
"interrupt handlers are clock interrupts and serial I/O device interrupts. "
"Since these handlers do not have their own context, they may not acquire "
"blocking locks and thus may only use spin mutexes."
msgstr ""
"并非所有的中断处理程序都在独立的线程上下文中执行。相反， 某些处理程序会直接在"
"主中断上下文中执行。 这些中断处理程序，现在被错误地命名为<quote>快速</quote> "
"中断处理程序， 因为早期版本的内核中使用了<constant>INTR_FAST</constant> 标志"
"来标记这些处理程序。目前只有时钟中断和串口 I/O 设备中断采用这一类型。由于这些"
"处理程序没有独立的上下文， 因而它们都不能获得阻塞性锁，因此也就只能使用自旋 "
"mutex。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:103
msgid ""
"Finally, there is one optional optimization that can be added in MD code "
"called lightweight context switches. Since an interrupt thread executes in a "
"kernel context, it can borrow the vmspace of any process. Thus, in a "
"lightweight context switch, the switch to the interrupt thread does not "
"switch vmspaces but borrows the vmspace of the interrupted thread. In order "
"to ensure that the vmspace of the interrupted thread does not disappear out "
"from under us, the interrupted thread is not allowed to execute until the "
"interrupt thread is no longer borrowing its vmspace. This can happen when "
"the interrupt thread either blocks or finishes. If an interrupt thread "
"blocks, then it will use its own context when it is made runnable again. "
"Thus, it can release the interrupted thread."
msgstr ""
"最后， 还有一种称为轻量级上下文切换的优化，可以在 MD 代码中使用。 因为中断线"
"程都是在内核上下文中执行的，所以它可以借用任意进程的 vmspace (虚拟内存地址空"
"间)。 因此，在轻量级上下文切换中， 切换到中断线程并不切换对应的 vmspace，而是"
"借用被中断线程的 vmspace。 为确保被中断线程的 vmspace不在中断处理过程中消"
"失， 被中断线程在中断线程不再借用其 vmspace之前是不允许执行的。 刚才提到的情"
"况可能在中断线程阻塞或完成时发生。如果中断线程发生阻塞， 则它再次进入可运行状"
"态时将使用自己的上下文，这样一来， 就可以释放被中断的线程了。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:105
msgid ""
"The cons of this optimization are that they are very machine specific and "
"complex and thus only worth the effort if their is a large performance "
"improvement. At this point it is probably too early to tell, and in fact, "
"will probably hurt performance as almost all interrupt handlers will "
"immediately block on Giant and require a thread fix-up when they block. "
"Also, an alternative method of interrupt handling has been proposed by Mike "
"Smith that works like so:"
msgstr ""
"这种优化的坏处在于它们和硬件紧密相关， 而且实现比较复杂，因此只有在这样做能带"
"来大幅性能改善时才应采用。目前这样说可能还为时过早， 而且事实上可能会反而导致"
"性能下降，因为几乎所有的中断处理程序都会立即被全局锁 (Giant) 阻塞，而这种阻塞"
"将进而需要线程修正。 另外， Mike Smith提议采用另一种方式来处理中断线程："

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:107
msgid ""
"Each interrupt handler has two parts: a predicate which runs in primary "
"interrupt context and a handler which runs in its own thread context."
msgstr ""
"每个中断处理程序分为两部分， 一个在主中断上下文中运行的主体(predicate) 和一个"
"在自己的线程上下文中执行的处理程序 (handler)。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:108
msgid ""
"If an interrupt handler has a predicate, then when an interrupt is "
"triggered, the predicate is run. If the predicate returns true then the "
"interrupt is assumed to be fully handled and the kernel returns from the "
"interrupt. If the predicate returns false or there is no predicate, then the "
"threaded handler is scheduled to run."
msgstr ""
"如果中断处理程序拥有主体， 则当触发中断时， 执行该主体。如果主体返回真， 则认"
"为该中断被处理完毕， 内核从中断返回。如果主体返回假， 或者中断没有主体， 则调"
"度运行线程式处理程序。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:110
msgid ""
"Fitting light weight context switches into this scheme might prove rather "
"complicated. Since we may want to change to this scheme at some point in the "
"future, it is probably best to defer work on light weight context switches "
"until we have settled on the final interrupt handling architecture and "
"determined how light weight context switches might or might not fit into it."
msgstr ""
"在这一模式中适当地采用轻量级上下文切换可能是非常复杂的。因为我们可能会希望在"
"未来改变这一模式， 因此现在最好的方案，应该是暂时推迟在轻量级上下文切换之上的"
"工作，以便进一步完善中断处理架构， 随后再考察轻量级上下文切换是否适用。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:111
#, no-wrap
msgid "Kernel Preemption and Critical Sections"
msgstr "内核抢占与临界区"

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:113
#, no-wrap
msgid "Kernel Preemption in a Nutshell"
msgstr "内核抢占简介"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:116
msgid ""
"Kernel preemption is fairly simple. The basic idea is that a CPU should "
"always be doing the highest priority work available. Well, that is the ideal "
"at least. There are a couple of cases where the expense of achieving the "
"ideal is not worth being perfect."
msgstr ""
"内核抢占的概念很简单， 其基本思想是 CPU 总应执行优先级最高的工作。当然， 至少"
"在理想情况下是这样。 有些时候，达成这一理想的代价会十分高昂， 以至于在这些情"
"况下抢占会得不偿失。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:118
msgid ""
"Implementing full kernel preemption is very straightforward: when you "
"schedule a thread to be executed by putting it on a run queue, you check to "
"see if its priority is higher than the currently executing thread. If so, "
"you initiate a context switch to that thread."
msgstr ""
"实现完全的内核抢占十分简单： 在调度将要执行的线程并放入运行队列时，检查它的优"
"先级是否高于目前正在执行的线程。 如果是这样的话，执行一次上下文切换并立即开始"
"执行该线程。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:120
#, fuzzy
msgid ""
"While locks can protect most data in the case of a preemption, not all of "
"the kernel is preemption safe. For example, if a thread holding a spin mutex "
"preempted and the new thread attempts to grab the same spin mutex, the new "
"thread may spin forever as the interrupted thread may never get a chance to "
"execute. Also, some code such as the code to assign an address space number "
"for a process during `exec` on the Alpha needs to not be preempted as it "
"supports the actual context switch code. Preemption is disabled for these "
"code sections by using a critical section."
msgstr ""
"尽管锁能够在抢占时保护多数数据， 但内核并不是可以安全地处处抢占的。例如， 如"
"果持有自旋 mutex 的线程被抢占， 而新线程也尝试获得同一自旋mutex， 新线程就可"
"能一直自旋下去，因为被中断的线程可能永远没有机会运行了。 此外， 某些代码， 例"
"如在 Alpha 上的<function>exec</function> 对进程地址空间编号进行赋值的代码也不"
"能被抢断，因为它被用来支持实际的上下文切换操作。 在这些代码段中，会通过使用临"
"界区来临时禁用抢占。"

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:121
#, no-wrap
msgid "Critical Sections"
msgstr "临界区"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:124
#, fuzzy
msgid ""
"The responsibility of the critical section API is to prevent context "
"switches inside of a critical section. With a fully preemptive kernel, every "
"`setrunqueue` of a thread other than the current thread is a preemption "
"point. One implementation is for `critical_enter` to set a per-thread flag "
"that is cleared by its counterpart. If `setrunqueue` is called with this "
"flag set, it does not preempt regardless of the priority of the new thread "
"relative to the current thread. However, since critical sections are used in "
"spin mutexes to prevent context switches and multiple spin mutexes can be "
"acquired, the critical section API must support nesting. For this reason the "
"current implementation uses a nesting count instead of a single per-thread "
"flag."
msgstr ""
"临界区 API 的责任是避免在临界区内发生上下文切换。对于完全抢占式内核而言， 除"
"了当前线程之外的其它线程的每个<function>setrunqueue</function> 都是抢断点。"
"<function>critical_enter</function> 的一种实现方式是设置一线程私有标记，并由"
"其对应方清除。 如果调用<function>setrunqueue</function> 时设置了这个标志，则"
"无论新线程和当前线程相比其优先级高低， 都不会发生抢占。然而， 由于临界区会在"
"自旋 mutex 中用于避免上下文切换，而且能够同时获得多个自旋 mutex， 因此临界区 "
"API 必须支持嵌套。由于这个原因， 目前的实现中采用了嵌套计数，而不仅仅是单个的"
"线程标志。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:126
msgid ""
"In order to minimize latency, preemptions inside of a critical section are "
"deferred rather than dropped. If a thread that would normally be preempted "
"to is made runnable while the current thread is in a critical section, then "
"a per-thread flag is set to indicate that there is a pending preemption. "
"When the outermost critical section is exited, the flag is checked. If the "
"flag is set, then the current thread is preempted to allow the higher "
"priority thread to run."
msgstr ""
"为了尽可能缩短响应时间， 在临界区中的抢占被推迟，而不是直接丢弃。 如果线程应"
"被抢断， 并被置为可运行，而当前线程处于临界区， 则会设置一线程私有标志，表示"
"有一个尚未进行的抢断操作。 当最外层临界区退出时，会检查这一标志， 如果它被置"
"位， 则当前线程会被抢断，以允许更高优先级的线程开始运行。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:128
#, fuzzy
msgid ""
"Interrupts pose a problem with regards to spin mutexes. If a low-level "
"interrupt handler needs a lock, it needs to not interrupt any code needing "
"that lock to avoid possible data structure corruption. Currently, providing "
"this mechanism is piggybacked onto critical section API by means of the "
"`cpu_critical_enter` and `cpu_critical_exit` functions. Currently this API "
"disables and re-enables interrupts on all of FreeBSD's current platforms. "
"This approach may not be purely optimal, but it is simple to understand and "
"simple to get right. Theoretically, this second API need only be used for "
"spin mutexes that are used in primary interrupt context. However, to make "
"the code simpler, it is used for all spin mutexes and even all critical "
"sections. It may be desirable to split out the MD API from the MI API and "
"only use it in conjunction with the MI API in the spin mutex implementation. "
"If this approach is taken, then the MD API likely would need a rename to "
"show that it is a separate API."
msgstr ""
"中断会引发一个和自旋 mutex 有关的问题。如果低级中断处理程序需要锁， 它就不能"
"中断任何需要该锁的代码，以避免可能发生的损坏数据结构的情况。 目前，这一机制是"
"透过临界区 API以 <function>cpu_critical_enter</function> 和"
"<function>cpu_critical_exit</function> 函数的形式实现的。目前这一 API 会在所"
"有 FreeBSD所支持的平台上禁用和重新启用中断。 这种方法并不是最优的，但它更易理"
"解， 也更容易正确地实现。 理论上， 这一辅助 API只需要配合在主中断上下文中的自"
"旋 mutex 使用。 然而，为了让代码更为简单， 它被用在了全部自旋 mutex，甚至包括"
"所有临界区上。 将其从 MI API 中剥离出来放入 MD API，并只在需要使用它的 MI "
"API 的自旋 mutex 实现中使用可能会有更好的效果。如果我们最终采用了这种实现方"
"式， 则 MD API可能需要改名， 以彰显其为一单独 API 这一事实。"

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:129
#, no-wrap
msgid "Design Tradeoffs"
msgstr "设计折衷"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:132
msgid ""
"As mentioned earlier, a couple of trade-offs have been made to sacrifice "
"cases where perfect preemption may not always provide the best performance."
msgstr ""
"如前面提到的， 当完全抢占并非总能提供最佳性能时，采取了一些折衷的措施。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:134
msgid ""
"The first trade-off is that the preemption code does not take other CPUs "
"into account. Suppose we have a two CPU's A and B with the priority of A's "
"thread as 4 and the priority of B's thread as 2. If CPU B makes a thread "
"with priority 1 runnable, then in theory, we want CPU A to switch to the new "
"thread so that we will be running the two highest priority runnable threads. "
"However, the cost of determining which CPU to enforce a preemption on as "
"well as actually signaling that CPU via an IPI along with the "
"synchronization that would be required would be enormous. Thus, the current "
"code would instead force CPU B to switch to the higher priority thread. Note "
"that this still puts the system in a better position as CPU B is executing a "
"thread of priority 1 rather than a thread of priority 2."
msgstr ""
"第一处折衷是， 抢占代码并不考虑其它 CPU 的存在。假设我们有两个 CPU， A和 B， "
"其中 A 上线程的优先级为 4，而 B 上线程的优先级是 2。 如果 CPU B 令一优先级为 "
"1的线程进入可运行状态， 则理论上， 我们希望 CPU A 切换至这一新线程，这样就有"
"两个优先级最高的线程在运行了。 然而， 确定哪个CPU 在抢占时更合适， 并通过 "
"IPI 向那个 CPU 发出信号，并完成相关的同步工作的代价十分高昂。 因此， 目前的代"
"码会强制 CPU B切换至更高优先级的线程。 请注意这样做仍会让系统进入更好的状态，"
"因为 CPU B 会去执行优先级为 1 而不是 2 的那个线程。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:136
msgid ""
"The second trade-off limits immediate kernel preemption to real-time "
"priority kernel threads. In the simple case of preemption defined above, a "
"thread is always preempted immediately (or as soon as a critical section is "
"exited) if a higher priority thread is made runnable. However, many threads "
"executing in the kernel only execute in a kernel context for a short time "
"before either blocking or returning to userland. Thus, if the kernel "
"preempts these threads to run another non-realtime kernel thread, the kernel "
"may switch out the executing thread just before it is about to sleep or "
"execute. The cache on the CPU must then adjust to the new thread. When the "
"kernel returns to the preempted thread, it must refill all the cache "
"information that was lost. In addition, two extra context switches are "
"performed that could be avoided if the kernel deferred the preemption until "
"the first thread blocked or returned to userland. Thus, by default, the "
"preemption code will only preempt immediately if the higher priority thread "
"is a real-time priority thread."
msgstr ""
"第二处折衷是限制对于实时优先级的内核线程的立即抢占。在前面所定义的抢占操作的"
"简单情形中， 低优先级总会被立即抢断(或在其退出临界区后被抢断)。 然而， 许多在"
"内核中执行的线程，有很多只会执行很短的时间就会阻塞或返回用户态。 因此，如果内"
"核抢断这些线程并执行其它非实时的内核线程，则内核可能会在这些线程马上要休眠或"
"执行完毕之前切换出去。这样一来， CPU 就必须调整快取缓存以配合新线程的执行。当"
"内核返回到被抢断的线程时， 它又需要重新填充之前丢失的快取缓存信息。此外， 如"
"果内核能够将对将阻塞或返回用户态的那个线程的抢断延迟到这之后的话，还能够免去"
"两次额外的上下文切换。 因此， 默认情况下，只有在优先级较高的线程是实时线程"
"时， 抢占代码才会立即执行抢断操作。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:138
#, fuzzy
msgid ""
"Turning on full kernel preemption for all kernel threads has value as a "
"debugging aid since it exposes more race conditions. It is especially useful "
"on UP systems were many races are hard to simulate otherwise. Thus, there is "
"a kernel option `FULL_PREEMPTION` to enable preemption for all kernel "
"threads that can be used for debugging purposes."
msgstr ""
"启用针对所有内核线程的完全抢占对于调试非常有帮助，因为它会暴露出更多的竞态条"
"件 (race conditions)。在难以模拟这些竞态条件的单处理器系统中， 这显得尤其有"
"用。因此， 我们提供了内核选项 <literal>FULL_PREEMPTION</literal>来启用针对所"
"有内核线程的抢占， 这一选项主要用于调试目的。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:139
#, no-wrap
msgid "Thread Migration"
msgstr "线程迁移"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:142
#, fuzzy
msgid ""
"Simply put, a thread migrates when it moves from one CPU to another. In a "
"non-preemptive kernel this can only happen at well-defined points such as "
"when calling `msleep` or returning to userland. However, in the preemptive "
"kernel, an interrupt can force a preemption and possible migration at any "
"time. This can have negative affects on per-CPU data since with the "
"exception of `curthread` and `curpcb` the data can change whenever you "
"migrate. Since you can potentially migrate at any time this renders "
"unprotected per-CPU data access rather useless. Thus it is desirable to be "
"able to disable migration for sections of code that need per-CPU data to be "
"stable."
msgstr ""
"简单地说， 线程从一个 CPU 移动到另一个上的过程称作迁移。在非抢占式内核中， 这"
"只会在明确定义的点， 例如调用<function>msleep</function> 或返回至用户态时才会"
"发生。但是， 在抢占式内核中， 中断可能会在任何时候强制抢断，并导致迁移。 对"
"于 CPU 私有的数据而言这可能会带来一些负面影响， 因为除<varname>curthread</"
"varname> 和 <varname>curpcb</varname>以外的数据都可能在迁移过程中发生变化。 "
"由于存在潜在的线程迁移，使得未受保护的 CPU 私有数据访问变得无用。 这就需要在"
"某些代码段禁止迁移，以获得稳定的 CPU 私有数据。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:144
msgid ""
"Critical sections currently prevent migration since they do not allow "
"context switches. However, this may be too strong of a requirement to "
"enforce in some cases since a critical section also effectively blocks "
"interrupt threads on the current processor. As a result, another API has "
"been provided to allow the current thread to indicate that if it preempted "
"it should not migrate to another CPU."
msgstr ""
"目前我们采用临界区来避免迁移， 因为它们能够阻止上下文切换。但是， 这有时可能"
"是一种过于严厉的限制，因为临界区实际上会阻止当前处理器上的中断线程。 因而，提"
"供了另一个 API， 用以指示当前进程在被抢断时，不应迁移到另一 CPU。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:146
#, fuzzy
msgid ""
"This API is known as thread pinning and is provided by the scheduler. The "
"API consists of two functions: `sched_pin` and `sched_unpin`. These "
"functions manage a per-thread nesting count `td_pinned`. A thread is pinned "
"when its nesting count is greater than zero and a thread starts off unpinned "
"with a nesting count of zero. Each scheduler implementation is required to "
"ensure that pinned threads are only executed on the CPU that they were "
"executing on when the `sched_pin` was first called. Since the nesting count "
"is only written to by the thread itself and is only read by other threads "
"when the pinned thread is not executing but while `sched_lock` is held, then "
"`td_pinned` does not need any locking. The `sched_pin` function increments "
"the nesting count and `sched_unpin` decrements the nesting count. Note that "
"these functions only operate on the current thread and bind the current "
"thread to the CPU it is executing on at the time. To bind an arbitrary "
"thread to a specific CPU, the `sched_bind` and `sched_unbind` functions "
"should be used instead."
msgstr ""
"这组 API 也叫线程牵制， 它由调度器提供。 这组 API 包括两个函数："
"<function>sched_pin</function> 和<function>sched_unpin</function>。 这两个函"
"数用于管理线程私有的计数<varname>td_pinned</varname>。 如果嵌套计数大于零， "
"则线程将被锁住，而线程开始运行时其嵌套计数为零， 表示处于未牵制状态。 所有的"
"调度器实现中，都要求保证牵制线程只在它们首次调用 <function>sched_pin</"
"function>时所在的 CPU 上运行。 由于只有线程自己会写嵌套计数，而只有其它线程在"
"受牵制线程没有执行， 且持有<varname>sched_lock</varname> 锁时才会读嵌套计"
"数， 因此访问<varname>td_pinned</varname> 不必上锁。<function>sched_pin</"
"function> 函数会使嵌套计数递增，而 <function>sched_unpin</function> 则使其递"
"减。注意， 这些函数只操作当前线程， 并将其绑定到其执行它时所处的 CPU 上。要将"
"任意线程绑定到指定的 CPU 上， 则应使用 <function>sched_bind</function> 和"
"<function>sched_unbind</function>。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:147
#, no-wrap
msgid "Callouts"
msgstr "调出 (Callout)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:150
#, fuzzy
msgid ""
"The `timeout` kernel facility permits kernel services to register functions "
"for execution as part of the `softclock` software interrupt. Events are "
"scheduled based on a desired number of clock ticks, and callbacks to the "
"consumer-provided function will occur at approximately the right time."
msgstr ""
"内核机制 <function>timeout</function> 允许内核服务注册函数，以作为 "
"<function>softclock</function> 软件中断的一部分来执行。事件将基于所希望的时钟"
"嘀嗒的数目进行， 并在大约指定的时间回调用户提供的函数。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:152
#, fuzzy
msgid ""
"The global list of pending timeout events is protected by a global spin "
"mutex, `callout_lock`; all access to the timeout list must be performed with "
"this mutex held. When `softclock` is woken up, it scans the list of pending "
"timeouts for those that should fire. In order to avoid lock order reversal, "
"the `softclock` thread will release the `callout_lock` mutex when invoking "
"the provided `timeout` callback function. If the `CALLOUT_MPSAFE` flag was "
"not set during registration, then Giant will be grabbed before invoking the "
"callout, and then released afterwards. The `callout_lock` mutex will be re-"
"grabbed before proceeding. The `softclock` code is careful to leave the list "
"in a consistent state while releasing the mutex. If `DIAGNOSTIC` is enabled, "
"then the time taken to execute each function is measured, and a warning is "
"generated if it exceeds a threshold."
msgstr ""
"未决 timeout (超时) 事件的全局表是由一全局 mutex，<varname>callout_lock</"
"varname> 保护的； 所有对 timeout 表的访问，都必须首先拿到这个 mutex。 当 "
"<function>softclock</function>唤醒时， 它会扫描未决超时表， 并找出应启动的那"
"些。 为避免锁逆序，<function>softclock</function> 线程会在调用所提供的"
"<function>timeout</function> 回调函数时首先释放<varname>callout_lock</"
"varname> mutex。如果在注册时没有设置 <constant>CALLOUT_MPSAFE</constant> 标"
"志，则在调用调出函数之前， 还会抓取全局锁， 并在之后释放。 其后，"
"<varname>callout_lock</varname> mutex 会在继续处理前再次获得。"
"<function>softclock</function> 代码在释放这个 mutex时会非常小心地保持表的一致"
"状态。 如果启用了 <constant>DIAGNOSTIC</constant>，则每个函数的执行时间会被记"
"录， 如果超过了某一阈值， 则会产生警告。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:154
#, no-wrap
msgid "Specific Locking Strategies"
msgstr "特定数据的锁策略"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:156
#, no-wrap
msgid "Credentials"
msgstr "凭据（Credentials）"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:159
#, fuzzy
msgid ""
"`struct ucred` is the kernel's internal credential structure, and is "
"generally used as the basis for process-driven access control within the "
"kernel. BSD-derived systems use a \"copy-on-write\" model for credential "
"data: multiple references may exist for a credential structure, and when a "
"change needs to be made, the structure is duplicated, modified, and then the "
"reference replaced. Due to wide-spread caching of the credential to "
"implement access control on open, this results in substantial memory "
"savings. With a move to fine-grained SMP, this model also saves "
"substantially on locking operations by requiring that modification only "
"occur on an unshared credential, avoiding the need for explicit "
"synchronization when consuming a known-shared credential."
msgstr ""
"<varname remap=\"structname\">struct ucred</varname> 是内核内部的凭据结构体，"
"它通常作为内核中以进程为导向的访问控制的依据。BSD-派生的系统采用一种 <quote>"
"写时复制</quote> 的模型来处理凭据数据：同一凭据结构体可能存在多个引用， 如果"
"需要对其进行修改，则这个结构体将被复制、 修改， 然后替换该引用。由于在打开时"
"用于实现访问控制的凭据快取缓存广泛存在，这种做法会极大地节省内存。 在迁移到细"
"粒度的 SMP 时，这一模型也省去了大量的锁操作， 因为只有未共享的凭据才能实施修"
"改，因而避免了在使用共享凭据时额外的同步操作。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:161
msgid ""
"Credential structures with a single reference are considered mutable; shared "
"credential structures must not be modified or a race condition is risked. A "
"mutex, `cr_mtxp` protects the reference count of `struct ucred` so as to "
"maintain consistency. Any use of the structure requires a valid reference "
"for the duration of the use, or the structure may be released out from under "
"the illegitimate consumer."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:163
msgid ""
"The `struct ucred` mutex is a leaf mutex and is implemented via a mutex pool "
"for performance reasons."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:165
msgid ""
"Usually, credentials are used in a read-only manner for access control "
"decisions, and in this case `td_ucred` is generally preferred because it "
"requires no locking. When a process' credential is updated the `proc` lock "
"must be held across the check and update operations thus avoid races. The "
"process credential `p_ucred` must be used for check and update operations to "
"prevent time-of-check, time-of-use races."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:167
msgid ""
"If system call invocations will perform access control after an update to "
"the process credential, the value of `td_ucred` must also be refreshed to "
"the current process value. This will prevent use of a stale credential "
"following a change. The kernel automatically refreshes the `td_ucred` "
"pointer in the thread structure from the process `p_ucred` whenever a "
"process enters the kernel, permitting use of a fresh credential for kernel "
"access control."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:168
#, no-wrap
msgid "File Descriptors and File Descriptor Tables"
msgstr "文件描述符和文件描述符表"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:171
msgid "Details to follow."
msgstr "详细内容将在稍后增加。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:172
#, no-wrap
msgid "Jail Structures"
msgstr "Jail 结构体"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:175
msgid ""
"`struct prison` stores administrative details pertinent to the maintenance "
"of jails created using the man:jail[2] API. This includes the per-jail "
"hostname, IP address, and related settings. This structure is reference-"
"counted since pointers to instances of the structure are shared by many "
"credential structures. A single mutex, `pr_mtx` protects read and write "
"access to the reference count and all mutable variables inside the struct "
"jail. Some variables are set only when the jail is created, and a valid "
"reference to the `struct prison` is sufficient to read these values. The "
"precise locking of each entry is documented via comments in [.filename]#sys/"
"jail.h#."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:176
#, no-wrap
msgid "MAC Framework"
msgstr "MAC 框架"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:179
msgid ""
"The TrustedBSD MAC Framework maintains data in a variety of kernel objects, "
"in the form of `struct label`. In general, labels in kernel objects are "
"protected by the same lock as the remainder of the kernel object. For "
"example, the `v_label` label in `struct vnode` is protected by the vnode "
"lock on the vnode."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:181
#, fuzzy
msgid ""
"In addition to labels maintained in standard kernel objects, the MAC "
"Framework also maintains a list of registered and active policies. The "
"policy list is protected by a global mutex (`mac_policy_list_lock`) and a "
"busy count (also protected by the mutex). Since many access control checks "
"may occur in parallel, entry to the framework for a read-only access to the "
"policy list requires holding the mutex while incrementing (and later "
"decrementing) the busy count. The mutex need not be held for the duration of "
"the MAC entry operation--some operations, such as label operations on file "
"system objects--are long-lived. To modify the policy list, such as during "
"policy registration and de-registration, the mutex must be held and the "
"reference count must be zero, to prevent modification of the list while it "
"is in use."
msgstr ""
"除了嵌入到标准内核对象中的标签之外， MAC框架也需要维护一组包含已注册的和激活"
"策略的列表。 策略表和忙计数由一个全局mutex (<varname>mac_policy_list_lock</"
"varname>) 保护。由于能够同时并行地进行许多访问控制检查， 对策略表的只读访问，"
"在增减忙计数时， 框架的入口处需要首先持有这个 mutex。MAC 入口操作的过程中并不"
"需要长时间持有此 mutex -- 有些操作，例如文件系统对象上的标签操作 -- 是持久"
"的。 要修改策略表，例如在注册和解除注册策略时， 需要持有此 mutex， 而且要求引"
"用计数为零，以避免在用表时对其进行修改。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:183
#, fuzzy
msgid ""
"A condition variable, `mac_policy_list_not_busy`, is available to threads "
"that need to wait for the list to become unbusy, but this condition variable "
"must only be waited on if the caller is holding no other locks, or a lock "
"order violation may be possible. The busy count, in effect, acts as a form "
"of shared/exclusive lock over access to the framework: the difference is "
"that, unlike with an sx lock, consumers waiting for the list to become "
"unbusy may be starved, rather than permitting lock order problems with "
"regards to the busy count and other locks that may be held on entry to (or "
"inside) the MAC Framework."
msgstr ""
"对于需要等待表进入闲置状态的线程， 提供了一个条件变量"
"<varname>mac_policy_list_not_busy</varname>，但这一条件变量只能在调用者没有持"
"有其它锁时才能使用，否则可能会引发锁逆序问题。 忙计数在整个框架中事实上还扮演"
"了某种形式的共享/排他 锁的作用： 与 sx 锁不同的地方在于，等待列表进入闲置状态"
"的线程可以饿死， 而不是允许忙计数和其它在 MAC框架入口 (或内部) 的锁之间的逆序"
"情况。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:184
#, no-wrap
msgid "Modules"
msgstr "模块"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:187
#, fuzzy
msgid ""
"For the module subsystem there exists a single lock that is used to protect "
"the shared data. This lock is a shared/exclusive (SX) lock and has a good "
"chance of needing to be acquired (shared or exclusively), therefore there "
"are a few macros that have been added to make access to the lock more easy. "
"These macros can be located in [.filename]#sys/module.h# and are quite basic "
"in terms of usage. The main structures protected under this lock are the "
"`module_t` structures (when shared) and the global `modulelist_t` structure, "
"modules. One should review the related source code in [.filename]#kern/"
"kern_module.c# to further understand the locking strategy."
msgstr ""
"对于模块子系统， 用于保护共享数据使用了一个单独的锁， 它是一个 共享/排他(SX) "
"锁， 许多情况需要获得它 (以共享或排他的方式)，因此我们提供了几个方便使用的宏"
"来简化对这个锁的访问，这些宏可以在 <filename>sys/module.h</filename> 中找到，"
"其用法都非常简单明了。 这个锁保护的主要是<varname remap=\"structname"
"\">module_t</varname> (当以共享方式上锁)和全局的 <varname remap=\"structname"
"\">modulelist_t</varname> 这两个结构体，以及模块。 要更进一步理解这些锁策"
"略， 需要仔细阅读<filename>kern/kern_module.c</filename> 的源代码。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:188
#, no-wrap
msgid "Newbus Device Tree"
msgstr "Newbus 设备树"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:191
msgid ""
"The newbus system will have one sx lock. Readers will hold a shared (read) "
"lock (man:sx_slock[9]) and writers will hold an exclusive (write) lock (man:"
"sx_xlock[9]). Internal functions will not do locking at all. Externally "
"visible ones will lock as needed. Those items that do not matter if the race "
"is won or lost will not be locked, since they tend to be read all over the "
"place (e.g., man:device_get_softc[9]). There will be relatively few changes "
"to the newbus data structures, so a single lock should be sufficient and not "
"impose a performance penalty."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:192
#, no-wrap
msgid "Pipes"
msgstr "管道"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:195
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:217
msgid "..."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:196
#, no-wrap
msgid "Processes and Threads"
msgstr "进程和线程"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:199
#, fuzzy
msgid "process hierarchy"
msgstr "- 进程层次结构"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:201
#, fuzzy
msgid "proc locks, references"
msgstr "- proc 锁及其参考"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:203
#, fuzzy
msgid ""
"thread-specific copies of proc entries to freeze during system calls, "
"including td_ucred"
msgstr "- 在系统调用过程中线程私有的 proc 项副本，包括 td_ucred"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:205
#, fuzzy
msgid "inter-process operations"
msgstr "- 进程间操作"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:207
#, fuzzy
msgid "process groups and sessions"
msgstr "- 进程组和会话"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:208
#, no-wrap
msgid "Scheduler"
msgstr "调度"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:211
msgid ""
"Lots of references to `sched_lock` and notes pointing at specific primitives "
"and related magic elsewhere in the document."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:212
#, no-wrap
msgid "Select and Poll"
msgstr "Select 和 Poll"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:215
#, fuzzy
msgid ""
"The `select` and `poll` functions permit threads to block waiting on events "
"on file descriptors--most frequently, whether or not the file descriptors "
"are readable or writable."
msgstr ""
"<function>select</function> 和<function>poll</function> 这两个函数允许线程阻"
"塞并等待文件描述符上的事件 --最常见的情况是文件描述符是否可读或可写。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:218
#, no-wrap
msgid "SIGIO"
msgstr "SIGIO"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:221
msgid ""
"The SIGIO service permits processes to request the delivery of a SIGIO "
"signal to its process group when the read/write status of specified file "
"descriptors changes. At most one process or process group is permitted to "
"register for SIGIO from any given kernel object, and that process or group "
"is referred to as the owner. Each object supporting SIGIO registration "
"contains pointer field that is `NULL` if the object is not registered, or "
"points to a `struct sigio` describing the registration. This field is "
"protected by a global mutex, `sigio_lock`. Callers to SIGIO maintenance "
"functions must pass in this field \"by reference\" so that local register "
"copies of the field are not made when unprotected by the lock."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:223
msgid ""
"One `struct sigio` is allocated for each registered object associated with "
"any process or process group, and contains back-pointers to the object, "
"owner, signal information, a credential, and the general disposition of the "
"registration. Each process or progress group contains a list of registered "
"`struct sigio` structures, `p_sigiolst` for processes, and `pg_sigiolst` for "
"process groups. These lists are protected by the process or process group "
"locks respectively. Most fields in each `struct sigio` are constant for the "
"duration of the registration, with the exception of the `sio_pgsigio` field "
"which links the `struct sigio` into the process or process group list. "
"Developers implementing new kernel objects supporting SIGIO will, in "
"general, want to avoid holding structure locks while invoking SIGIO "
"supporting functions, such as `fsetown` or `funsetown` to avoid defining a "
"lock order between structure locks and the global SIGIO lock. This is "
"generally possible through use of an elevated reference count on the "
"structure, such as reliance on a file descriptor reference to a pipe during "
"a pipe operation."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:224
#, no-wrap
msgid "Sysctl"
msgstr "Sysctl"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:227
#, fuzzy
msgid ""
"The `sysctl` MIB service is invoked from both within the kernel and from "
"userland applications using a system call. At least two issues are raised in "
"locking: first, the protection of the structures maintaining the namespace, "
"and second, interactions with kernel variables and functions that are "
"accessed by the sysctl interface. Since sysctl permits the direct export "
"(and modification) of kernel statistics and configuration parameters, the "
"sysctl mechanism must become aware of appropriate locking semantics for "
"those variables. Currently, sysctl makes use of a single global sx lock to "
"serialize use of `sysctl`; however, it is assumed to operate under Giant and "
"other protections are not provided. The remainder of this section speculates "
"on locking and semantic changes to sysctl."
msgstr ""
"<function>sysctl</function> MIB 服务会从内核内部，以及用户态的应用程序以系统"
"调用的方式触发。这会引发至少两个和锁有关的问题： 其一是对维持命名空间的数据结"
"构的保护，其二是与那些通过 sysctl 接口访问的内核变量和函数之间的交互。由于 "
"sysctl 允许直接导出 (甚至修改) 内核统计数据以及配置参数， sysctl机制必须知道"
"这些变量相应的上锁语义。 目前， sysctl 使用一个全局 sx锁来实现对 "
"<function>sysctl</function> 操作的串行化；然而， 这些是假定用全局锁保护的， "
"并且没有提供其它保护机制。这一节的其余部分将详细介绍上锁和 sysctl 相关变动的"
"语义。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:229
#, fuzzy
msgid ""
"Need to change the order of operations for sysctl's that update values from "
"read old, copyin and copyout, write new to copyin, lock, read old and write "
"new, unlock, copyout. Normal sysctl's that just copyout the old value and "
"set a new value that they copyin may still be able to follow the old model. "
"However, it may be cleaner to use the second model for all of the sysctl "
"handlers to avoid lock operations."
msgstr ""
"- 需要将 sysctl 更新值所进行的操作的顺序， 从原先的读旧值、copyin 和 "
"copyout、 写新值， 改为 copyin、 上锁、 读旧值、 写新值、解锁、 copyout。 一"
"般的 sysctl 只是 copyout 旧值并设置它们 copyin所得到的新值， 仍然可以采用旧式"
"的模型。 然而，对所有 sysctl 处理程序采用第二种模型并避免锁操作方面，第二种方"
"式可能更规矩一些。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:231
#, fuzzy
msgid ""
"To allow for the common case, a sysctl could embed a pointer to a mutex in "
"the SYSCTL_FOO macros and in the struct. This would work for most sysctl's. "
"For values protected by sx locks, spin mutexes, or other locking strategies "
"besides a single sleep mutex, SYSCTL_PROC nodes could be used to get the "
"locking right."
msgstr ""
"- 对于通常的情况， sysctl 可以内嵌一个 mutex 指针到 SYSCTL_FOO宏和结构体中。 "
"这对多数 sysctl 都是有效的。 对于使用 sx锁、 自旋 mutex， 或其它除单一休眠 "
"mutex 之外的锁策略，可以用 SYSCTL_PROC 节点来完成正确的上锁。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:232
#, no-wrap
msgid "Taskqueue"
msgstr "任务队列 (Taskqueue)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:235
#, fuzzy
msgid ""
"The taskqueue's interface has two basic locks associated with it in order to "
"protect the related shared data. The `taskqueue_queues_mutex` is meant to "
"serve as a lock to protect the `taskqueue_queues` TAILQ. The other mutex "
"lock associated with this system is the one in the `struct taskqueue` data "
"structure. The use of the synchronization primitive here is to protect the "
"integrity of the data in the `struct taskqueue`. It should be noted that "
"there are no separate macros to assist the user in locking down his/her own "
"work since these locks are most likely not going to be used outside of [."
"filename]#kern/subr_taskqueue.c#."
msgstr ""
"任务队列 (taskqueue) 的接口包括两个与之关联的用于保护相关数据的锁。"
"<varname>taskqueue_queues_mutex</varname> 是用于保护"
"<varname>taskqueue_queues</varname> TAILQ 的锁。与这个系统关联的另一个 mutex "
"锁是位于<varname remap=\"structname\">struct taskqueue</varname> 结构体上。在"
"此处使用同步原语的目的在于保护 <varname remap=\"structname"
"\">structtaskqueue</varname> 中数据的完整性。 应注意的是，并没有单独的、 帮助"
"用户对其自身的工作进行锁的细化用的宏，因为这些锁基本上不会在<filename>kern/"
"subr_taskqueue.c</filename> 以外的地方用到。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:237
#, no-wrap
msgid "Implementation Notes"
msgstr "实现说明"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:239
#, no-wrap
msgid "Sleep Queues"
msgstr "休眠队列"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:242
msgid ""
"A sleep queue is a structure that holds the list of threads asleep on a wait "
"channel. Each thread that is not asleep on a wait channel carries a sleep "
"queue structure around with it. When a thread blocks on a wait channel, it "
"donates its sleep queue structure to that wait channel. Sleep queues "
"associated with a wait channel are stored in a hash table."
msgstr ""
"休眠队列是一种用于保存同处一个等待通道 (wait channel)上休眠线程列表的数据结"
"构。 在等待通道上，每个处于非睡眠状态的线程都会携带一个休眠队列结构。当线程在"
"等待通道上发生阻塞时， 它会将休眠队列结构体送给那个等待通道。与等待通道关联的"
"休眠队列则保存在一个散列表中。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:244
msgid ""
"The sleep queue hash table holds sleep queues for wait channels that have at "
"least one blocked thread. Each entry in the hash table is called a "
"sleepqueue chain. The chain contains a linked list of sleep queues and a "
"spin mutex. The spin mutex protects the list of sleep queues as well as the "
"contents of the sleep queue structures on the list. Only one sleep queue is "
"associated with a given wait channel. If multiple threads block on a wait "
"channel than the sleep queues associated with all but the first thread are "
"stored on a list of free sleep queues in the master sleep queue. When a "
"thread is removed from the sleep queue it is given one of the sleep queue "
"structures from the master queue's free list if it is not the only thread "
"asleep on the queue. The last thread is given the master sleep queue when it "
"is resumed. Since threads may be removed from the sleep queue in a different "
"order than they are added, a thread may depart from a sleep queue with a "
"different sleep queue structure than the one it arrived with."
msgstr ""
"休眠队列散列表中保存了包含至少一个阻塞线程的等待通道上的休眠队列。这个散列表"
"上的项称作 sleepqueue (休眠队列) 链。 它包含了一个休眠队列的链表，以及一个自"
"旋 mutex。 此处的自旋 mutex 用于保护休眠队列表，以及其上休眠队列结构的内容。 "
"一个等待通道上只会关联一个休眠队列。如果有多个线程在同一等待通道上阻塞，则休"
"眠队列中将关联除第一个线程之外的全部线程。 当从休眠队列中删除线程时，如果它不"
"是唯一的阻塞的休眠线程， 则会获得主休眠队列的空闲表上的休眠队列结构。最后一个"
"线程会在恢复运行时获得主休眠队列。由于线程有可能以和加入休眠队列不同的次序从"
"其中删除，因此， 线程离开队列时可能会携带与其进入时不同的休眠队列。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:246
#, fuzzy
msgid ""
"The `sleepq_lock` function locks the spin mutex of the sleep queue chain "
"that maps to a specific wait channel. The `sleepq_lookup` function looks in "
"the hash table for the master sleep queue associated with a given wait "
"channel. If no master sleep queue is found, it returns `NULL`. The "
"`sleepq_release` function unlocks the spin mutex associated with a given "
"wait channel."
msgstr ""
"<function>sleepq_lock</function> 函数会锁住指定等待通道上休眠队列链的自旋"
"mutex。 <function>sleepq_lookup</function>函数会在主休眠队列散列表中查找给定"
"的等待通道。 如果没有找到主休眠队列，它会返回 <constant>NULL</constant>。"
"<function>sleepq_release</function> 函数会对给定等待通道所关联的自旋mutex 进"
"行解锁。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:248
#, fuzzy
msgid ""
"A thread is added to a sleep queue via the `sleepq_add`. This function "
"accepts the wait channel, a pointer to the mutex that protects the wait "
"channel, a wait message description string, and a mask of flags. The sleep "
"queue chain should be locked via `sleepq_lock` before this function is "
"called. If no mutex protects the wait channel (or it is protected by Giant), "
"then the mutex pointer argument should be `NULL`. The flags argument "
"contains a type field that indicates the kind of sleep queue that the thread "
"is being added to and a flag to indicate if the sleep is interruptible "
"(`SLEEPQ_INTERRUPTIBLE`). Currently there are only two types of sleep "
"queues: traditional sleep queues managed via the `msleep` and `wakeup` "
"functions (`SLEEPQ_MSLEEP`) and condition variable sleep queues "
"(`SLEEPQ_CONDVAR`). The sleep queue type and lock pointer argument are used "
"solely for internal assertion checking. Code that calls `sleepq_add` should "
"explicitly unlock any interlock protecting the wait channel after the "
"associated sleepqueue chain has been locked via `sleepq_lock` and before "
"blocking on the sleep queue via one of the waiting functions."
msgstr ""
"将线程加入休眠队列是通过<function>sleepq_add</function> 来完成的。这个函数的"
"参数包括等待通道、 指向保护等待通道的 mutex 的指针、等待消息描述串， 以及一个"
"标志掩码。 调用此函数之前， 应通过<function>sleepq_lock</function> 为休眠队列"
"链上锁。如果等待通道不是通过 mutex 保护的 (或者它由全局锁保护)，则应将 mutex "
"指针设置为<constant>NULL</constant>。 而 flags (标志) 参数则包括了一个类型字"
"段，用以表示线程即将加入到的休眠队列的类型，以及休眠是否是可中断的 "
"(<constant>SLEEPQ_INTERRUPTIBLE</constant>)。目前只有两种类型的休眠队列： 通"
"过<function>msleep</function> 和 <function>wakeup</function>函数管理的传统休"
"眠队列 (<constant>SLEEPQ_MSLEEP</constant>)，以及基于条件变量的休眠队列 "
"(<constant>SLEEPQ_CONDVAR</constant>)。休眠队列类型和锁指针这两个参数完全是用"
"于内部的断言检查。 调用<function>sleepq_add</function> 的代码， 应明示地在关"
"联的 sleepqueue 链透过<function>sleepq_lock</function> 进行上锁之后， 并使用"
"等待函数在休眠队列上阻塞之前解锁所有用于保护等待通道的interlock。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:250
#, fuzzy
msgid ""
"A timeout for a sleep is set by invoking `sleepq_set_timeout`. The function "
"accepts the wait channel and the timeout time as a relative tick count as "
"its arguments. If a sleep should be interrupted by arriving signals, the "
"`sleepq_catch_signals` function should be called as well. This function "
"accepts the wait channel as its only parameter. If there is already a signal "
"pending for this thread, then `sleepq_catch_signals` will return a signal "
"number; otherwise, it will return 0."
msgstr ""
"通过使用<function>sleepq_set_timeout</function> 可以为休眠设置超时。这个函数"
"的参数包括等待通道， 以及以相对时钟嘀嗒数为单位的超时时间。如果休眠应被某个到"
"来的信号打断， 则还应调用<function>sleepq_catch_signals</function> 函数，这个"
"函数唯一的参数就是等待通道。 如果此线程已经有未决信号，则 "
"<function>sleepq_catch_signals</function> 将返回信号编号；其它情况下， 其返回"
"值则是 0。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:252
#, fuzzy
msgid ""
"Once a thread has been added to a sleep queue, it blocks using one of the "
"`sleepq_wait` functions. There are four wait functions depending on whether "
"or not the caller wishes to use a timeout or have the sleep aborted by "
"caught signals or an interrupt from the userland thread scheduler. The "
"`sleepq_wait` function simply waits until the current thread is explicitly "
"resumed by one of the wakeup functions. The `sleepq_timedwait` function "
"waits until either the thread is explicitly resumed or the timeout set by an "
"earlier call to `sleepq_set_timeout` expires. The `sleepq_wait_sig` function "
"waits until either the thread is explicitly resumed or its sleep is aborted. "
"The `sleepq_timedwait_sig` function waits until either the thread is "
"explicitly resumed, the timeout set by an earlier call to "
"`sleepq_set_timeout` expires, or the thread's sleep is aborted. All of the "
"wait functions accept the wait channel as their first parameter. In "
"addition, the `sleepq_timedwait_sig` function accepts a second boolean "
"parameter to indicate if the earlier call to `sleepq_catch_signals` found a "
"pending signal."
msgstr ""
"一旦将线程加入到休眠队列中，就可以使用 <function>sleepq_wait</function> 函数"
"族之一将其阻塞了。目前总共提供了四个等待函数， 使用哪个取决于调用这是否希望允"
"许使用超时、收到信号， 或用户态线程调度器打断休眠状态。其中， "
"<function>sleepq_wait</function> 函数简单地等待，直到当前线程通过某个唤醒 "
"(wakeup) 函数显式地恢复运行；<function>sleepq_timedwait</function> 函数则等"
"待，直到当前线程被显式地唤醒， 或者达到早前使用 "
"<function>sleepq_set_timeout</function>设置的超时； "
"<function>sleepq_wait_sig</function> 函数会等待显式地唤醒，或者其休眠被中"
"断； 而<function>sleepq_timedwait_sig</function> 函数则等待显式地唤醒、达到"
"用 <function>sleepq_set_timeout</function>设置的超时， 或线程的休眠被中断这三"
"种条件之一。所有这些等待函数的第一个参数都是等待通道。除此之外， "
"<function>sleepq_timedwait_sig</function>的第二个参数是一个布尔值， 表示之前"
"调用 <function>sleepq_catch_signals</function>时是否有发现未决信号。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:254
#, fuzzy
msgid ""
"If the thread is explicitly resumed or is aborted by a signal, then a value "
"of zero is returned by the wait function to indicate a successful sleep. If "
"the thread is resumed by either a timeout or an interrupt from the userland "
"thread scheduler then an appropriate errno value is returned instead. Note "
"that since `sleepq_wait` can only return 0 it does not return anything and "
"the caller should assume a successful sleep. Also, if a thread's sleep times "
"out and is aborted simultaneously then `sleepq_timedwait_sig` will return an "
"error indicating that a timeout occurred. If an error value of 0 is returned "
"and either `sleepq_wait_sig` or `sleepq_timedwait_sig` was used to block, "
"then the function `sleepq_calc_signal_retval` should be called to check for "
"any pending signals and calculate an appropriate return value if any are "
"found. The signal number returned by the earlier call to "
"`sleepq_catch_signals` should be passed as the sole argument to "
"`sleepq_calc_signal_retval`."
msgstr ""
"如果线程被显式地恢复运行， 或其休眠被信号终止，则等待函数会返回零， 表示休眠"
"成功。如果线程的休眠被超时或用户态线程调度器打断， 则会返回相应的 errno 数"
"值。需要注意的是， 因为 <function>sleepq_wait</function> 只能返回 0，因此调用"
"者不能指望它返回什么有用信息， 而应假定它完成了一次成功的休眠。同时， 如果线"
"程的休眠时间超时， 并同时被终止， 则<function>sleepq_timedwait_sig</"
"function> 将返回一个表示发生超时的错误代码。如果返回错误代码是0 而且使用 "
"<function>sleepq_wait_sig</function>或 <function>sleepq_timedwait_sig</"
"function> 来执行阻塞， 则应调用<function>sleepq_calc_signal_retval</"
"function> 来检查是否有未决信号，并据此选择合适的返回值。 较早前调用"
"<function>sleepq_catch_signals</function> 得到的信号编号，应作为参数传给"
"<function>sleepq_calc_signal_retval</function>。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:256
#, fuzzy
msgid ""
"Threads asleep on a wait channel are explicitly resumed by the "
"`sleepq_broadcast` and `sleepq_signal` functions. Both functions accept the "
"wait channel from which to resume threads, a priority to raise resumed "
"threads to, and a flags argument to indicate which type of sleep queue is "
"being resumed. The priority argument is treated as a minimum priority. If a "
"thread being resumed already has a higher priority (numerically lower) than "
"the priority argument then its priority is not adjusted. The flags argument "
"is used for internal assertions to ensure that sleep queues are not being "
"treated as the wrong type. For example, the condition variable functions "
"should not resume threads on a traditional sleep queue. The "
"`sleepq_broadcast` function resumes all threads that are blocked on the "
"specified wait channel while `sleepq_signal` only resumes the highest "
"priority thread blocked on the wait channel. The sleep queue chain should "
"first be locked via the `sleepq_lock` function before calling these "
"functions."
msgstr ""
"在同一休眠通道上休眠的线程，可以由 <function>sleepq_broadcast</function> 或"
"<function>sleepq_signal</function> 函数来显式地唤醒。这两个函数的参数均包括希"
"望唤醒的等待通道、将唤醒线程的优先级 (priority) 提高到多少，以及一个标志 "
"(flags) 参数表示将要恢复运行的休眠队列类型。优先级参数将作为最低优先级， 如果"
"将恢复的线程的优先级比此参数更高(数值更低) 则其优先级不会调整。 标志参数主要"
"用于函数内部的断言，用以确认休眠队列没有被当做错误的类型对待。 例如，条件变量"
"函数不应恢复传统休眠队列的执行。 <function>sleepq_broadcast</function>函数将"
"恢复所有指定休眠通道上的阻塞线程，而 <function>sleepq_signal</function> 则只"
"恢复在等待通道上优先级最高的阻塞线程。在调用这些函数之前， 应首先使用"
"<function>sleepq_lock</function> 对休眠队列上锁。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:258
#, fuzzy
msgid ""
"A sleeping thread may have its sleep interrupted by calling the "
"`sleepq_abort` function. This function must be called with `sched_lock` held "
"and the thread must be queued on a sleep queue. A thread may also be removed "
"from a specific sleep queue via the `sleepq_remove` function. This function "
"accepts both a thread and a wait channel as an argument and only awakens the "
"thread if it is on the sleep queue for the specified wait channel. If the "
"thread is not on a sleep queue or it is on a sleep queue for a different "
"wait channel, then this function does nothing."
msgstr ""
"休眠线程也可以通过调用 <function>sleepq_abort</function> 函数来中断其休眠状"
"态。这个函数只有在持有 <varname>sched_lock</varname> 时才能调用，而且线程必须"
"处于休眠队列之上。 线程也可以通过使用<function>sleepq_remove</function> 函数"
"从指定的休眠队列中删除。这个函数包括两个参数， 即休眠通道和线程，它只在线程处"
"于指定休眠通道的休眠队列之上时才将其唤醒。如果线程不在那个休眠队列之上， 或同"
"时处于另一等待通道的休眠队列上，则这个函数将什么都不做而直接返回。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:259
#, no-wrap
msgid "Turnstiles"
msgstr "十字转门 (turnstile)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:262
#, fuzzy
msgid "Compare/contrast with sleep queues."
msgstr "- 与休眠队列的比较和不同。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:264
#, fuzzy
msgid "Lookup/wait/release. - Describe TDF_TSNOBLOCK race."
msgstr ""
"- 查询/等待/释放 (lookup/wait/release)。- 介绍 TDF_TSNOBLOCK 竞态条件。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:266
#, fuzzy
msgid "Priority propagation."
msgstr "- 优先级传播。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:267
#, no-wrap
msgid "Details of the Mutex Implementation"
msgstr "关于 mutex 实现的一些细节"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:270
#, fuzzy
msgid ""
"Should we require mutexes to be owned for mtx_destroy() since we can not "
"safely assert that they are unowned by anyone else otherwise?"
msgstr ""
"- 我们是否应要求  mtx_destroy() 持有 mutex，因为无法安全地断言它们没有被其它"
"对象持有？"

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:271
#, no-wrap
msgid "Spin Mutexes"
msgstr "自旋 mutex"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:274
#, fuzzy
msgid "Use a critical section..."
msgstr "- 使用一临界区..."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:275
#, no-wrap
msgid "Sleep Mutexes"
msgstr "休眠 mutex"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:278
#, fuzzy
msgid "Describe the races with contested mutexes"
msgstr "- 描述 mutex 冲突时的竞态条件"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:280
#, fuzzy
msgid ""
"Why it is safe to read mtx_lock of a contested mutex when holding the "
"turnstile chain lock."
msgstr "- 为何在持有十字转门链锁时， 可以安全地读冲突 mutex 的 mtx_lock。"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:281
#, no-wrap
msgid "Witness"
msgstr "Witness"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:284
#, fuzzy
msgid "What does it do"
msgstr "- 它能做什么"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:286
#, fuzzy
msgid "How does it work"
msgstr "- 它如何工作"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:288
#, no-wrap
msgid "Miscellaneous Topics"
msgstr "其它话题"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:290
#, no-wrap
msgid "Interrupt Source and ICU Abstractions"
msgstr "中断源和 ICU 抽象"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:293
#, fuzzy
msgid "struct isrc"
msgstr "- struct isrc"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:295
#, fuzzy
msgid "pic drivers"
msgstr "- pic 驱动"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:296
#, no-wrap
msgid "Other Random Questions/Topics"
msgstr "其它问题/话题"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:299
msgid "Should we pass an interlock into `sema_wait`?"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:301
#, fuzzy
msgid "Should we have non-sleepable sx locks?"
msgstr "- 增加一些关于正确使用引用计数的介绍？"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:303
#, fuzzy
msgid "Add some info about proper use of reference counts."
msgstr "- 增加一些关于正确使用引用计数的介绍。"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:308
#, no-wrap
msgid "Glossary"
msgstr "术语表"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:311
#, no-wrap
msgid "atomic"
msgstr "原子"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:313
msgid ""
"An operation is atomic if all of its effects are visible to other CPUs "
"together when the proper access protocol is followed. In the degenerate case "
"are atomic instructions provided directly by machine architectures. At a "
"higher level, if several members of a structure are protected by a lock, "
"then a set of operations are atomic if they are all performed while holding "
"the lock without releasing the lock in between any of the operations."
msgstr ""
"当遵循适当的访问协议时， 如果一操作的效果对其它所有 CPU均可见， 则称其为原子"
"操作。 狭义的原子操作是机器直接提供的。就更高的抽象层次而言， 如果结构体的多"
"个成员由一个锁保护，则如果对它们的操作都是在上锁后、 解锁前进行的，也可以称其"
"为原子操作。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:315
msgid "See Also operation."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:316
#, no-wrap
msgid "block"
msgstr "阻塞块"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:318
msgid ""
"A thread is blocked when it is waiting on a lock, resource, or condition. "
"Unfortunately this term is a bit overloaded as a result."
msgstr "线程等待锁、 资源或条件时被阻塞。这一术语也因此被赋予了太多的意涵。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:320
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:357
msgid "See Also sleep."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:321
#, no-wrap
msgid "critical section"
msgstr "临界区"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:323
msgid ""
"A section of code that is not allowed to be preempted. A critical section is "
"entered and exited using the man:critical_enter[9] API."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:324
#, no-wrap
msgid "MD"
msgstr "MD (Machine dependent)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:326
msgid "Machine dependent."
msgstr "表示与机器/平台有关。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:328
msgid "See Also MI."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:329
#, no-wrap
msgid "memory operation"
msgstr "内存操作"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:331
msgid "A memory operation reads and/or writes to a memory location."
msgstr "内存操作包括读或写内存中的指定位置。"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:332
#, no-wrap
msgid "MI"
msgstr "MI （Machine independent）"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:334
msgid "Machine independent."
msgstr "表示与机器/平台无关。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:336
msgid "See Also MD."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:337
#, no-wrap
msgid "operation"
msgstr "操作"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:339
msgid "See memory operation."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:340
#, no-wrap
msgid "primary interrupt context"
msgstr "主中断上下文"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:342
msgid ""
"Primary interrupt context refers to the code that runs when an interrupt "
"occurs. This code can either run an interrupt handler directly or schedule "
"an asynchronous interrupt thread to execute the interrupt handlers for a "
"given interrupt source."
msgstr ""
"主中断上下文表示当发生中断时所执行的那段代码。这些代码可以直接运行某个中断处"
"理程序， 或调度一异步终端线程，以便为给定的中断源执行中断处理程序。"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:343
#, no-wrap
msgid "realtime kernel thread"
msgstr "实时内核线程"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:345
msgid ""
"A high priority kernel thread. Currently, the only realtime priority kernel "
"threads are interrupt threads."
msgstr "一种高优先级的内核线程。 目前，只有中断线程属于实时优先级的内核线程。"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:347
msgid "See Also thread."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:348
#, no-wrap
msgid "sleep"
msgstr "睡眠"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:350
msgid ""
"A thread is asleep when it is blocked on a condition variable or a sleep "
"queue via msleep or tsleep."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:352
msgid "See Also block."
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:353
#, no-wrap
msgid "sleepable lock"
msgstr "可休眠锁"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:355
msgid ""
"A sleepable lock is a lock that can be held by a thread which is asleep. "
"Lockmgr locks and sx locks are currently the only sleepable locks in "
"FreeBSD. Eventually, some sx locks such as the allproc and proctree locks "
"may become non-sleepable locks."
msgstr ""
"可休眠锁是一种在进程休眠时仍可持有的锁。锁管理器 (lockmgr) 锁和 sx 锁是目前 "
"FreeBSD 中仅有的可休眠锁。最终， 某些 sx 锁， 例如 allproc (全部进程) 和 "
"proctree (进程树)锁将成为不可休眠锁。"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:358
#, no-wrap
msgid "thread"
msgstr "线程"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:360
msgid ""
"A kernel thread represented by a struct thread. Threads own locks and hold a "
"single execution context."
msgstr ""
"由 struct thread 所表达的内核线程。 线程可以持有锁，并拥有独立的执行上下文。"

#. type: Labeled list
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:361
#, no-wrap
msgid "wait channel"
msgstr "等待通道"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/smp/_index.adoc:363
msgid "A kernel virtual address that threads may sleep on."
msgstr "线程可以在其上休眠的内核虚拟地址。"
