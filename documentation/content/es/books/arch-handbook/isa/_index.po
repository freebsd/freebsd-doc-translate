# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Fernando  Apesteguía <fernando.apesteguia@gmail.com>, 2021, 2023.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2025-05-01 19:56-0300\n"
"PO-Revision-Date: 2023-07-18 08:07+0000\n"
"Last-Translator: Fernando  Apesteguía <fernando.apesteguia@gmail.com>\n"
"Language-Team: Spanish <https://translate-dev.freebsd.org/projects/"
"documentation/booksarch-handbookisa_index/es/>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 4.17\n"

#. type: Title =
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:14
#, no-wrap
msgid "ISA Device Drivers"
msgstr "Controladores de Dispositivos ISA"

#. type: YAML Front Matter: title
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1
#, no-wrap
msgid "Chapter 10. ISA Device Drivers"
msgstr "Capítulo 10. Controladores de Dispositivos ISA"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:52
#, no-wrap
msgid "Synopsis"
msgstr "Sinopsis"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:55
msgid ""
"This chapter introduces the issues relevant to writing a driver for an ISA "
"device. The pseudo-code presented here is rather detailed and reminiscent of "
"the real code but is still only pseudo-code. It avoids the details "
"irrelevant to the subject of the discussion. The real-life examples can be "
"found in the source code of real drivers. In particular the drivers `ep` and "
"`aha` are good sources of information."
msgstr ""
"Esta capítulo hace una introducción a los problemas relevantes a la hora de "
"escribir un controlador para un dispositivo ISA. El pseudocódigo presentado "
"aquí es bastante detallado y se asemeja al código real pero sigue siendo "
"pseudocódigo. Evita los detalles irrelevantes para el tema de discusión. Los "
"ejemplos de la vida real se pueden encontrar en el código fuente de los "
"controladores reales. En particular los controladores `ep` y `aha` son "
"buenas fuentes de información."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:57
#, no-wrap
msgid "Basic Information"
msgstr "Información Básica"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:60
msgid "A typical ISA driver would need the following include files:"
msgstr "Un controlador ISA típico necesitaría incluir los siguientes ficheros:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:68
#, no-wrap
msgid ""
"#include <sys/module.h>\n"
"#include <sys/bus.h>\n"
"#include <machine/bus.h>\n"
"#include <machine/resource.h>\n"
"#include <sys/rman.h>\n"
msgstr ""
"#include <sys/module.h>\n"
"#include <sys/bus.h>\n"
"#include <machine/bus.h>\n"
"#include <machine/resource.h>\n"
"#include <sys/rman.h>\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:71
#, no-wrap
msgid ""
"#include <isa/isavar.h>\n"
"#include <isa/pnpvar.h>\n"
msgstr ""
"#include <isa/isavar.h>\n"
"#include <isa/pnpvar.h>\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:74
msgid "They describe the things specific to the ISA and generic bus subsystem."
msgstr ""
"Describen aspectos específicos de ISA y del subsistema de bus genérico."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:76
msgid ""
"The bus subsystem is implemented in an object-oriented fashion, its main "
"structures are accessed by associated method functions."
msgstr ""
"El subsistema de bus está implementado en forma orientada a objetos, sus "
"estructuras principales se acceden mediante funciones método asociadas."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:78
msgid ""
"The list of bus methods implemented by an ISA driver is like one for any "
"other bus. For a hypothetical driver named \"xxx\" they would be:"
msgstr ""
"La lista de los métodos del bus implementados por un controlador ISA es como "
"la de cualquier otro bus. Para un controlador hipotético llamado \"xxx\" "
"serían:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:80
msgid ""
"`static void xxx_isa_identify (driver_t *, device_t);` Normally used for bus "
"drivers, not device drivers. But for ISA devices this method may have "
"special use: if the device provides some device-specific (non-PnP) way to "
"auto-detect devices this routine may implement it."
msgstr ""
"`static void xxx_isa_identify (driver_t *, device_t);` Normalmente usado por "
"controladores de bus, no de dispositivo. Pero para dispositivos ISA este "
"método puede tener un uso especial: si el dispositivo proporciona alguna "
"forma de auto-detección (no PnP) esta rutina podría implementarlo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:81
msgid ""
"`static int xxx_isa_probe (device_t dev);` Probe for a device at a known (or "
"PnP) location. This routine can also accommodate device-specific auto-"
"detection of parameters for partially configured devices."
msgstr ""
"`static int xxx_isa_probe (device_t dev);` Comprueba si existe un "
"dispositivo en una localización conocida (o PnP). Esta rutina también puede "
"acomodar parámetros de auto-detección específicos del dispositivo para "
"dispositivos configurados parcialmente."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:82
msgid ""
"`static int xxx_isa_attach (device_t dev);` Attach and initialize device."
msgstr ""
"`static int xxx_isa_attach (device_t dev);` Adjunta e inicializa el "
"dispositivo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:83
msgid ""
"`static int xxx_isa_detach (device_t dev);` Detach device before unloading "
"the driver module."
msgstr ""
"`static int xxx_isa_detach (device_t dev);` Libera el dispositivo antes de "
"descargar el módulo del controlador."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:84
msgid ""
"`static int xxx_isa_shutdown (device_t dev);` Execute shutdown of the device "
"before system shutdown."
msgstr ""
"`static int xxx_isa_shutdown (device_t dev);` Ejecuta el apagado del "
"dispositivo antes del apagado del sistema."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:85
msgid ""
"`static int xxx_isa_suspend (device_t dev);` Suspend the device before the "
"system goes to the power-save state. May also abort transition to the power-"
"save state."
msgstr ""
"`static int xxx_isa_suspend (device_t dev);` Suspende el dispositivo antes "
"de que el sistema entre en estado de ahorro de energía. También puede "
"abortar la transición al estado de ahorro de energía."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:86
msgid ""
"`static int xxx_isa_resume (device_t dev);` Resume the device activity after "
"return from power-save state."
msgstr ""
"`static int xxx_isa_resume (device_t dev);` Retoma la actividad en el "
"dispositivo después de volver del estado de ahorro de energía."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:88
msgid ""
"`xxx_isa_probe()` and `xxx_isa_attach()` are mandatory, the rest of the "
"routines are optional, depending on the device's needs."
msgstr ""
"`xxx_isa_probe()` y `xxx_isa_attach()` son obligatorios, el resto de las "
"rutinas son opcionales, dependiendo de las necesidades del dispositivo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:90
msgid ""
"The driver is linked to the system with the following set of descriptions."
msgstr ""
"El controlador está enlazado con el sistema con el conjunto de descripciones "
"siguientes."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:104
#, no-wrap
msgid ""
"    /* table of supported bus methods */\n"
"    static device_method_t xxx_isa_methods[] = {\n"
"        /* list all the bus method functions supported by the driver */\n"
"        /* omit the unsupported methods */\n"
"        DEVMETHOD(device_identify,  xxx_isa_identify),\n"
"        DEVMETHOD(device_probe,     xxx_isa_probe),\n"
"        DEVMETHOD(device_attach,    xxx_isa_attach),\n"
"        DEVMETHOD(device_detach,    xxx_isa_detach),\n"
"        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),\n"
"        DEVMETHOD(device_suspend,   xxx_isa_suspend),\n"
"        DEVMETHOD(device_resume,    xxx_isa_resume),\n"
msgstr ""
"    /* table of supported bus methods */\n"
"    static device_method_t xxx_isa_methods[] = {\n"
"        /* list all the bus method functions supported by the driver */\n"
"        /* omit the unsupported methods */\n"
"        DEVMETHOD(device_identify,  xxx_isa_identify),\n"
"        DEVMETHOD(device_probe,     xxx_isa_probe),\n"
"        DEVMETHOD(device_attach,    xxx_isa_attach),\n"
"        DEVMETHOD(device_detach,    xxx_isa_detach),\n"
"        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),\n"
"        DEVMETHOD(device_suspend,   xxx_isa_suspend),\n"
"        DEVMETHOD(device_resume,    xxx_isa_resume),\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:107
#, no-wrap
msgid ""
"\tDEVMETHOD_END\n"
"    };\n"
msgstr ""
"\tDEVMETHOD_END\n"
"    };\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:113
#, no-wrap
msgid ""
"    static driver_t xxx_isa_driver = {\n"
"        \"xxx\",\n"
"        xxx_isa_methods,\n"
"        sizeof(struct xxx_softc),\n"
"    };\n"
msgstr ""
"    static driver_t xxx_isa_driver = {\n"
"        \"xxx\",\n"
"        xxx_isa_methods,\n"
"        sizeof(struct xxx_softc),\n"
"    };\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:115
#, no-wrap
msgid "    static devclass_t xxx_devclass;\n"
msgstr "    static devclass_t xxx_devclass;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:118
#, no-wrap
msgid ""
"    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,\n"
"        load_function, load_argument);\n"
msgstr ""
"    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,\n"
"        load_function, load_argument);\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:121
msgid ""
"Here struct `xxx_softc` is a device-specific structure that contains private "
"driver data and descriptors for the driver's resources. The bus code "
"automatically allocates one softc descriptor per device as needed."
msgstr ""
"Aquí la estructura `xxx_softc` es un estructura específica del dispositivo "
"que contiene datos privados del controlador y descriptores para los recursos "
"del controlador. El código del bus reserva automáticamente un descriptor "
"softc por cada dispositivo según sea necesario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:123
msgid ""
"If the driver is implemented as a loadable module then `load_function()` is "
"called to do driver-specific initialization or clean-up when the driver is "
"loaded or unloaded and load_argument is passed as one of its arguments. If "
"the driver does not support dynamic loading (in other words it must always "
"be linked into the kernel) then these values should be set to 0 and the last "
"definition would look like:"
msgstr ""
"Si el controlador se implementa como un módulo cargable entonces se llama a "
"la función `load_function()`para realizar una inicialización específica del "
"dispositivo o una limpieza cuando el controlador es cargado o descargado y "
"se pasa load_argument como uno de sus argumentos. Si el controlador no "
"soporta carga dinámica (en otras palabras siempre tiene que enlazarse en el "
"kernel) entonces estos valores deberían establecerse a 0 y la última "
"definición quedaría así:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:128
#, no-wrap
msgid ""
" DRIVER_MODULE(xxx, isa, xxx_isa_driver,\n"
"       xxx_devclass, 0, 0);\n"
msgstr ""
" DRIVER_MODULE(xxx, isa, xxx_isa_driver,\n"
"       xxx_devclass, 0, 0);\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:131
msgid ""
"If the driver is for a device which supports PnP then a table of supported "
"PnP IDs must be defined. The table consists of a list of PnP IDs supported "
"by this driver and human-readable descriptions of the hardware types and "
"models having these IDs. It looks like:"
msgstr ""
"Si el controlador es para un dispositivo que soporta PnP entonces se debe "
"definir una tabla de IDs PnP soportados. La tabla consiste en una lista de "
"IDs PnP soportados por este controlador y descripciones legibles de los "
"tipos de hardware y modeles que tienen estos IDs. Tiene este aspecto:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:140
#, no-wrap
msgid ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        /* a line for each supported PnP ID */\n"
"        { 0x12345678,   \"Our device model 1234A\" },\n"
"        { 0x12345679,   \"Our device model 1234B\" },\n"
"        { 0,        NULL }, /* end of table */\n"
"    };\n"
msgstr ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        /* a line for each supported PnP ID */\n"
"        { 0x12345678,   \"Our device model 1234A\" },\n"
"        { 0x12345679,   \"Our device model 1234B\" },\n"
"        { 0,        NULL }, /* end of table */\n"
"    };\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:143
msgid ""
"If the driver does not support PnP devices it still needs an empty PnP ID "
"table, like:"
msgstr ""
"Si el controlador no soporta dispositivos PnP aún así necesita una tabla PnP "
"vacía como:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:149
#, no-wrap
msgid ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        { 0,        NULL }, /* end of table */\n"
"    };\n"
msgstr ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        { 0,        NULL }, /* end of table */\n"
"    };\n"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:152
#, no-wrap
msgid "`device_t` Pointer"
msgstr "`device_t` Pointer"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:155
msgid ""
"`device_t` is the pointer type for the device structure. Here we consider "
"only the methods interesting from the device driver writer's standpoint. The "
"methods to manipulate values in the device structure are:"
msgstr ""
"`device_t` es el tipo puntero para la estructura del dispositivo. Aquí sólo "
"consideramos métodos interesantes desde el punto de vista del programador de "
"controladores de dispositivos. Los métodos para manipular valores en la "
"estructura del dispositivo son:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:157
msgid "`device_t device_get_parent(dev)` Get the parent bus of a device."
msgstr ""
"`device_t device_get_parent(dev)` Obtener el bus padre de un dispositivo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:158
msgid "`driver_t device_get_driver(dev)` Get pointer to its driver structure."
msgstr ""
"`driver_t device_get_driver(dev)` Obtener un puntero a su estructura de "
"controlador."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:159
msgid ""
"`char *device_get_name(dev)` Get the driver name, such as `\"xxx\"` for our "
"example."
msgstr ""
"`char *device_get_name(dev)` Obtener el nombre del controlador, como `\"xxx"
"\"` en nuestro ejemplo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:160
msgid ""
"`int device_get_unit(dev)` Get the unit number (units are numbered from 0 "
"for the devices associated with each driver)."
msgstr ""
"`int device_get_unit(dev)` Obtener el número de unidad (las unidades se "
"numeran empezando en 0 para los dispositivos asociados con cada controlador)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:161
msgid ""
"`char *device_get_nameunit(dev)` Get the device name including the unit "
"number, such as \"xxx0\", \"xxx1\" and so on."
msgstr ""
"`char *device_get_nameunit(dev)` Obtener el nombre del dispositivo incluido "
"el número de unidad, como \"xxx0\", \"xxx1\" etc."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:162
msgid ""
"`char *device_get_desc(dev)` Get the device description. Normally it "
"describes the exact model of device in human-readable form."
msgstr ""
"`char *device_get_desc(dev)` Obtener la descripción del dispositivo. "
"Normalmente describe el modelo exacto de dispositivo en forma legible para "
"las personas."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:163
msgid ""
"`device_set_desc(dev, desc)` Set the description. This makes the device "
"description point to the string desc which may not be deallocated or changed "
"after that."
msgstr ""
"`device_set_desc(dev, desc)` Establecer la descripción. Esto hace que la "
"descripción del dispositivo apunte a la cadena desc que no debería ser "
"liberada o cambiada después de esto."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:164
msgid ""
"`device_set_desc_copy(dev, desc)` Set the description. The description is "
"copied into an internal dynamically allocated buffer, so the string desc may "
"be changed afterwards without adverse effects."
msgstr ""
"`device_set_desc_copy(dev, desc)` Establecer la descripción. La descripción "
"se copia en un búfer interno reservado dinámicamente, de forma que la cadena "
"desc podría cambiarse posteriormente sin efectos adversos."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:165
msgid ""
"`void *device_get_softc(dev)` Get pointer to the device descriptor (struct "
"`xxx_softc`) associated with this device."
msgstr ""
"`void *device_get_softc(dev)` Obtener un puntero al descriptor de "
"dispositivo (struct `xxx_softc`) asociado con este dispositivo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:166
msgid ""
"`u_int32_t device_get_flags(dev)` Get the flags specified for the device in "
"the configuration file."
msgstr ""
"`u_int32_t device_get_flags(dev)` Obtener los flags especificados en el "
"fichero de configuración para el dispositivo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:168
msgid ""
"A convenience function `device_printf(dev, fmt, ...)` may be used to print "
"the messages from the device driver. It automatically prepends the unitname "
"and colon to the message."
msgstr ""
"La función de ayuda `device_printf(dev, fmt, ...)` puede usarse para "
"imprimir los mensajes del controlador de dispositivo. Añade de forma "
"automática un prefijo con el nombre de la unidad y dos puntos antes del "
"mensaje."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:170
msgid ""
"The device_t methods are implemented in the file [.filename]#kern/bus_subr."
"c#."
msgstr ""
"Los métodos de device_t se implementan en el fichero [.filename]#kern/"
"bus_subr.c#."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:172
#, no-wrap
msgid "Configuration File and the Order of Identifying and Probing During Auto-Configuration"
msgstr "El Fichero de Configuración y el Orden de la Identificación y el Sondeo Durante la Auto-Configuración"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:175
msgid "The ISA devices are described in the kernel configuration file like:"
msgstr ""
"Los dispositivos ISA se describen en el fichero de configuración del kernel "
"como sigue:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:180
#, no-wrap
msgid ""
"device xxx0 at isa? port 0x300 irq 10 drq 5\n"
"       iomem 0xd0000 flags 0x1 sensitive\n"
msgstr ""
"device xxx0 at isa? port 0x300 irq 10 drq 5\n"
"       iomem 0xd0000 flags 0x1 sensitive\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:183
msgid ""
"The values of port, IRQ and so on are converted to the resource values "
"associated with the device. They are optional, depending on the device's "
"needs and abilities for auto-configuration. For example, some devices do not "
"need DRQ at all and some allow the driver to read the IRQ setting from the "
"device configuration ports. If a machine has multiple ISA buses the exact "
"bus may be specified in the configuration line, like `isa0` or `isa1`, "
"otherwise the device would be searched for on all the ISA buses."
msgstr ""
"Los valores del puerto, IRQ y demás se convierten a valores de recursos "
"asociados con el dispositivo. Son opcionales, dependiendo de las necesidades "
"del dispositivo y las capacidades de auto-configuración. Por ejemplo, "
"algunos dispositivos no necesitan DRQ en absoluto y algunos permiten al "
"controlador leer la configuración de las IRQ desde los puertos de "
"configuración del dispositivo. Si una máquina tiene varios buses ISA se "
"tiene que especificar el bus exacto en la línea de configuración, como "
"`isa0` o `isa1`, de lo contrario se buscaría el dispositivo en todos los "
"buses ISA."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:185
msgid ""
"`sensitive` is a resource requesting that this device must be probed before "
"all non-sensitive devices. It is supported but does not seem to be used in "
"any current driver."
msgstr ""
"`sensitive` es un recurso que solicita que se sondee este dispositivo antes "
"de aquellos que sean no-sensitive. Se soporta pero no parece que se use "
"actualmente en ningún controlador."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:187
msgid ""
"For legacy ISA devices in many cases the drivers are still able to detect "
"the configuration parameters. But each device to be configured in the system "
"must have a config line. If two devices of some type are installed in the "
"system but there is only one configuration line for the corresponding "
"driver, ie:"
msgstr ""
"Para dispositivos ISA antiguos en muchos casos los controladores todavía son "
"capaces de detectar los parámetros de configuración. Pero cada dispositivo "
"que necesita ser configurado en el sistema necesita tener una línea de "
"configuración. Si dos dispositivos de un tipo se instalan en el sistema pero "
"sólo hay una línea de configuración para el controlador correspondiente, es "
"decir:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:190
#, no-wrap
msgid "device xxx0 at isa?\n"
msgstr "device xxx0 at isa?\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:192
#, no-wrap
msgid " then only one device will be configured.\n"
msgstr " entonces sólo se configurará un dispositivo.\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:194
msgid ""
"But for the devices supporting automatic identification by the means of Plug-"
"n-Play or some proprietary protocol one configuration line is enough to "
"configure all the devices in the system, like the one above or just simply:"
msgstr ""
"Pero para dispositivos que soportan identificación automática mediante Plug-"
"n-Play o algún protocolo propietario es suficiente con una línea de "
"configuración para configurar todos los dispositivos en el sistema, como la "
"mostrada arriba o simplemente:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:198
#, no-wrap
msgid "device xxx at isa?\n"
msgstr "device xxx at isa?\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:201
msgid ""
"If a driver supports both auto-identified and legacy devices and both kinds "
"are installed at once in one machine then it is enough to describe in the "
"config file the legacy devices only. The auto-identified devices will be "
"added automatically."
msgstr ""
"Si un controlador soporta tanto auto-identificación como dispositivos "
"antiguos y se instalan ambos tipos a la vez en una máquina entonces es "
"suficiente describir en el fichero de configuración sólo los dispositivos "
"antiguos. Los dispositivos auto-identificados se añadirán automáticamente."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:203
msgid "When an ISA bus is auto-configured the events happen as follows:"
msgstr "Cuando se auto-configura un bus ISA se suceden los siguientes eventos:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:205
msgid ""
"All the drivers' identify routines (including the PnP identify routine which "
"identifies all the PnP devices) are called in random order. As they identify "
"the devices they add them to the list on the ISA bus. Normally the drivers' "
"identify routines associate their drivers with the new devices. The PnP "
"identify routine does not know about the other drivers yet so it does not "
"associate any with the new devices it adds."
msgstr ""
"Todas las rutinas de identificación de los controladores (incluida la rutina "
"de identificación PnP que identifica todos los dispositivos PnP) se llaman "
"en orden aleatorio. Según se identifican los dispositivos se añaden a la "
"lista en el bus ISA. Normalmente las rutinas de identificación de los "
"controladores asocian sus controladores con los nuevos dispositivos. La "
"rutina de identificación PnP no sabe nada acerca de otros controladores "
"todavía de forma que no se asocia con ninguno de los nuevos dispositivos que "
"añade."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:207
msgid ""
"The PnP devices are put to sleep using the PnP protocol to prevent them from "
"being probed as legacy devices."
msgstr ""
"Los dispositivos PnP se ponen a dormir usando el protocolo PnP para evitar "
"que sean sondeados como dispositivos antiguos."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:209
msgid ""
"The probe routines of non-PnP devices marked as `sensitive` are called. If "
"probe for a device went successfully, the attach routine is called for it."
msgstr ""
"Se llama a las rutinas de sondeo para dispositivos no-PnP marcadas como "
"`sensitive`. Si un sondeo de dispositivo tiene éxito, se llama a la rutina "
"para adjuntarlo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:211
msgid ""
"The probe and attach routines of all non-PNP devices are called likewise."
msgstr ""
"Se llama a las rutinas de sondeo y de ajuntar para todos los dispositivos no-"
"PnP."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:213
msgid ""
"The PnP devices are brought back from the sleep state and assigned the "
"resources they request: I/O and memory address ranges, IRQs and DRQs, all of "
"them not conflicting with the attached legacy devices."
msgstr ""
"Se despierta a los dispositivos PnP y se les asigna los recursos que "
"soliciten: rangos de E/S y memoria, IRQs y DRQs, todos los que no entren en "
"conflicto con los dispositivos antiguos adjuntados."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:215
msgid ""
"Then for each PnP device the probe routines of all the present ISA drivers "
"are called. The first one that claims the device gets attached. It is "
"possible that multiple drivers would claim the device with different "
"priority; in this case, the highest-priority driver wins. The probe routines "
"must call `ISA_PNP_PROBE()` to compare the actual PnP ID with the list of "
"the IDs supported by the driver and if the ID is not in the table return "
"failure. That means that absolutely every driver, even the ones not "
"supporting any PnP devices must call `ISA_PNP_PROBE()`, at least with an "
"empty PnP ID table to return failure on unknown PnP devices."
msgstr ""
"Después se llama a las rutinas de sondeo para cada dispositivo PnP de todos "
"los controladores ISA presentes. El primero que reclame el dispositivo se "
"adjunta. Es posible que varios controladores reclamen el dispositivo con "
"diferentes prioridades; en este caso gana el controlador con la prioridad "
"más alta. Las rutinas de sondeo deben llamar a `ISA_PNP_PROBE()` para "
"comparar el ID PnP actual con la lista de IDs soportada por el controlador y "
"si el ID no está en la tabla devolver fallo. Eso significa que absolutamente "
"todos los controladores, incluso los que no soportan ningún dispositivo PnP "
"deben llamar a `ISA_PNP_PROBE()`, al menos con una tabla de IDs PnP vacía "
"para devolver fallo en los dispositivos PnP desconocidos."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:217
msgid ""
"The probe routine returns a positive value (the error code) on error, zero "
"or negative value on success."
msgstr ""
"Las rutinas de sondeo devuelven un valor positivo (el código de error) si "
"hay error, cero o valor negativo en caso de éxito."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:219
msgid ""
"The negative return values are used when a PnP device supports multiple "
"interfaces. For example, an older compatibility interface and a newer "
"advanced interface which are supported by different drivers. Then both "
"drivers would detect the device. The driver which returns a higher value in "
"the probe routine takes precedence (in other words, the driver returning 0 "
"has highest precedence, returning -1 is next, returning -2 is after it and "
"so on). In result the devices which support only the old interface will be "
"handled by the old driver (which should return -1 from the probe routine) "
"while the devices supporting the new interface as well will be handled by "
"the new driver (which should return 0 from the probe routine). If multiple "
"drivers return the same value then the one called first wins. So if a driver "
"returns value 0 it may be sure that it won the priority arbitration."
msgstr ""
"Los valores de retorno negativos se usan cuando un dispositivo PnP soporta "
"múltiples interfaces. Por ejemplo, una interfaz de compatibilidad más "
"antigua y una interfaz avanzada más modernas que se soportan en diferentes "
"controladores. Después ambos controladores detectarían el dispositivo. El "
"controlador que devuelve el valor más alto en la rutina de sondeo tiene "
"preferencia (en otras palabras, el controlador que devuelve 0 tiene mayor "
"preferencia, el que devuelve -1 es el siguiente, el que devuelve -2 el "
"siguiente y así sucesivamente). Como resultado los dispositivos que soportan "
"sólo el interfaz antiguo serán manejados por el controlador antiguo (que "
"debería devolver -1 en su rutina de sondeo) mientras que los dispositivos "
"que soportan también el interfaz nuevo serán manejados por el controlador "
"nuevo (que debería devolver 0 en la rutina de sondeo). Si varios "
"controladores devuelven el mismo valor entonces el que se haya llamado "
"primero gana. De forma que si un controlador devuelve 0 puede asegurarse que "
"ha ganado el arbitraje."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:221
msgid ""
"The device-specific identify routines can also assign not a driver but a "
"class of drivers to the device. Then all the drivers in the class are probed "
"for this device, like the case with PnP. This feature is not implemented in "
"any existing driver and is not considered further in this document."
msgstr ""
"Las rutinas de identificación específicas del dispositivo no sólo pueden "
"asociar un controlador sino una clase de controladores a un dispositivo. En "
"este caso se sondean todos los controladores de la clase para este "
"dispositivo, como el caso con PnP. Esta característica no está implementada "
"en ningún controlador y no se considera a lo largo de este documento."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:223
msgid ""
"As the PnP devices are disabled when probing the legacy devices they will "
"not be attached twice (once as legacy and once as PnP). But in case of "
"device-dependent identify routines it is the responsibility of the driver to "
"make sure that the same device will not be attached by the driver twice: "
"once as legacy user-configured and once as auto-identified."
msgstr ""
"Como los dispositivos PnP se desactivan mientras se están sondeando los "
"dispositivos antiguos estos no se adjuntarán dos veces (una como dispositivo "
"antiguo y una como PnP). Pero en el caso de rutinas de identificación "
"dependientes del dispositivo es responsabilidad del controlador asegurarse "
"que el mismo dispositivo no será adjuntado dos veces por el controlador: una "
"como dispositivo antiguo configurador por el usuario y otra como auto-"
"identificado."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:225
msgid ""
"Another practical consequence for the auto-identified devices (both PnP and "
"device-specific) is that the flags can not be passed to them from the kernel "
"configuration file. So they must either not use the flags at all or use the "
"flags from the device unit 0 for all the auto-identified devices or use the "
"sysctl interface instead of flags."
msgstr ""
"Otra consecuencia práctica de los dispositivos auto-identificados (tanto PnP "
"como específicos del dispositivo) es que los flags no se pueden pasar desde "
"el fichero de configuración del kernel. Se debe no usar flags en absoluto o "
"usar los flags de la unida de dispositivo 0 para todos los dispositivos auto-"
"identificados o usar el interfaz sysctl en lugar de flags."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:227
msgid ""
"Other unusual configurations may be accommodated by accessing the "
"configuration resources directly with functions of families "
"`resource_query_*()` and `resource_*_value()`. Their implementations are "
"located in [.filename]#kern/subr_bus.c#. The old IDE disk driver [."
"filename]#i386/isa/wd.c# contains examples of such use. But the standard "
"means of configuration must always be preferred. Leave parsing the "
"configuration resources to the bus configuration code."
msgstr ""
"Se pueden acomodar otras configuraciones menos usuarios accediendo "
"directamente a los recursos de configuración con funciones de las familias "
"`resource_query_*()` y `resource_*_value()`. Sus implementaciones están en [."
"filename]#kern/subr_bus.c#. El antiguo controlador de disco IDE [."
"filename]#i386/isa/wd.c# contiene ejemplos de cómo usarlas. Pero el estándar "
"especifica que siempre se debe preferir la configuración. Deja el parseo de "
"los recursos de configuración al código de configuración del bus."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:229
#, no-wrap
msgid "Resources"
msgstr "Recursos"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:232
msgid ""
"The information that a user enters into the kernel configuration file is "
"processed and passed to the kernel as configuration resources. This "
"information is parsed by the bus configuration code and transformed into a "
"value of structure device_t and the bus resources associated with it. The "
"drivers may access the configuration resources directly using functions "
"`resource_*` for more complex cases of configuration. However, generally "
"this is neither needed nor recommended, so this issue is not discussed "
"further here."
msgstr ""
"La información que el usuario introducen el fichero de configuración del "
"kernel se procesa y se le pasa al kernel como recursos de configuración. "
"Esta información se parsea con el código de configuración del bus y se "
"transforma en un valor de una estructura device_t y los recursos del bus "
"asociados con él. Los controladores pueden acceder directamente a los "
"recursos de configuración usando funciones `resource_*` para casos de "
"configuración más complejos. Sin embargo, generalmente esto no es ni "
"necesario ni recomendado, de forma que no discutiremos más este asunto."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:234
msgid ""
"The bus resources are associated with each device. They are identified by "
"type and number within the type. For the ISA bus the following types are "
"defined:"
msgstr ""
"Los recursos del bus se asocian con cada dispositivo. Se identifican por un "
"tipo y un número dentro del tipo. Para el bus ISA se definen los siguientes "
"tipos:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:236
msgid "_SYS_RES_IRQ_ - interrupt number"
msgstr "_SYS_RES_IRQ_ - número de interrupción"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:237
msgid "_SYS_RES_DRQ_ - ISA DMA channel number"
msgstr "_SYS_RES_DRQ_ - número de canal DMA ISA"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:238
msgid ""
"_SYS_RES_MEMORY_ - range of device memory mapped into the system memory space"
msgstr ""
"_SYS_RES_MEMORY_ - rango de memoria del dispositivo mapeado en el espacio de "
"memoria del sistema"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:239
msgid "_SYS_RES_IOPORT_ - range of device I/O registers"
msgstr "_SYS_RES_IOPORT_ - rango de registros de E/S del dispositivo"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:241
msgid ""
"The enumeration within types starts from 0, so if a device has two memory "
"regions it would have resources of type `SYS_RES_MEMORY` numbered 0 and 1. "
"The resource type has nothing to do with the C language type, all the "
"resource values have the C language type `unsigned long` and must be cast as "
"necessary. The resource numbers do not have to be contiguous, although for "
"ISA they normally would be. The permitted resource numbers for ISA devices "
"are:"
msgstr ""
"Las enumeraciones en los tipos empiezan en 0, de forma que si un dispositivo "
"tiene dos regiones de memoria tendría recursos de tipo `SYS_RES_MEMORY` "
"enumerados 0 y 1. El tipo de recurso no tiene nada que ver con el tipo en el "
"lenguaje C, todos los recursos tienen valores con tipo `unsigned long` en "
"lenguaje C y se deben convertir como sea necesario. Los números de recurso "
"no tienen que ser contiguos, aunque para ISA normalmente lo son. Los números "
"de recurso permitidos para los dispositivos ISA son:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:248
#, no-wrap
msgid ""
"          IRQ: 0-1\n"
"          DRQ: 0-1\n"
"          MEMORY: 0-3\n"
"          IOPORT: 0-7\n"
msgstr ""
"          IRQ: 0-1\n"
"          DRQ: 0-1\n"
"          MEMORY: 0-3\n"
"          IOPORT: 0-7\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:251
msgid ""
"All the resources are represented as ranges, with a start value and count. "
"For IRQ and DRQ resources the count would normally be equal to 1. The values "
"for memory refer to the physical addresses."
msgstr ""
"Todos los recursos se representan como rangos, con un valor de comienzo y un "
"contador. Para los recursos IRQ y DRQ el contador normalmente será 1. Los "
"valores para memoria se refieren a las direcciones físicas."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:253
msgid "Three types of activities can be performed on resources:"
msgstr "Se pueden realizar tres tipos de actividades sobre los recursos:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:255
msgid "set/get"
msgstr "set/get"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:256
msgid "allocate/release"
msgstr "allocate/release"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:257
msgid "activate/deactivate"
msgstr "activate/deactivate"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:259
msgid ""
"Setting sets the range used by the resource. Allocation reserves the "
"requested range that no other driver would be able to reserve it (and "
"checking that no other driver reserved this range already). Activation makes "
"the resource accessible to the driver by doing whatever is necessary for "
"that (for example, for memory it would be mapping into the kernel virtual "
"address space)."
msgstr ""
"Los ajustes establecen el rango usado por el recurso. La asignación reserva "
"el rango solicitado de forma que ningún otro controlador puede reservarlo (y "
"comprueba que ningún otro controlador haya reservado este rango con "
"anterioridad). La activación hace que el recurso sea accesible por el "
"controlador haciendo lo que sea necesario (por ejemplo, para la memoria "
"sería mapearla en el espacio de direcciones virtuales del kernel)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:261
msgid "The functions to manipulate resources are:"
msgstr "Las funciones para manipular recursos son:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:263
msgid ""
"`int bus_set_resource(device_t dev, int type, int rid, u_long start, u_long "
"count)`"
msgstr ""
"`int bus_set_resource(device_t dev, int type, int rid, u_long start, u_long "
"count)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:265
msgid ""
"Set a range for a resource. Returns 0 if successful, error code otherwise. "
"Normally, this function will return an error only if one of `type`, `rid`, "
"`start` or `count` has a value that falls out of the permitted range."
msgstr ""
"Establece un rango para un recurso. Devuelve 0 en caso de éxito, en caso "
"contrario un código de error. Normalmente, esta función sólo devolverá un "
"error si `type`, `rid`, `start` o `count` tienen un valor que está fuera del "
"rango permitido."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:267
msgid "dev - driver's device"
msgstr "dev - dispositivo del controlador"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:268
msgid "type - type of resource, SYS_RES_*"
msgstr "type - tipo de recurso, SYS_RES_*"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:269
msgid "rid - resource number (ID) within type"
msgstr "rid - número de recurso (ID) dentro del tipo"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:270
msgid "start, count - resource range"
msgstr "start, count - rango del recurso"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:272
msgid ""
"`int bus_get_resource(device_t dev, int type, int rid, u_long *startp, "
"u_long *countp)`"
msgstr ""
"`int bus_get_resource(device_t dev, int type, int rid, u_long *startp, "
"u_long *countp)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:274
msgid ""
"Get the range of resource. Returns 0 if successful, error code if the "
"resource is not defined yet."
msgstr ""
"Obtiene el rango del recurso. Devuelve 0 en caso de éxito, código de error "
"si el recurso no se ha definido todavía."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:275
msgid ""
"`u_long bus_get_resource_start(device_t dev, int type, int rid) u_long "
"bus_get_resource_count (device_t dev, int type, int rid)`"
msgstr ""
"`u_long bus_get_resource_start(device_t dev, int type, int rid) u_long "
"bus_get_resource_count (device_t dev, int type, int rid)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:277
msgid ""
"Convenience functions to get only the start or count. Return 0 in case of "
"error, so if the resource start has 0 among the legitimate values it would "
"be impossible to tell if the value is 0 or an error occurred. Luckily, no "
"ISA resources for add-on drivers may have a start value equal to 0."
msgstr ""
"Funciones de apoyo para obtener sólo el comienzo o el tamaño. Devuelve 0 en "
"caso de error, de forma que si el recurso tiene 0 entre sus valores "
"legítimos sería imposible decir si el valor es 0 o ha ocurrido un error. "
"Afortunadamente, ningún recurso ISA para controladores añadidos puede tener "
"un valor de comienzo igual a 0."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:278
msgid "`void bus_delete_resource(device_t dev, int type, int rid)`"
msgstr "`void bus_delete_resource(device_t dev, int type, int rid)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:280
msgid "Delete a resource, make it undefined."
msgstr "Borra un recurso, lo hace indefinido."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:281
msgid ""
"`struct resource * bus_alloc_resource(device_t dev, int type, int *rid, "
"u_long start, u_long end, u_long count, u_int flags)`"
msgstr ""
"`struct resource * bus_alloc_resource(device_t dev, int type, int *rid, "
"u_long start, u_long end, u_long count, u_int flags)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:283
msgid ""
"Allocate a resource as a range of count values not allocated by anyone else, "
"somewhere between start and end. Alas, alignment is not supported. If the "
"resource was not set yet it is automatically created. The special values of "
"start 0 and end ~0 (all ones) means that the fixed values previously set by "
"`bus_set_resource()` must be used instead: start and count as themselves and "
"end=(start+count), in this case if the resource was not defined before then "
"an error is returned. Although rid is passed by reference it is not set "
"anywhere by the resource allocation code of the ISA bus. (The other buses "
"may use a different approach and modify it)."
msgstr ""
"Asigna un recurso como un rango de count valores no asignados por nadie más, "
"en algún punto entre start y end. Lamentablemente, no se soporta "
"alineamiento. Si el recurso no se ha establecido todavía se crea "
"automáticamente. Los valores especiales 0 para start y ~0 para end (todo "
"unos) significan que los valores fijos previamente establecidos por "
"`bus_set_resource()` se tiene que usar en su lugar: start y count como ellos "
"mismos y end=(start+count), en este caso si el recurso no estaba definido "
"anteriormente se devuelve un error. Aunque se pasa rid como referencia el "
"código de asignación del bus ISA no lo establece en ningún sitio. (Los otros "
"buses podrían usar una aproximación diferente y modificarlo)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:285
msgid "Flags are a bitmap, the flags interesting for the caller are:"
msgstr ""
"Los flags con un mapa de bits, los flags interesantes para el llamante son:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:287
msgid ""
"_RF_ACTIVE_ - causes the resource to be automatically activated after "
"allocation."
msgstr ""
"_RF_ACTIVE_ - hace que se active el recurso automáticamente después de la "
"asignación."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:288
msgid ""
"_RF_SHAREABLE_ - resource may be shared at the same time by multiple drivers."
msgstr ""
"_RF_SHAREABLE_ - el recurso puede ser compartido al mismo tiempo por varios "
"controladores."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:289
msgid ""
"_RF_TIMESHARE_ - resource may be time-shared by multiple drivers, i.e., "
"allocated at the same time by many but activated only by one at any given "
"moment of time."
msgstr ""
"_RF_TIMESHARE_ - el recurso puede ser de tiempo compartido por varios "
"controladores, es decir, asignado al mismo tiempo por muchos pero activado "
"sólo por uno en un momento dado."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:290
msgid ""
"Returns 0 on error. The allocated values may be obtained from the returned "
"handle using methods `rhand_*()`."
msgstr ""
"Devuelve 0 en caso de error. Los valores asignados se pueden obtener del "
"manejador devuelto usando los métodos `rhand_*()`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:291
msgid ""
"`int bus_release_resource(device_t dev, int type, int rid, struct resource "
"*r)`"
msgstr ""
"`int bus_release_resource(device_t dev, int type, int rid, struct resource "
"*r)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:292
msgid ""
"Release the resource, r is the handle returned by `bus_alloc_resource()`. "
"Returns 0 on success, error code otherwise."
msgstr ""
"Libera el recurso, r es el manejador devuelto por `bus_alloc_resource()`. "
"Devuelve 0 en caso de éxito, un código de error en caso contrario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:293
msgid ""
"`int bus_activate_resource(device_t dev, int type, int rid, struct resource "
"*r) int bus_deactivate_resource(device_t dev, int type, int rid, struct "
"resource *r)`"
msgstr ""
"`int bus_activate_resource(device_t dev, int type, int rid, struct resource "
"*r) int bus_deactivate_resource(device_t dev, int type, int rid, struct "
"resource *r)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:294
msgid ""
"Activate or deactivate resource. Return 0 on success, error code otherwise. "
"If the resource is time-shared and currently activated by another driver "
"then `EBUSY` is returned."
msgstr ""
"Activa o desactiva un recurso. Devuelve 0 en caso de éxito, un código de "
"error en caso contrario. Si el recurso es de tiempo compartido y actualmente "
"está activado por otro controlador entonces se devuelve `EBUSY`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:295
msgid ""
"`int bus_setup_intr(device_t dev, struct resource *r, int flags, "
"driver_intr_t *handler, void *arg, void **cookiep) int "
"bus_teardown_intr(device_t dev, struct resource *r, void *cookie)`"
msgstr ""
"`int bus_setup_intr(device_t dev, struct resource *r, int flags, "
"driver_intr_t *handler, void *arg, void **cookiep) int "
"bus_teardown_intr(device_t dev, struct resource *r, void *cookie)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:296
msgid ""
"Associate or de-associate the interrupt handler with a device. Return 0 on "
"success, error code otherwise."
msgstr ""
"Asocia o elimina la asociación de un manejador de interrupciones con un "
"dispositivo. Devuelve 0 en caso de éxito, un código de error en caso "
"contrario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:297
msgid "r - the activated resource handler describing the IRQ"
msgstr "r - el manejador del recurso activado que describe la IRQ"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:299
msgid "flags - the interrupt priority level, one of:"
msgstr "flags - el nivel de prioridad de la interrupción, uno de:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:301
msgid ""
"`INTR_TYPE_TTY` - terminals and other likewise character-type devices. To "
"mask them use `spltty()`."
msgstr ""
"`INTR_TYPE_TTY` - terminales y otros dispositivos tipo carácter. Para "
"enmascaracrlos utiliza `spltty()`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:302
msgid ""
"`(INTR_TYPE_TTY | INTR_TYPE_FAST)` - terminal type devices with small input "
"buffer, critical to the data loss on input (such as the old-fashioned serial "
"ports). To mask them use `spltty()`."
msgstr ""
"`(INTR_TYPE_TTY | INTR_TYPE_FAST)` - dispositivos tipo terminal con búfers "
"de entrada pequeños, críticos respecto a la pérdida de datos de entrada "
"(como los antiguos puertos serie). Para enmascararlos utiliza `spltty()`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:303
msgid ""
"`INTR_TYPE_BIO` - block-type devices, except those on the CAM controllers. "
"To mask them use `splbio()`."
msgstr ""
"`INTR_TYPE_BIO` - dispositivos de bloques, excepto aquellos en los "
"controladores CAM. Para enmascararlos utiliza `splbio()`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:304
msgid ""
"`INTR_TYPE_CAM` - CAM (Common Access Method) bus controllers. To mask them "
"use `splcam()`."
msgstr ""
"`INTR_TYPE_CAM` - controladores de bus CAM (Common Access Method). Para "
"enmascararlos utiliza `splcam()`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:305
msgid ""
"`INTR_TYPE_NET` - network interface controllers. To mask them use `splimp()`."
msgstr ""
"`INTR_TYPE_NET` - controladores de interfaces de red. Para enmascararlos "
"utiliza `splimp()`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:306
msgid ""
"`INTR_TYPE_MISC` - miscellaneous devices. There is no other way to mask them "
"than by `splhigh()` which masks all interrupts."
msgstr ""
"`INTR_TYPE_MISC` - dispositivos varios. No hay otra forma de enmascararlos "
"que no sea con `splhigh()` que enmascara todas las interrupciones."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:308
msgid ""
"When an interrupt handler executes all the other interrupts matching its "
"priority level will be masked. The only exception is the MISC level for "
"which no other interrupts are masked and which is not masked by any other "
"interrupt."
msgstr ""
"Cuando se ejecuta un manejador de interrupción todas las demás "
"interrupciones que tengan su mismo nivel de prioridad serán enmascaradas. La "
"única excepción es el nivel MISC para el cual no se enmascara ninguna otra "
"interrupción y que no es enmascarado por ninguna otra interrupción."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:310
msgid ""
"_handler_ - pointer to the handler function, the type driver_intr_t is "
"defined as `void driver_intr_t(void *)`"
msgstr ""
"_handler_ - puntero a la función del manejeador, el tipo driver_intr_t se "
"define como `void driver_intr_t(void *)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:311
msgid ""
"_arg_ - the argument passed to the handler to identify this particular "
"device. It is cast from void* to any real type by the handler. The old "
"convention for the ISA interrupt handlers was to use the unit number as "
"argument, the new (recommended) convention is using a pointer to the device "
"softc structure."
msgstr ""
"_arg_ - el argumento pasado al menejador para identificar este dispositivo "
"en particular. El manejador lo transforma desde void* a cualquier tipo real. "
"La antigua convención para los menejadores de interrupción ISA era usar el "
"número de unidad como argumento, la nueva (recomendada) convención es usar "
"un puntero a la estructura softc del dispositivo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:312
msgid ""
"_cookie[p]_ - the value received from `setup()` is used to identify the "
"handler when passed to `teardown()`"
msgstr ""
"_cookie[p]_ - el valor recibido desde `setup()` se usa para identificar el "
"manejador cuando se pasa a `teardown()`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:314
msgid ""
"A number of methods are defined to operate on the resource handlers (struct "
"resource *). Those of interest to the device driver writers are:"
msgstr ""
"Un cierto número de métodos se definen para operar sobre los manejadores de "
"recursos (struct resource *). Aquellos de interés para los creadores de "
"controladores de dispositivos son:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:316
msgid ""
"`u_long rman_get_start(r) u_long rman_get_end(r)` Get the start and end of "
"allocated resource range."
msgstr ""
"`u_long rman_get_start(r) u_long rman_get_end(r)` Obtener el comienzo y el "
"final de un rango de recursos reservados."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:317
msgid ""
"`void *rman_get_virtual(r)` Get the virtual address of activated memory "
"resource."
msgstr ""
"`void *rman_get_virtual(r)` Obtener la dirección virtual de un recurso de "
"memoria activado."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:319
#, no-wrap
msgid "Bus Memory Mapping"
msgstr "Mapeo de Memoria del Bus"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:322
msgid ""
"In many cases data is exchanged between the driver and the device through "
"the memory. Two variants are possible:"
msgstr ""
"En muchos casos los datos se intercambian entre el controlador y el "
"dispositivo a través de memoria. Hay dos posibles variantes:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:324
msgid "(a) memory is located on the device card"
msgstr "(a) la memoria está reservada en la tarjeta del dispositivo"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:326
msgid "(b) memory is the main memory of the computer"
msgstr "(b) la memoria está en la memoria principal del ordenador"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:328
msgid ""
"In case (a) the driver always copies the data back and forth between the on-"
"card memory and the main memory as necessary. To map the on-card memory into "
"the kernel virtual address space the physical address and length of the on-"
"card memory must be defined as a `SYS_RES_MEMORY` resource. That resource "
"can then be allocated and activated, and its virtual address obtained using "
"`rman_get_virtual()`. The older drivers used the function `pmap_mapdev()` "
"for this purpose, which should not be used directly any more. Now it is one "
"of the internal steps of resource activation."
msgstr ""
"En el caso (a) el controlador siempre copia los datos a y desde la memoria "
"de la tarjeta y la memoria principal cuando sea necesario. Para mapear la "
"memoria de la tarjeta en el espacio de direcciones virtuales del núcleo la "
"dirección física y la longitud de la memoria de la tarjeta se tiene que "
"definir como un recurso `SYS_RES_MEMORY`. Después el recurso puede ser "
"reservado y activado, y su dirección virtual obtenida utilizando "
"`rman_get_virtual()`. Los controladores antiguos usaban la función "
"`pmap_mapdev()` para este propósito, que ya no debería ser usada "
"directamente. Ahora es uno de los pasos internos de la activación de los "
"recursos."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:330
msgid ""
"Most of the ISA cards will have their memory configured for physical "
"location somewhere in range 640KB-1MB. Some of the ISA cards require larger "
"memory ranges which should be placed somewhere under 16MB (because of the 24-"
"bit address limitation on the ISA bus). In that case if the machine has more "
"memory than the start address of the device memory (in other words, they "
"overlap) a memory hole must be configured at the address range used by "
"devices. Many BIOSes allow configuration of a memory hole of 1MB starting at "
"14MB or 15MB. FreeBSD can handle the memory holes properly if the BIOS "
"reports them properly (this feature may be broken on old BIOSes)."
msgstr ""
"La mayoría de las tarjetas ISA tendrán su memoria configurada para la "
"dirección física en algún punto en el rango 640KB-1MB. Algunas tarjetas ISA "
"requieren rangos de memoria más amplios que deberían situarse en algún punto "
"por debajo de 16MB (por la limitación de los 24-bit de direccionamiento en "
"el bus ISA). En ese caso si la máquina tiene más memoria que la dirección de "
"inicio de la memoria del dispositivo (en otras palabras, se superponen) se "
"tiene que configurar un agujero de memoria en el rango de direcciones usado "
"por los dispositivos. Muchas BIOS permiten configurar un agujero de memoria "
"de 1MB empezando en 14MB o 15 MB. FreeBSD puede manejar los agujeros de "
"memoria de forma adecuada si la BIOS los reporta de forma apropiada (esta "
"característica podría estar rota en BIOS antiguas)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:332
msgid ""
"In case (b) just the address of the data is sent to the device, and the "
"device uses DMA to actually access the data in the main memory. Two "
"limitations are present: First, ISA cards can only access memory below 16MB. "
"Second, the contiguous pages in virtual address space may not be contiguous "
"in physical address space, so the device may have to do scatter/gather "
"operations. The bus subsystem provides ready solutions for some of these "
"problems, the rest has to be done by the drivers themselves."
msgstr ""
"En el caso (b) sólo se pasa al dispositivo la dirección del dato, y el "
"dispositivo utiliza DMA para acceder a los datos en la memoria principal. "
"Hay dos limitaciones: Primero, las tarjetas ISA sólo pueden acceder a la "
"memoria por debajo de 16MB. Segundo, las páginas que son contiguas en el "
"espacio virtual de direcciones podrían no serlo en el espacio físico de "
"direcciones, por lo que el dispositivo tiene que realizar operaciones "
"scatter/gather. El subsistema del bus proporciona soluciones para algunos de "
"estos problemas, el resto tienen que ser realizadas por los controladores "
"mismos."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:334
msgid ""
"Two structures are used for DMA memory allocation, `bus_dma_tag_t` and "
"`bus_dmamap_t`. Tag describes the properties required for the DMA memory. "
"Map represents a memory block allocated according to these properties. "
"Multiple maps may be associated with the same tag."
msgstr ""
"Se usan dos estructuras para realizar la reserva de memoria de DMA, "
"`bus_dma_tag_t` y `bus_dmamap_t`. La etiqueta describe las propiedades "
"requeridas para la memoria DMA. El mapa representa un bloque de memoria "
"reservado conforme a esas propiedades. Se pueden asociar múltiples mapas con "
"la misma etiqueta."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:336
msgid ""
"Tags are organized into a tree-like hierarchy with inheritance of the "
"properties. A child tag inherits all the requirements of its parent tag, and "
"may make them more strict but never more loose."
msgstr ""
"Las etiquetas se organizan en una jerarquía tipo árbol con herencia de "
"propiedades. Una etiqueta hija hereda todos los requisitos de su etiqueta "
"padre, y puede hacerlas más estrictas pero nunca más relajadas."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:338
msgid ""
"Normally one top-level tag (with no parent) is created for each device unit. "
"If multiple memory areas with different requirements are needed for each "
"device then a tag for each of them may be created as a child of the parent "
"tag."
msgstr ""
"Normalmente se crea una etiqueta de primer nivel (sin padre) para cada "
"unidad de dispositivo. Si se necesitan múltiples áreas de memoria con "
"diferentes requisitos para cada dispositivo entonces se puede crear una "
"etiqueta para cada uno de ellos como hijas de la etiqueta padre."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:340
msgid "The tags can be used to create a map in two ways."
msgstr "Las etiquetas se pueden usar para crear mapas de dos formas."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:342
msgid ""
"First, a chunk of contiguous memory conformant with the tag requirements may "
"be allocated (and later may be freed). This is normally used to allocate "
"relatively long-living areas of memory for communication with the device. "
"Loading of such memory into a map is trivial: it is always considered as one "
"chunk in the appropriate physical memory range."
msgstr ""
"Primero, se reserva un bloque contiguo de memoria (que luego puede ser "
"liberado) que cumple con los requisitos de la etiqueta. Esto normalmente se "
"usa para reservar áreas de memoria que van a tener una vida relativamente "
"larga para comunicarse con el dispositivo. La carga de esa memoria en un "
"mapa es trivial: siempre se considera como un sólo bloque en el rango físico "
"de memoria apropiado."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:344
msgid ""
"Second, an arbitrary area of virtual memory may be loaded into a map. Each "
"page of this memory will be checked for conformance to the map requirement. "
"If it conforms then it is left at its original location. If it is not then a "
"fresh conformant \"bounce page\" is allocated and used as intermediate "
"storage. When writing the data from the non-conformant original pages they "
"will be copied to their bounce pages first and then transferred from the "
"bounce pages to the device. When reading the data would go from the device "
"to the bounce pages and then copied to their non-conformant original pages. "
"The process of copying between the original and bounce pages is called "
"synchronization. This is normally used on a per-transfer basis: buffer for "
"each transfer would be loaded, transfer done and buffer unloaded."
msgstr ""
"Segundo, se puede cargar en un mapa un área arbitraria de memoria virtual. "
"Cada página de esta memoria se comprobará para ver si cumple con los "
"requisitos del mapa. Si lo hace entonces se deja en su situación original. "
"Si no entonces se reserva una página \"bounce\" que cumpla los requisitos y "
"se usa como almacenamiento intermedio. Cuando se escriben datos desde las "
"páginas originales se copiarán primero a las páginas \"bounce\" y luego "
"serán transferidos de estas hasta el dispositivo. Cuando se lee los datos "
"irían desde el dispositivo hasta las páginas \"bounce\" y después se "
"copiarían a las páginas originales. El proceso de copiado entre las páginas "
"originales y las páginas \"bounce\" se llama sincronización. Normalmente "
"esto se usa en cada transferencia: se cargaría el búfer de cada "
"transferencia, se realiza la transferencia y se descarga el búfer."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:346
msgid "The functions working on the DMA memory are:"
msgstr "Las funciones que trabajan con la memoria DMA son:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:348
msgid ""
"`int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, "
"bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr, "
"bus_dma_filter_t *filter, void *filterarg, bus_size_t maxsize, int "
"nsegments, bus_size_t maxsegsz, int flags, bus_dma_tag_t *dmat)`"
msgstr ""
"`int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, "
"bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr, "
"bus_dma_filter_t *filter, void *filterarg, bus_size_t maxsize, int "
"nsegments, bus_size_t maxsegsz, int flags, bus_dma_tag_t *dmat)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:350
msgid "Create a new tag. Returns 0 on success, the error code otherwise."
msgstr ""
"Crea una nueva etiqueta. Devuelve 0 en caso de éxito, el código de error en "
"caso contrario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:352
msgid "_parent_ - parent tag, or NULL to create a top-level tag."
msgstr ""
"_parent_ - la etiqueta padre, o NULL para crear una etiqueta de primer nivel."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:353
msgid ""
"_alignment_ - required physical alignment of the memory area to be allocated "
"for this tag. Use value 1 for \"no specific alignment\". Applies only to the "
"future `bus_dmamem_alloc()` but not `bus_dmamap_create()` calls."
msgstr ""
"_alignment_ - alineamiento físico requerido para el área de memoria que va a "
"ser reservado para esta etiqueta. Usa el valor 1 para \"ningún alineamiento "
"específico\". Sólo aplica para las llamadas a `bus_dmamem_alloc()` pero no a "
"las de `bus_dmamap_create()`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:354
msgid ""
"_boundary_ - physical address boundary that must not be crossed when "
"allocating the memory. Use value 0 for \"no boundary\". Applies only to the "
"future `bus_dmamem_alloc()` but not `bus_dmamap_create()` calls. Must be "
"power of 2. If the memory is planned to be used in non-cascaded DMA mode (i."
"e., the DMA addresses will be supplied not by the device itself but by the "
"ISA DMA controller) then the boundary must be no larger than 64KB (64*1024) "
"due to the limitations of the DMA hardware."
msgstr ""
"_boundary_ - límite de memoria físico que no se debe sobrepasar cuando se "
"reserva la memoria. Usa el valor 0 para \"sin límite\". Aplica sólo a las "
"llamadas a `bus_dmamem_alloc()` pero no a `bus_dmamap_create()`. Debe ser "
"una potencia de 2. Si la memoria se va a usar en modo DMA sin cascada (es "
"decir, las direcciones DMA serán proporcionadas no por el dispositivo sino "
"por el controlador ISA DMA) entonces el límite no debe ser mayor de 64KB "
"(64*1024) debido a las limitaciones del hardware DMA."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:355
msgid ""
"_lowaddr, highaddr_ - the names are slightly misleading; these values are "
"used to limit the permitted range of physical addresses used to allocate the "
"memory. The exact meaning varies depending on the planned future use:"
msgstr ""
"_lowaddr, highaddr_ - los nombres son un poco confusos; estos valores se "
"usan para limitar el rango permitido de direcciones físicas usadas para "
"reservar la memoria. El significado exacto depende del uso que se le vaya a "
"dar:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:357
msgid ""
"For `bus_dmamem_alloc()` all the addresses from 0 to lowaddr-1 are "
"considered permitted, the higher ones are forbidden."
msgstr ""
"Para `bus_dmamem_alloc()` se consideran como permitidas todas las "
"direcciones desde 0 a lowaddr-1, las más altas están prohibidas."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:358
msgid ""
"For `bus_dmamap_create()` all the addresses outside the inclusive range "
"[lowaddr; highaddr] are considered accessible. The addresses of pages inside "
"the range are passed to the filter function which decides if they are "
"accessible. If no filter function is supplied then all the range is "
"considered unaccessible."
msgstr ""
"Para `bus_dmamap_create()` todas las direcciones fuera del rango cerrado "
"[lowaddr; highaddr] se consideran accesibles. Las direcciones de las páginas "
"dentro del rango se pasan a la función de filtrado que decide si son "
"accesibles. Si no se proporciona una función de filtrado entonces todo el "
"rango se considera inaccesible."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:359
msgid "For the ISA devices the normal values (with no filter function) are:"
msgstr ""
"Para los dispositivos ISA los valores normales (sin función de filtrado) son:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:361
msgid "lowaddr = BUS_SPACE_MAXADDR_24BIT"
msgstr "lowaddr = BUS_SPACE_MAXADDR_24BIT"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:363
msgid "highaddr = BUS_SPACE_MAXADDR"
msgstr "highaddr = BUS_SPACE_MAXADDR"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:365
msgid ""
"_filter, filterarg_ - the filter function and its argument. If NULL is "
"passed for filter then the whole range [lowaddr, highaddr] is considered "
"unaccessible when doing `bus_dmamap_create()`. Otherwise the physical "
"address of each attempted page in range [lowaddr; highaddr] is passed to the "
"filter function which decides if it is accessible. The prototype of the "
"filter function is: `int filterfunc(void *arg, bus_addr_t paddr)`. It must "
"return 0 if the page is accessible, non-zero otherwise."
msgstr ""
"_filter, filterarg_ - la función de filtrado y su argumento. Si se pasa NULL "
"como filtro entonces todo el rango [lowaddr, highaddr] se considera "
"inaccesible cuando se llama a `bus_dmamap_create()`. De lo contrario la "
"dirección física de cada página en el rango [lowaddr; highaddr] es pasada a "
"la función de filtrado que decide si es accesible. El prototipo de esta "
"función es: `int filterfunc(void *arg, bus_addr_t paddr)`. Debe devolver 0 "
"si la página es accesible, distinto de cero en caso contrario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:366
msgid ""
"_maxsize_ - the maximal size of memory (in bytes) that may be allocated "
"through this tag. In case it is difficult to estimate or could be "
"arbitrarily big, the value for ISA devices would be "
"`BUS_SPACE_MAXSIZE_24BIT`."
msgstr ""
"_maxsize_ - el tamaño máximo de memoria (en bytes) que podría ser reservado "
"a través de esta etiqueta. En caso de que se difícil de estimar o que "
"pudiera ser arbitrariamente grande, el valor para los dispositivos ISA sería "
"`BUS_SPACE_MAXSIZE_24BIT`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:367
msgid ""
"_nsegments_ - maximal number of scatter-gather segments supported by the "
"device. If unrestricted then the value `BUS_SPACE_UNRESTRICTED` should be "
"used. This value is recommended for the parent tags, the actual restrictions "
"would then be specified for the descendant tags. Tags with nsegments equal "
"to `BUS_SPACE_UNRESTRICTED` may not be used to actually load maps, they may "
"be used only as parent tags. The practical limit for nsegments seems to be "
"about 250-300, higher values will cause kernel stack overflow (the hardware "
"can not normally support that many scatter-gather buffers anyway)."
msgstr ""
"_nsegments_ - máximo número de segmentos scatter-gather soportados por el "
"dispositivo. Si no hay restricciones entonces se debería usar el valor "
"`BUS_SPACE_UNRESTRICTED`. Este valor es el recomentado para etiquetas padre, "
"la restricción real sería especificada después por las etiquetas "
"descendientes. Las etiquetas con nsegments igual a `BUS_SPACE_UNRESTRICTED` "
"no se deben usar para cargar mapas, sólo se deben usar como etiquetas padre. "
"El límite práctico para nsegments parece ser alrededor de 250-300, valores "
"más altos provocarán un desbordamiento de pila en el núcleo (el hardware "
"normalmente no puede soportar tantos buffers scatter-gather de todas formas)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:368
msgid ""
"_maxsegsz_ - maximal size of a scatter-gather segment supported by the "
"device. The maximal value for ISA device would be `BUS_SPACE_MAXSIZE_24BIT`."
msgstr ""
"_maxsegsz_ - máximo tamaño de un segmento scatter-gather soportado por el "
"dispositivo. El valor máximo para un dispositivo ISA sería "
"`BUS_SPACE_MAXSIZE_24BIT`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:369
msgid "_flags_ - a bitmap of flags. The only interesting flag is:"
msgstr "_flags_ - un mapa de bits de flags. El único flag interesante es:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:371
msgid ""
"_BUS_DMA_ALLOCNOW_ - requests to allocate all the potentially needed bounce "
"pages when creating the tag."
msgstr ""
"_BUS_DMA_ALLOCNOW_ - solicita reservar todas las páginas \"bounce\" "
"potencialmente necesarias cuando se crea la etiqueta."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:373
msgid "_dmat_ - pointer to the storage for the new tag to be returned."
msgstr ""
"_dmat_ - puntero al almacenamiento que se devolverá para la nueva etiqueta."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:375
msgid "`int bus_dma_tag_destroy(bus_dma_tag_t dmat)`"
msgstr "`int bus_dma_tag_destroy(bus_dma_tag_t dmat)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:377
msgid "Destroy a tag. Returns 0 on success, the error code otherwise."
msgstr ""
"Destruye una etiqueta. Devuelve 0 en caso de éxito, el código de error en "
"caso contrario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:379
msgid "dmat - the tag to be destroyed."
msgstr "dmat - la etiqueta a destruir."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:380
msgid ""
"`int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags, "
"bus_dmamap_t *mapp)`"
msgstr ""
"`int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags, "
"bus_dmamap_t *mapp)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:382
msgid ""
"Allocate an area of contiguous memory described by the tag. The size of "
"memory to be allocated is tag's maxsize. Returns 0 on success, the error "
"code otherwise. The result still has to be loaded by `bus_dmamap_load()` "
"before being used to get the physical address of the memory."
msgstr ""
"Reserva un área contigua de memoria descrita por la etiqueta. El tamaño de "
"la memoria a reservar es el maxsize de la etiqueta. Devuelve 0 en caso de "
"éxito, el código de error en caso contrario. El resultado todavía tiene que "
"ser cargado con `bus_dmamap_load()` antes de ser usado para obtener la "
"dirección física de la memoria."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:384
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:396
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:404
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:419
msgid "_dmat_ - the tag"
msgstr "_dmat_ - la etiqueta"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:385
msgid ""
"_vaddr_ - pointer to the storage for the kernel virtual address of the "
"allocated area to be returned."
msgstr ""
"_vaddr_ - puntero al almacenamiento para la dirección virtual del núcleo del "
"área reservada que será devuelta."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:386
msgid "flags - a bitmap of flags. The only interesting flag is:"
msgstr "flags - un mapa de bits de flags. El único flag interesante es:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:388
msgid ""
"_BUS_DMA_NOWAIT_ - if the memory is not immediately available return the "
"error. If this flag is not set then the routine is allowed to sleep until "
"the memory becomes available."
msgstr ""
"_BUS_DMA_NOWAIT_ - si la memoria no está disponible inmediatamente devuelve "
"el error. Si este flag no se usa entonces se permite dormir a la rutina "
"hasta que la memoria esté disponible."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:390
msgid "_mapp_ - pointer to the storage for the new map to be returned."
msgstr ""
"_mapp_ - puntero al almacenamiento para el nuevo mapa que será devuelto."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:392
msgid ""
"`void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t map)`"
msgstr ""
"`void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t map)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:394
msgid ""
"Free the memory allocated by `bus_dmamem_alloc()`. At present, freeing of "
"the memory allocated with ISA restrictions is not implemented. Due to this "
"the recommended model of use is to keep and re-use the allocated areas for "
"as long as possible. Do not lightly free some area and then shortly allocate "
"it again. That does not mean that `bus_dmamem_free()` should not be used at "
"all: hopefully it will be properly implemented soon."
msgstr ""
"Libera la memoria reservada por `bus_dmamem_alloc()`. En este momento, "
"liberar la memoria reservada con restricciones ISA no está implementado. "
"Debido a esto el modo de uso recomendado es mantener y reutilizar las áreas "
"reservadas tanto tiempo como sea posible. No liberes áreas alegremente y "
"luego vuelvas a reservarlas. Eso no significa que `bus_dmamem_free()`no deba "
"usarse nunca: con suerte será implementada pronto."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:397
msgid "_vaddr_ - the kernel virtual address of the memory"
msgstr "_vaddr_ - la dirección virtual del núcleo para la memoria"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:398
msgid "_map_ - the map of the memory (as returned from `bus_dmamem_alloc()`)"
msgstr "_map_ - el mapa de memoria (como lo devuelve `bus_dmamem_alloc()`)"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:400
msgid ""
"`int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t *mapp)`"
msgstr ""
"`int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t *mapp)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:402
msgid ""
"Create a map for the tag, to be used in `bus_dmamap_load()` later. Returns 0 "
"on success, the error code otherwise."
msgstr ""
"Crea un mapa para la etiqueta, para ser usado después en "
"`bus_dmamap_load()`. Devuelve 0 en caso de éxito, el código de error en caso "
"contrario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:405
msgid ""
"_flags_ - theoretically, a bit map of flags. But no flags are defined yet, "
"so at present it will be always 0."
msgstr ""
"_flags_ - en teoría, un mapa de bits de flags. Pero no hay flags definidos "
"todavía, así que actualmente será siempre 0."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:406
msgid "_mapp_ - pointer to the storage for the new map to be returned"
msgstr ""
"_mapp_ - puntero al almacenamiento para el nuevo mapa que será devuelto"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:408
msgid "`int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)`"
msgstr "`int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:410
msgid "Destroy a map. Returns 0 on success, the error code otherwise."
msgstr ""
"Destruye un mapa. Devuelve 0 en caso de éxito, el código de error en caso "
"contrario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:412
msgid "dmat - the tag to which the map is associated"
msgstr "dmat - la etiqueta a la que está asociado el mapa"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:413
msgid "map - the map to be destroyed"
msgstr "map - el mapa a destruir"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:415
msgid ""
"`int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void *buf, "
"bus_size_t buflen, bus_dmamap_callback_t *callback, void *callback_arg, int "
"flags)`"
msgstr ""
"`int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void *buf, "
"bus_size_t buflen, bus_dmamap_callback_t *callback, void *callback_arg, int "
"flags)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:417
msgid ""
"Load a buffer into the map (the map must be previously created by "
"`bus_dmamap_create()` or `bus_dmamem_alloc()`). All the pages of the buffer "
"are checked for conformance to the tag requirements and for those not "
"conformant the bounce pages are allocated. An array of physical segment "
"descriptors is built and passed to the callback routine. This callback "
"routine is then expected to handle it in some way. The number of bounce "
"buffers in the system is limited, so if the bounce buffers are needed but "
"not immediately available the request will be queued and the callback will "
"be called when the bounce buffers will become available. Returns 0 if the "
"callback was executed immediately or `EINPROGRESS` if the request was queued "
"for future execution. In the latter case the synchronization with queued "
"callback routine is the responsibility of the driver."
msgstr ""
"Carga un búfer en el mapa (el mapa debe haber sido creado previamente con "
"`bus_dmamap_create()` o `bus_dmamem_alloc()`). Se comprueban todos los "
"búfers para asegurar que siguen los requisitos de la etiqueta y para "
"aquellos que no lo hacen se reservan páginas \"bounce\". Un array de "
"descriptores de segmentos físicos es construido y pasado a la rutina de "
"callback. Se espera que esta rutina de callback lo maneje de alguna forma. "
"El número de búfers \"bounce\" en el sistema está limitado, así que si los "
"búfers \"bounce\" son necesarios pero no están disponibles inmediatamente se "
"encolará la solicitud y el callback se llamará cuando estén disponibles. "
"Devuelve 0 si el callback se ejecutó inmediatamente o `EINPROGRESS` si la "
"solicitud fue encolada para ejecutarse más tarde. En este último caso la "
"sincronización con la rutina de callback es responsabilidad del controlador."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:420
msgid "_map_ - the map"
msgstr "_map_ - el mapa"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:421
msgid "_buf_ - kernel virtual address of the buffer"
msgstr "_buf_ - dirección virtual del núcleo para el búfer"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:422
msgid "_buflen_ - length of the buffer"
msgstr "_buflen_ - longitud del búfer"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:423
msgid "_callback_, `callback_arg` - the callback function and its argument"
msgstr "_callback_, `callback_arg` - la función de callback y su argumento"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:425
msgid ""
"The prototype of callback function is: `void callback(void *arg, "
"bus_dma_segment_t *seg, int nseg, int error)`"
msgstr ""
"El prototipo de la función de callback es: `void callback(void *arg, "
"bus_dma_segment_t *seg, int nseg, int error)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:427
msgid "_arg_ - the same as callback_arg passed to `bus_dmamap_load()`"
msgstr "_arg_ - el mismo que callback_arg que se pasa a `bus_dmamap_load()`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:428
msgid "_seg_ - array of the segment descriptors"
msgstr "_seg_ - array de descriptores de segmento"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:429
msgid "_nseg_ - number of descriptors in array"
msgstr "_nseg_ - número de descriptores en el array"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:430
msgid ""
"_error_ - indication of the segment number overflow: if it is set to `EFBIG` "
"then the buffer did not fit into the maximal number of segments permitted by "
"the tag. In this case only the permitted number of descriptors will be in "
"the array. Handling of this situation is up to the driver: depending on the "
"desired semantics it can either consider this an error or split the buffer "
"in two and handle the second part separately"
msgstr ""
"_error_ - indicación de desbordamiento del número de segmento: si se "
"establece a `EFBIG` entonces el búfer no entró dentro del máximo número de "
"segmentos permitido por la etiqueta. En este caso sólo el número de "
"descriptores permitidos estará en el array. Manejar esta situación es cosa "
"del controlador: dependiendo de la semántica que se quiere se puede "
"considerar un error o partir el búfer en dos y manejar la segunda parte de "
"forma separada"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:432
msgid "Each entry in the segments array contains the fields:"
msgstr "Cada entrada en el array de segmentos contiene los campos:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:434
msgid "_ds_addr_ - physical bus address of the segment"
msgstr "_ds_addr_ - dirección física del bus para el segmento"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:435
msgid "_ds_len_ - length of the segment"
msgstr "_ds_len_ - longitud del segmento"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:437
msgid "`void bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)`"
msgstr "`void bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:439
msgid "unload the map."
msgstr "descarga un mapa."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:441
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:448
msgid "_dmat_ - tag"
msgstr "_dmat_ - etiqueta"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:442
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:449
msgid "_map_ - loaded map"
msgstr "_map_ - mapa cargado"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:444
msgid ""
"`void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t map, "
"bus_dmasync_op_t op)`"
msgstr ""
"`void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t map, "
"bus_dmasync_op_t op)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:446
msgid ""
"Synchronise a loaded buffer with its bounce pages before and after physical "
"transfer to or from device. This is the function that does all the necessary "
"copying of data between the original buffer and its mapped version. The "
"buffers must be synchronized both before and after doing the transfer."
msgstr ""
"Sincroniza un búfer cargado con sus páginas \"bounce\" antes y después de "
"una transferencia física a o desde el dispositivo. Esta es la función que "
"hace todas las copias de datos necesarias entre el búfer original y su "
"versión mapeada. Los búfers deben ser sincronizados tanto antes como después "
"de la transferencia."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:450
msgid "_op_ - type of synchronization operation to perform:"
msgstr "_op_ - la operación de sincronización a realizar:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:452
msgid "`BUS_DMASYNC_PREREAD` - before reading from device into buffer"
msgstr ""
"`BUS_DMASYNC_PREREAD` - antes de leer desde el dispositivo y hacia el búfer"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:453
msgid "`BUS_DMASYNC_POSTREAD` - after reading from device into buffer"
msgstr ""
"`BUS_DMASYNC_POSTREAD` - después de leer desde el dispositivo hacia el búfer"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:454
msgid "`BUS_DMASYNC_PREWRITE` - before writing the buffer to device"
msgstr "`BUS_DMASYNC_PREWRITE` - antes de escribir el búfer en el dispositivo"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:455
msgid "`BUS_DMASYNC_POSTWRITE` - after writing the buffer to device"
msgstr ""
"`BUS_DMASYNC_POSTWRITE` - después de escribir el búfer en el dispositivo"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:457
msgid ""
"As of now PREREAD and POSTWRITE are null operations but that may change in "
"the future, so they must not be ignored in the driver. Synchronization is "
"not needed for the memory obtained from `bus_dmamem_alloc()`."
msgstr ""
"Actualmente PREREAD y POSTWRITE son operaciones null pero esto podría "
"cambiar en el futuro, de forma que no deben ignorarse en el controlador. La "
"sincronización no es necesaria para la memoria obtenida mediante "
"`bus_dmamem_alloc()`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:459
msgid ""
"Before calling the callback function from `bus_dmamap_load()` the segment "
"array is stored in the stack. And it gets pre-allocated for the maximal "
"number of segments allowed by the tag. As a result of this the practical "
"limit for the number of segments on i386 architecture is about 250-300 (the "
"kernel stack is 4KB minus the size of the user structure, size of a segment "
"array entry is 8 bytes, and some space must be left). Since the array is "
"allocated based on the maximal number this value must not be set higher than "
"really needed. Fortunately, for most of hardware the maximal supported "
"number of segments is much lower. But if the driver wants to handle buffers "
"with a very large number of scatter-gather segments it should do that in "
"portions: load part of the buffer, transfer it to the device, load next part "
"of the buffer, and so on."
msgstr ""
"Antes de llamar a la función de callback desde `bus_dmamap_load()` se "
"almacena el array de segmentos en la pila. Y se pre-reserva para el número "
"máximo de segmentos permitidos por la etiqueta. Como resultado el límite "
"práctico para el número de segmentos en arquitectura i386 es de cerca de "
"250-300 (la pila del núcleo es 4KB menos el tamaño de la estructura de "
"usuario, tamaño de una entrada del array de segmentos es 8 btytes, y se debe "
"dejar algo de espacio). Como el array se reserva basándose en el número "
"máximo este valor no se debe configurar más alto de lo necesario. "
"Afortunadamente, para la mayoría del hardware el máximo soportado es mucho "
"menor. Pero si el controlador quiere manejar búfers con un número muy grande "
"de segmentos scatter-gather debería hacerlo por trozos: carga parte del "
"búfer, lo transfiere al dispositivo, carga la siguiente parte del búfer, etc."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:461
msgid ""
"Another practical consequence is that the number of segments may limit the "
"size of the buffer. If all the pages in the buffer happen to be physically "
"non-contiguous then the maximal supported buffer size for that fragmented "
"case would be (nsegments * page_size). For example, if a maximal number of "
"10 segments is supported then on i386 maximal guaranteed supported buffer "
"size would be 40K. If a higher size is desired then special tricks should be "
"used in the driver."
msgstr ""
"Otra consecuencia práctica es que el número de segmentos podría limitar el "
"tamaño del búfer. Si todas las páginas en el búfer no son contiguas "
"físicamente entonces el tamaño máximo de búfer soportado para ese caso "
"fragmentado sería de (nsegments * page_size). Por ejemplo, si se soporta un "
"número máximo de 10 segmentos entonces en i386 el tamaño máximo de búfer "
"soportado garantizado sería de 40K. Si se desea un tamaño mayor se deben "
"usar trucos especiales en el controlador."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:463
msgid ""
"If the hardware does not support scatter-gather at all or the driver wants "
"to support some buffer size even if it is heavily fragmented then the "
"solution is to allocate a contiguous buffer in the driver and use it as "
"intermediate storage if the original buffer does not fit."
msgstr ""
"Si el hardware no soporta scatter-gather en absoluto o si el controlador "
"quiere soportador un tamaño de búfer incluso si está muy fragmentado "
"entonces la solución es reservar un búfer contiguo en el controlador y "
"usarlo como almacenamiento intermedio si el búfer original no cabe."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:465
msgid ""
"Below are the typical call sequences when using a map depend on the use of "
"the map. The characters -> are used to show the flow of time."
msgstr ""
"Abajo están las secuencias de llamadas típicas cuando se usa un mapa "
"dependiendo del uso del mismo. Los caracteres -> se usan para mostrar el "
"flujo de tiempo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:467
msgid ""
"For a buffer which stays practically fixed during all the time between "
"attachment and detachment of a device:"
msgstr ""
"Para un búfer que permanece prácticamente fijo durante todo el tiempo desde "
"que se adjunta hasta que se libera de un dispositivo:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:469
msgid ""
"bus_dmamem_alloc -> bus_dmamap_load -> ...use buffer... -> -> "
"bus_dmamap_unload -> bus_dmamem_free"
msgstr ""
"bus_dmamem_alloc -> bus_dmamap_load -> ...use buffer... -> -> "
"bus_dmamap_unload -> bus_dmamem_free"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:471
msgid ""
"For a buffer that changes frequently and is passed from outside the driver:"
msgstr ""
"Para un búfer que cambia frecuentemente y que es pasado desde fuera del "
"controlador:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:480
#, no-wrap
msgid ""
"          bus_dmamap_create ->\n"
"          -> bus_dmamap_load -> bus_dmamap_sync(PRE...) -> do transfer ->\n"
"          -> bus_dmamap_sync(POST...) -> bus_dmamap_unload ->\n"
"          ...\n"
"          -> bus_dmamap_load -> bus_dmamap_sync(PRE...) -> do transfer ->\n"
"          -> bus_dmamap_sync(POST...) -> bus_dmamap_unload ->\n"
"          -> bus_dmamap_destroy\n"
msgstr ""
"          bus_dmamap_create ->\n"
"          -> bus_dmamap_load -> bus_dmamap_sync(PRE...) -> do transfer ->\n"
"          -> bus_dmamap_sync(POST...) -> bus_dmamap_unload ->\n"
"          ...\n"
"          -> bus_dmamap_load -> bus_dmamap_sync(PRE...) -> do transfer ->\n"
"          -> bus_dmamap_sync(POST...) -> bus_dmamap_unload ->\n"
"          -> bus_dmamap_destroy\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:483
msgid ""
"When loading a map created by `bus_dmamem_alloc()` the passed address and "
"size of the buffer must be the same as used in `bus_dmamem_alloc()`. In this "
"case it is guaranteed that the whole buffer will be mapped as one segment "
"(so the callback may be based on this assumption) and the request will be "
"executed immediately (EINPROGRESS will never be returned). All the callback "
"needs to do in this case is to save the physical address."
msgstr ""
"Cuando se carga un mapa creado por `bus_dmamem_alloc()` la dirección pasada "
"y el tamaño del búfer deben ser los mismos usados en `bus_dmamem_alloc()`. "
"En este caso se garantiza que todo el búfer se mapeará como un sólo segmente "
"(de forma que el callback puede asumir esto) y la solicitud se ejecutará "
"inmediatamente (nunca se devolverá EINPROGRESS). Todo lo que necesita hacer "
"el callback en este caso es guardar la dirección física."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:485
msgid "A typical example would be:"
msgstr "Un ejemplo típico sería:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:493
#, no-wrap
msgid ""
"          static void\n"
"        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)\n"
"        {\n"
"          *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"        }\n"
msgstr ""
"          static void\n"
"        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)\n"
"        {\n"
"          *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"        }\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:504
#, no-wrap
msgid ""
"          ...\n"
"          int error;\n"
"          struct somedata {\n"
"            ....\n"
"          };\n"
"          struct somedata *vsomedata; /* virtual address */\n"
"          bus_addr_t psomedata; /* physical bus-relative address */\n"
"          bus_dma_tag_t tag_somedata;\n"
"          bus_dmamap_t map_somedata;\n"
"          ...\n"
msgstr ""
"          ...\n"
"          int error;\n"
"          struct somedata {\n"
"            ....\n"
"          };\n"
"          struct somedata *vsomedata; /* virtual address */\n"
"          bus_addr_t psomedata; /* physical bus-relative address */\n"
"          bus_dma_tag_t tag_somedata;\n"
"          bus_dmamap_t map_somedata;\n"
"          ...\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:512
#, no-wrap
msgid ""
"          error=bus_dma_tag_create(parent_tag, alignment,\n"
"           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,\n"
"           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,\n"
"           &tag_somedata);\n"
"          if(error)\n"
"          return error;\n"
msgstr ""
"          error=bus_dma_tag_create(parent_tag, alignment,\n"
"           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,\n"
"           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,\n"
"           &tag_somedata);\n"
"          if(error)\n"
"          return error;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:517
#, no-wrap
msgid ""
"          error = bus_dmamem_alloc(tag_somedata, &vsomedata, /* flags*/ 0,\n"
"             &map_somedata);\n"
"          if(error)\n"
"             return error;\n"
msgstr ""
"          error = bus_dmamem_alloc(tag_somedata, &vsomedata, /* flags*/ 0,\n"
"             &map_somedata);\n"
"          if(error)\n"
"             return error;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:521
#, no-wrap
msgid ""
"          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,\n"
"             sizeof (struct somedata), alloc_callback,\n"
"             (void *) &psomedata, /*flags*/0);\n"
msgstr ""
"          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,\n"
"             sizeof (struct somedata), alloc_callback,\n"
"             (void *) &psomedata, /*flags*/0);\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:524
msgid ""
"Looks a bit long and complicated but that is the way to do it. The practical "
"consequence is: if multiple memory areas are allocated always together it "
"would be a really good idea to combine them all into one structure and "
"allocate as one (if the alignment and boundary limitations permit)."
msgstr ""
"Parece un poco largo y complicado pero es la forma de hacerlo. La "
"consecuencia práctica es: si se reservan múltiples áreas de memoria siempre "
"juntas sería una buena idea combinarlas en una sola estructura y reservarlas "
"como una sola (si el alineamiento y los límites lo permiten)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:526
msgid ""
"When loading an arbitrary buffer into the map created by "
"`bus_dmamap_create()` special measures must be taken to synchronize with the "
"callback in case it would be delayed. The code would look like:"
msgstr ""
"Cuando se carga un búfer arbitrario en el mapa creado por "
"`bus_dmamap_create()` se tienen que tomar medidas especiales para "
"sincronizar el callback en caso de que se retrasara. El código se parecería "
"a :"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:532
#, no-wrap
msgid ""
"          {\n"
"           int s;\n"
"           int error;\n"
msgstr ""
"          {\n"
"           int s;\n"
"           int error;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:551
#, no-wrap
msgid ""
"           s = splsoftvm();\n"
"           error = bus_dmamap_load(\n"
"               dmat,\n"
"               dmamap,\n"
"               buffer_ptr,\n"
"               buffer_len,\n"
"               callback,\n"
"               /*callback_arg*/ buffer_descriptor,\n"
"               /*flags*/0);\n"
"           if (error == EINPROGRESS) {\n"
"               /*\n"
"                * Do whatever is needed to ensure synchronization\n"
"                * with callback. Callback is guaranteed not to be started\n"
"                * until we do splx() or tsleep().\n"
"                */\n"
"              }\n"
"           splx(s);\n"
"          }\n"
msgstr ""
"           s = splsoftvm();\n"
"           error = bus_dmamap_load(\n"
"               dmat,\n"
"               dmamap,\n"
"               buffer_ptr,\n"
"               buffer_len,\n"
"               callback,\n"
"               /*callback_arg*/ buffer_descriptor,\n"
"               /*flags*/0);\n"
"           if (error == EINPROGRESS) {\n"
"               /*\n"
"                * Do whatever is needed to ensure synchronization\n"
"                * with callback. Callback is guaranteed not to be started\n"
"                * until we do splx() or tsleep().\n"
"                */\n"
"              }\n"
"           splx(s);\n"
"          }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:554
msgid "Two possible approaches for the processing of requests are:"
msgstr "Dos posibles aproximaciones para el procesamiento de peticiones son:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:556
msgid ""
"If requests are completed by marking them explicitly as done (such as the "
"CAM requests) then it would be simpler to put all the further processing "
"into the callback driver which would mark the request when it is done. Then "
"not much extra synchronization is needed. For the flow control reasons it "
"may be a good idea to freeze the request queue until this request gets "
"completed."
msgstr ""
"Si las peticiones se completan marcándolas explícitamente como terminadas "
"(como las peticiones CAM) entonces sería más sencillo poner todo el "
"procesamiento siguiente en el callback del controlador que marcaría la "
"petición cuando estuviera hecha. Entonces no se necesita mucha "
"sincronización. Con motivo del flujo de control sería una buena idea "
"congelar la cola de peticiones hasta que la petición se complete."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:558
msgid ""
"If requests are completed when the function returns (such as classic read or "
"write requests on character devices) then a synchronization flag should be "
"set in the buffer descriptor and `tsleep()` called. Later when the callback "
"gets called it will do its processing and check this synchronization flag. "
"If it is set then the callback should issue a wakeup. In this approach the "
"callback function could either do all the needed processing (just like the "
"previous case) or simply save the segments array in the buffer descriptor. "
"Then after callback completes the calling function could use this saved "
"segments array and do all the processing."
msgstr ""
"Si las peticiones se completan cuando la función retorna (como una petición "
"clásica de lectura o escritura en un dispositivo de caracteres) entonces se "
"debería establecer un flag de sincronización en el descriptor del búfer y "
"después llamar a `tsleep()`. Más tarde cuando se llama al callback hará el "
"procesamiento que le toque y comprobará el flag de sincronización. Si está "
"establecido entonces el callback debería hacer un wakeup. En esta "
"aproximación la función de callback podría hacer todo el procesamiento "
"necesario (como en el caso anterior) o simplemente guardar el array de "
"segmentos en el descriptor de búfer. Después de que el callback termine la "
"función llamante podría usar este array de segmentos guardado y hacer todo "
"el procesamiento."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:560
#, no-wrap
msgid "DMA"
msgstr "DMA"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:563
msgid ""
"The Direct Memory Access (DMA) is implemented in the ISA bus through the DMA "
"controller (actually, two of them but that is an irrelevant detail). To make "
"the early ISA devices simple and cheap the logic of the bus control and "
"address generation was concentrated in the DMA controller. Fortunately, "
"FreeBSD provides a set of functions that mostly hide the annoying details of "
"the DMA controller from the device drivers."
msgstr ""
"El Acceso Director a Memoria (DMA) se implementa en el bus ISA mediante el "
"controlador DMA (en realidad, dos de ellos pero es un detalle irrelevante). "
"Para hacer los primeros dispositivos ISA simples y baratos la lógica del bus "
"de control y de generación de direcciones se concentró en el controlador "
"DMA. Afortunadamente, FreeBSD proporciona un conjunto de funciones que "
"ocultan mayoritariamente los detalles molestos del controlador DMA desde el "
"punto de vista de los controladores de dispositivo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:565
msgid ""
"The simplest case is for the fairly intelligent devices. Like the bus master "
"devices on PCI they can generate the bus cycles and memory addresses all by "
"themselves. The only thing they really need from the DMA controller is bus "
"arbitration. So for this purpose they pretend to be cascaded slave DMA "
"controllers. And the only thing needed from the system DMA controller is to "
"enable the cascaded mode on a DMA channel by calling the following function "
"when attaching the driver:"
msgstr ""
"El caso más simple es para los dispositivos medianamente inteligentes. Como "
"los dispositivos maestros del bus PCI pueden generar los ciclos del bus y "
"las direcciones de memoria por ellos mismos. Lo único que necesitan "
"realmente del controlador DMA es arbitraje del bus. Para este propósito "
"fingen ser controladores DMA esclavos en cascada. Y lo único que necesitan "
"del controlador DMA es activa el modo en cascada en un canal DMA llamando a "
"la siguiente función cuando se adjunta el controlador:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:567
msgid "`void isa_dmacascade(int channel_number)`"
msgstr "`void isa_dmacascade(int channel_number)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:569
msgid ""
"All the further activity is done by programming the device. When detaching "
"the driver no DMA-related functions need to be called."
msgstr ""
"El resto de la actividad se hace programando el dispositivo. Cuando se "
"descarga un controlador no se necesita llamar a funciones de DMA."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:571
msgid ""
"For the simpler devices things get more complicated. The functions used are:"
msgstr ""
"Para los dispositivos más simples las cosas son más complicadas. Las "
"funciones utilizadas son:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:573
msgid "`int isa_dma_acquire(int chanel_number)`"
msgstr "`int isa_dma_acquire(int chanel_number)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:575
msgid ""
"Reserve a DMA channel. Returns 0 on success or EBUSY if the channel was "
"already reserved by this or a different driver. Most of the ISA devices are "
"not able to share DMA channels anyway, so normally this function is called "
"when attaching a device. This reservation was made redundant by the modern "
"interface of bus resources but still must be used in addition to the latter. "
"If not used then later, other DMA routines will panic."
msgstr ""
"Reserva un canal DMA. Devuelve 0 en caso de éxito o EBUSY si el cana ya "
"estaba reservado por este u otro controlador. De todos modos la mayoría de "
"los dispositivos ISA no son capaces de compartir canales DMA, así que "
"normalmente esta función se llama cuando se adjunta un dispositivo. Esta "
"reserva se hizo redundante con el interfaz moderno de recursos del bus pero "
"todavía puede ser utilizado con el anterior. Si no se usa, otras rutinas DMA "
"fallarán."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:576
msgid "`int isa_dma_release(int chanel_number)`"
msgstr "`int isa_dma_release(int chanel_number)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:578
msgid ""
"Release a previously reserved DMA channel. No transfers must be in progress "
"when the channel is released (in addition the device must not try to "
"initiate transfer after the channel is released)."
msgstr ""
"Libera un canal DMA reservado anteriormente. No debe haber transferencias en "
"curso cuando se libera el canal (además el dispositivo no debe intentar "
"iniciar transferencias después de que el canal haya sido liberado)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:579
msgid "`void isa_dmainit(int chan, u_int bouncebufsize)`"
msgstr "`void isa_dmainit(int chan, u_int bouncebufsize)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:581
msgid ""
"Allocate a bounce buffer for use with the specified channel. The requested "
"size of the buffer can not exceed 64KB. This bounce buffer will be "
"automatically used later if a transfer buffer happens to be not physically "
"contiguous or outside of the memory accessible by the ISA bus or crossing "
"the 64KB boundary. If the transfers will be always done from buffers which "
"conform to these conditions (such as those allocated by `bus_dmamem_alloc()` "
"with proper limitations) then `isa_dmainit()` does not have to be called. "
"But it is quite convenient to transfer arbitrary data using the DMA "
"controller. The bounce buffer will automatically care of the scatter-gather "
"issues."
msgstr ""
"Reserva un búfer \"bounce\" para usarse con el canal especificado. El tamaño "
"solicitado del búfer no puede exceder los 64KB. Este búfer \"bounce\" se "
"usará automáticamente si un búfer para una transferencia no es físicamente "
"contiguo o está fuera de la memoria accesible por el bus ISA o cruza el "
"límite de los 64KB. Si las transferencias siempre se van a hacer desde "
"búfers que cumplen estas condiciones (como aquellos reservados por "
"`bus_dmamem_alloc()`con los límites adecuados) entonces no se necesita "
"llamar a `isa_dmainit()`. Pero es muy útil para transferir datos arbitrarios "
"usando el controlador DMA. El búfer \"bounce\" se encargará automáticamente "
"de los problemas de scatter-gather."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:583
msgid "_chan_ - channel number"
msgstr "_chan_ - número de canal"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:584
msgid "_bouncebufsize_ - size of the bounce buffer in bytes"
msgstr "_bouncebufsize_ - tamaño en bytes del búfer \"bounce\""

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:586
msgid "`void isa_dmastart(int flags, caddr_t addr, u_int nbytes, int chan)`"
msgstr "`void isa_dmastart(int flags, caddr_t addr, u_int nbytes, int chan)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:588
msgid ""
"Prepare to start a DMA transfer. This function must be called to set up the "
"DMA controller before actually starting transfer on the device. It checks "
"that the buffer is contiguous and falls into the ISA memory range, if not "
"then the bounce buffer is automatically used. If bounce buffer is required "
"but not set up by `isa_dmainit()` or too small for the requested transfer "
"size then the system will panic. In case of a write request with bounce "
"buffer the data will be automatically copied to the bounce buffer."
msgstr ""
"Prepara para empezar una transferencia DMA. Esta función se debe llamar para "
"configurar el controlador DMA antes de empezar la transferencia en el "
"dispositivo. Comprueba que el búfer es contiguo y que está dentro del rango "
"de memoria de ISA, si no, se usa el búfer de rebote de forma automática. Si "
"se requiere el búfer de rebote pero no se configura con `isa_dmainit()` o es "
"demasiado pequeño para el tamaño de la transferencia entonces el sistema "
"entrará en pánico. En caso de que se haga una solicitud de escritura con un "
"búfer de rebote los datos se copiarán automáticamente al búfer de rebote."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:589
msgid ""
"flags - a bitmask determining the type of operation to be done. The "
"direction bits B_READ and B_WRITE are mutually exclusive."
msgstr ""
"flags - un mapa de bits que determina el tipo de operación a realizar. Los "
"bits de dirección B_READ y B_WRITE son mutuamente excluyentes."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:591
msgid "B_READ - read from the ISA bus into memory"
msgstr "B_READ - lee desde el bus ISA hacia memoria"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:592
msgid "B_WRITE - write from the memory to the ISA bus"
msgstr "B_WRITE - escribe desde memoria hacia el bus ISA"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:593
msgid ""
"B_RAW - if set then the DMA controller will remember the buffer and after "
"the end of transfer will automatically re-initialize itself to repeat "
"transfer of the same buffer again (of course, the driver may change the data "
"in the buffer before initiating another transfer in the device). If not set "
"then the parameters will work only for one transfer, and `isa_dmastart()` "
"will have to be called again before initiating the next transfer. Using "
"B_RAW makes sense only if the bounce buffer is not used."
msgstr ""
"B_RAW - si se establece entonces el controlador DMA recordará el búfer y "
"después de la transferencia se reiniciará a sí mismo automáticamente para "
"repetir la transferencia del mismo búfer (por supuesto, el controlador puede "
"cambiar los datos en el búfer antes de iniciar otra transferencia en el "
"dispositivo). Si no se establece entonces los parámetros funcionarán sólo "
"para una transferencia, y se tendrá que llamar de nuevo a `isa_dmastart()` "
"antes de iniciar la siguiente transferencia. Usar B_RAW sólo tiene sentido "
"si no se usa un búfer \"bounce\"."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:595
msgid "addr - virtual address of the buffer"
msgstr "addr - dirección virtual del búfer"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:596
msgid ""
"nbytes - length of the buffer. Must be less or equal to 64KB. Length of 0 is "
"not allowed: the DMA controller will understand it as 64KB while the kernel "
"code will understand it as 0 and that would cause unpredictable effects. For "
"channels number 4 and higher the length must be even because these channels "
"transfer 2 bytes at a time. In case of an odd length the last byte will not "
"be transferred."
msgstr ""
"nbytes - longitud del búfer. Debe ser menor o igual a 64KB. La longitud 0 no "
"está permitida: el controlador DMA lo entenderá como 64KB mientras que el "
"código del núcleo lo entenderá como 0 y eso tendría efectos impredecibles. "
"Para los canales número 4 y superiores la longitud debe ser par porque estos "
"canales transfieren 2 bytes cada vez. En caso de una longitud impar no se "
"transmitirá el último byte."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:597
msgid "chan - channel number"
msgstr "chan - número de canal"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:598
msgid "`void isa_dmadone(int flags, caddr_t addr, int nbytes, int chan)`"
msgstr "`void isa_dmadone(int flags, caddr_t addr, int nbytes, int chan)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:600
msgid ""
"Synchronize the memory after device reports that transfer is done. If that "
"was a read operation with a bounce buffer then the data will be copied from "
"the bounce buffer to the original buffer. Arguments are the same as for "
"`isa_dmastart()`. Flag B_RAW is permitted but it does not affect "
"`isa_dmadone()` in any way."
msgstr ""
"Sincroniza la memoria después de que el dispositivo informe de que la "
"transferencia ha finalizado. Si era una operación de lectura con un búfer de "
"amortiguación entonces los datos se copiarán desde el búfer de amortiguación "
"al búfer original. Los argumentos son los mismos que para `isa_dmastart()`. "
"Se permite el flag B_RAW pero no afecta a `isa_dmadone()` en modo alguno."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:601
msgid "`int isa_dmastatus(int channel_number)`"
msgstr "`int isa_dmastatus(int channel_number)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:603
msgid ""
"Returns the number of bytes left in the current transfer to be transferred. "
"In case the flag B_READ was set in `isa_dmastart()` the number returned will "
"never be equal to zero. At the end of transfer it will be automatically "
"reset back to the length of buffer. The normal use is to check the number of "
"bytes left after the device signals that the transfer is completed. If the "
"number of bytes is not 0 then something probably went wrong with that "
"transfer."
msgstr ""
"Devuelve el número de bytes que faltan por transferir en la transferencia "
"actual. En caso de que se estableciera el flag B_READ en `isa_dmastart()` el "
"número devuelto nunca será cero. Al final de la transferencia se reseteará "
"automáticamente al tamaño del búfer. El uso normal es comprobar el número de "
"bytes pendientes después de que el dispositivo señalice que la transferencia "
"se ha completado. Si el número de bytes no es 0 entonces algo ha ido mal con "
"la transferencia."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:604
msgid "`int isa_dmastop(int channel_number)`"
msgstr "`int isa_dmastop(int channel_number)`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:606
msgid ""
"Aborts the current transfer and returns the number of bytes left "
"untransferred."
msgstr ""
"Aborta la transferencia actual y devuelve el número de bytes que quedan por "
"transferir."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:608
#, no-wrap
msgid "xxx_isa_probe"
msgstr "xxx_isa_probe"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:611
msgid ""
"This function probes if a device is present. If the driver supports auto-"
"detection of some part of device configuration (such as interrupt vector or "
"memory address) this auto-detection must be done in this routine."
msgstr ""
"Esta función sondea si un dispositivo está presente. Si el controlador "
"soporta auto-detección de alguna parte de la configuración (como un vector "
"de interrupción o dirección de memoria) esta auto-detección se debe hacer en "
"esta rutina."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:613
msgid ""
"As for any other bus, if the device cannot be detected or is detected but "
"failed the self-test or some other problem happened then it returns a "
"positive value of error. The value `ENXIO` must be returned if the device is "
"not present. Other error values may mean other conditions. Zero or negative "
"values mean success. Most of the drivers return zero as success."
msgstr ""
"Como en cualquier otro bus, si el dispositivo no puede ser detectado o es "
"detectado pero falla en el auto chequeo o hay algún otro problema entonces "
"devuelve un valor de error positivo. El valor `ENXIO` se debe devolver si el "
"dispositivo no está presente. Otros valores pueden significar otras "
"condiciones. Cero o valores negativos significan éxito. La mayoría de los "
"controladores devuelven cero como éxito."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:615
msgid ""
"The negative return values are used when a PnP device supports multiple "
"interfaces. For example, an older compatibility interface and a newer "
"advanced interface which are supported by different drivers. Then both "
"drivers would detect the device. The driver which returns a higher value in "
"the probe routine takes precedence (in other words, the driver returning 0 "
"has highest precedence, one returning -1 is next, one returning -2 is after "
"it and so on). In result the devices which support only the old interface "
"will be handled by the old driver (which should return -1 from the probe "
"routine) while the devices supporting the new interface as well will be "
"handled by the new driver (which should return 0 from the probe routine)."
msgstr ""
"Los valores de retorno negativos se usan cuando un dispositivo PnP suporta "
"múltiples interfaces. Por ejemplo, una interfaz de compatibilidad más "
"antigua y una interfaz avanzada más nueva que son soportadas por diferentes "
"controladores. Ambos controladores detectarán el dispositivo. El controlador "
"que devuelva el valor más alto en la rutina de sondeo tomará precedencia (en "
"otras palabras, el controlador que devuelva 0 tendrá la precedencia más "
"alta, el que devuelva -1 la siguiente, el que de devuelva -2 la siguiente y "
"así). Como resultado los dispositivos que sólo soporten la interfaz antigua "
"se manejarán con el controlador antiguo (que debería devolver -1 en la "
"rutina de sondeo) mientras que los dispositivos que soporten interfaces "
"nuevas también serán manejadas por controladores nuevos (que deberían "
"devolver 0 desde la rutina de sondeo)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:617
msgid ""
"The device descriptor struct xxx_softc is allocated by the system before "
"calling the probe routine. If the probe routine returns an error the "
"descriptor will be automatically deallocated by the system. So if a probing "
"error occurs the driver must make sure that all the resources it used during "
"probe are deallocated and that nothing keeps the descriptor from being "
"safely deallocated. If the probe completes successfully the descriptor will "
"be preserved by the system and later passed to the routine "
"`xxx_isa_attach()`. If a driver returns a negative value it can not be sure "
"that it will have the highest priority and its attach routine will be "
"called. So in this case it also must release all the resources before "
"returning and if necessary allocate them again in the attach routine. When "
"`xxx_isa_probe()` returns 0 releasing the resources before returning is also "
"a good idea and a well-behaved driver should do so. But in cases where there "
"is some problem with releasing the resources the driver is allowed to keep "
"resources between returning 0 from the probe routine and execution of the "
"attach routine."
msgstr ""
"El descriptor de dispositivo struct xxx_softc es reservado por el sistema "
"antes de llamar a la rutina de sondeo. Si la rutina de sondeo devuelve error "
"el sistema libera el descriptor automáticamente. De forma que si ocurre un "
"error de sondeo el controlador debe asegurarse de que todos los recursos "
"usados durante el sondeo son liberados y que nada impide que el descriptor "
"pueda ser liberado con seguridad. Si el sondeo termina con éxito el sistema "
"guardará el descriptor y lo pasará posteriormente a la rutina "
"`xxx_isa_attach()`. Si un controlador devuelve un valor negativo no puede "
"estar seguro de que tendrá la máxima prioridad y se llamará a su rutina de "
"adjuntar. En este caso también debe liberar los recursos antes de regresar y "
"si es necesario reservarlos de nuevo en la rutina de adjuntar. Cuando "
"`xxx_isa_probe()` devuelve 0 también es buena idea liberar los recursos "
"antes de volver y un buen controlador debería hacerlo. Pero en casos donde "
"hay algún problema liberando recursos se permite al controlador mantenerlos "
"entre que devuelve 0 desde la rutina de sondeo y la ejecución de la rutina "
"de adjuntar."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:619
msgid ""
"A typical probe routine starts with getting the device descriptor and unit:"
msgstr ""
"Una rutina de sondeo típica comienza obteniendo el descriptor y la unidad "
"del dispositivo:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:626
#, no-wrap
msgid ""
"         struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int pnperror;\n"
"          int error = 0;\n"
msgstr ""
"         struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int pnperror;\n"
"          int error = 0;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:629
#, no-wrap
msgid ""
"          sc->dev = dev; /* link it back */\n"
"          sc->unit = unit;\n"
msgstr ""
"          sc->dev = dev; /* link it back */\n"
"          sc->unit = unit;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:632
msgid ""
"Then check for the PnP devices. The check is carried out by a table "
"containing the list of PnP IDs supported by this driver and human-readable "
"descriptions of the device models corresponding to these IDs."
msgstr ""
"Después comprueba los dispositivos PnP. La comprobación se realiza con una "
"tabla que contiene la lista de IDs PnP soportados por el controlador y unas "
"descripciones en formato legible de los modelos de dispositivo que "
"corresponden con esos IDs."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:638
#, no-wrap
msgid ""
"        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,\n"
"        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;\n"
msgstr ""
"        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,\n"
"        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:641
msgid ""
"The logic of ISA_PNP_PROBE is the following: If this card (device unit) was "
"not detected as PnP then ENOENT will be returned. If it was detected as PnP "
"but its detected ID does not match any of the IDs in the table then ENXIO is "
"returned. Finally, if it has PnP support and it matches on of the IDs in the "
"table, 0 is returned and the appropriate description from the table is set "
"by `device_set_desc()`."
msgstr ""
"La lógica de ISA_PNP_PROBE es la siguiente: si la tarjeta (unidad de "
"dispositivo) no se detectó como PnP, entonces se devuelve ENOENT. Si se "
"detectó como PnP pero su ID no corresponde con ninguno de los IDs de la "
"tabla entonces se devuelve ENXIO. Por último, si tiene soporte PnP y "
"concuerda con un ID de la tabla, se devuelve 0 y se establece la descripción "
"correspondiente de la tabla en la función `device_set_desc()`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:643
msgid ""
"If a driver supports only PnP devices then the condition would look like:"
msgstr ""
"Si un controlador sólo soporta dispositivos PnP entonces la condición sería:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:648
#, no-wrap
msgid ""
"          if(pnperror != 0)\n"
"              return pnperror;\n"
msgstr ""
"          if(pnperror != 0)\n"
"              return pnperror;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:651
msgid ""
"No special treatment is required for the drivers which do not support PnP "
"because they pass an empty PnP ID table and will always get ENXIO if called "
"on a PnP card."
msgstr ""
"No se requiere un tratamiento especial para los controladores que no "
"soportan PnP porque pasan un ID vacío a la tabla y siempre obtendrán ENXIO "
"si se llama sobre una tarjeta PnP."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:653
msgid ""
"The probe routine normally needs at least some minimal set of resources, "
"such as I/O port number to find the card and probe it. Depending on the "
"hardware the driver may be able to discover the other necessary resources "
"automatically. The PnP devices have all the resources pre-set by the PnP "
"subsystem, so the driver does not need to discover them by itself."
msgstr ""
"Normalmente la rutina de sondeo necesita al menos un conjunto mínimo de "
"recursos, como números de puerto de I/O para encontrar la tarjeta y "
"sondearla. Dependiendo del hardware el controlador puede ser capaz de "
"descubrir otros recursos automáticamente. Los dispositivos PnP tienen todos "
"los recursos preestablecidos por el subsistema PnP, así que el controlador "
"no necesita descubrirlos por él mismo."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:655
msgid ""
"Typically the minimal information required to get access to the device is "
"the I/O port number. Then some devices allow to get the rest of information "
"from the device configuration registers (though not all devices do that). So "
"first we try to get the port start value:"
msgstr ""
"Típicamente la información mínima necesaria para acceder al dispositivo es "
"el número de puerto de I/O. Después algunos dispositivos permiten obtener el "
"resto de la información de los registros de configuración del dispositivo "
"(aunque no todos los dispositivos lo hacen). Así que primero intentamos "
"obtener el valor de inicio del puerto:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:660
#, no-wrap
msgid ""
" sc->port0 = bus_get_resource_start(dev,\n"
"        SYS_RES_IOPORT, 0 /*rid*/); if(sc->port0 == 0) return ENXIO;\n"
msgstr ""
" sc->port0 = bus_get_resource_start(dev,\n"
"        SYS_RES_IOPORT, 0 /*rid*/); if(sc->port0 == 0) return ENXIO;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:663
msgid ""
"The base port address is saved in the structure softc for future use. If it "
"will be used very often then calling the resource function each time would "
"be prohibitively slow. If we do not get a port we just return an error. Some "
"device drivers can instead be clever and try to probe all the possible "
"ports, like this:"
msgstr ""
"La dirección base del puerto se salva en la estructura softc para su uso "
"posterior. Se fuera a usarse muy a menudo llamar a la función del recurso "
"cada vez sería muy lento. Si no obtenemos un puerto simplemente devolvemos "
"un error. Algunos controladores de dispositivo pueden intentar ser listos y "
"probar a sondear todos los puertos posibles, de esta forma:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:677
#, no-wrap
msgid ""
"          /* table of all possible base I/O port addresses for this device */\n"
"          static struct xxx_allports {\n"
"              u_short port; /* port address */\n"
"              short used; /* flag: if this port is already used by some unit */\n"
"          } xxx_allports = {\n"
"              { 0x300, 0 },\n"
"              { 0x320, 0 },\n"
"              { 0x340, 0 },\n"
"              { 0, 0 } /* end of table */\n"
"          };\n"
msgstr ""
"          /* table of all possible base I/O port addresses for this device */\n"
"          static struct xxx_allports {\n"
"              u_short port; /* port address */\n"
"              short used; /* flag: if this port is already used by some unit */\n"
"          } xxx_allports = {\n"
"              { 0x300, 0 },\n"
"              { 0x320, 0 },\n"
"              { 0x340, 0 },\n"
"              { 0, 0 } /* end of table */\n"
"          };\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:681
#, no-wrap
msgid ""
"          ...\n"
"          int port, i;\n"
"          ...\n"
msgstr ""
"          ...\n"
"          int port, i;\n"
"          ...\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:687
#, no-wrap
msgid ""
"          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);\n"
"          if(port !=0 ) {\n"
"              for(i=0; xxx_allports[i].port!=0; i++) {\n"
"                  if(xxx_allports[i].used || xxx_allports[i].port != port)\n"
"                      continue;\n"
msgstr ""
"          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);\n"
"          if(port !=0 ) {\n"
"              for(i=0; xxx_allports[i].port!=0; i++) {\n"
"                  if(xxx_allports[i].used || xxx_allports[i].port != port)\n"
"                      continue;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:695
#, no-wrap
msgid ""
"                  /* found it */\n"
"                  xxx_allports[i].used = 1;\n"
"                  /* do probe on a known port */\n"
"                  return xxx_really_probe(dev, port);\n"
"              }\n"
"              return ENXIO; /* port is unknown or already used */\n"
"          }\n"
msgstr ""
"                  /* found it */\n"
"                  xxx_allports[i].used = 1;\n"
"                  /* do probe on a known port */\n"
"                  return xxx_really_probe(dev, port);\n"
"              }\n"
"              return ENXIO; /* port is unknown or already used */\n"
"          }\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:700
#, no-wrap
msgid ""
"          /* we get here only if we need to guess the port */\n"
"          for(i=0; xxx_allports[i].port!=0; i++) {\n"
"              if(xxx_allports[i].used)\n"
"                  continue;\n"
msgstr ""
"          /* we get here only if we need to guess the port */\n"
"          for(i=0; xxx_allports[i].port!=0; i++) {\n"
"              if(xxx_allports[i].used)\n"
"                  continue;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:705
#, no-wrap
msgid ""
"              /* mark as used - even if we find nothing at this port\n"
"               * at least we won't probe it in future\n"
"               */\n"
"               xxx_allports[i].used = 1;\n"
msgstr ""
"              /* mark as used - even if we find nothing at this port\n"
"               * at least we won't probe it in future\n"
"               */\n"
"               xxx_allports[i].used = 1;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:712
#, no-wrap
msgid ""
"              error = xxx_really_probe(dev, xxx_allports[i].port);\n"
"              if(error == 0) /* found a device at that port */\n"
"                  return 0;\n"
"          }\n"
"          /* probed all possible addresses, none worked */\n"
"          return ENXIO;\n"
msgstr ""
"              error = xxx_really_probe(dev, xxx_allports[i].port);\n"
"              if(error == 0) /* found a device at that port */\n"
"                  return 0;\n"
"          }\n"
"          /* probed all possible addresses, none worked */\n"
"          return ENXIO;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:715
msgid ""
"Of course, normally the driver's `identify()` routine should be used for "
"such things. But there may be one valid reason why it may be better to be "
"done in `probe()`: if this probe would drive some other sensitive device "
"crazy. The probe routines are ordered with consideration of the `sensitive` "
"flag: the sensitive devices get probed first and the rest of the devices "
"later. But the `identify()` routines are called before any probes, so they "
"show no respect to the sensitive devices and may upset them."
msgstr ""
"Por supuesto, normalmente se debería usar la rutina `identify()` de los "
"controladores para estas cosas. Pero podría haber alguna razón válida para "
"que fuera mejor hacerlo en `probe()`: si este sondeo hace enloquecer a algún "
"otro dispositivo que sea sensible. Las rutinas de sondeo se ordenan conforme "
"al flag `sensitive`: los dispositivos sensibles se prueban primero y luego "
"van los demás dispositivos. Pero las rutinas `identify()` se llaman antes "
"que ningún sondeo, de forma que no respetan a los dispositivos sensibles y "
"podrían ponerlos tristes."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:717
msgid ""
"Now, after we got the starting port we need to set the port count (except "
"for PnP devices) because the kernel does not have this information in the "
"configuration file."
msgstr ""
"Ahora, después de tener el puerto de inicio necesitamos establecer el número "
"de puertos (excepto para los dispositivos PnP) porque el kernel no tiene "
"esta información en el fichero de configuración."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:725
#, no-wrap
msgid ""
"         if(pnperror /* only for non-PnP devices */\n"
"         && bus_set_resource(dev, SYS_RES_IOPORT, 0, sc->port0,\n"
"         XXX_PORT_COUNT)<0)\n"
"             return ENXIO;\n"
msgstr ""
"         if(pnperror /* only for non-PnP devices */\n"
"         && bus_set_resource(dev, SYS_RES_IOPORT, 0, sc->port0,\n"
"         XXX_PORT_COUNT)<0)\n"
"             return ENXIO;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:728
msgid ""
"Finally allocate and activate a piece of port address space (special values "
"of start and end mean \"use those we set by ``bus_set_resource()``\"):"
msgstr ""
"Por último reservar y activar una parte del espacio de direcciones del "
"puerto (valores especiales de start y end significan \"usa aquellos "
"establecidos por ``bus_set_resource()``\"):"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:736
#, no-wrap
msgid ""
"          sc->port0_rid = 0;\n"
"          sc->port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,\n"
"          &sc->port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
msgstr ""
"          sc->port0_rid = 0;\n"
"          sc->port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,\n"
"          &sc->port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:739
#, no-wrap
msgid ""
"          if(sc->port0_r == NULL)\n"
"              return ENXIO;\n"
msgstr ""
"          if(sc->port0_r == NULL)\n"
"              return ENXIO;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:742
msgid ""
"Now having access to the port-mapped registers we can poke the device in "
"some way and check if it reacts like it is expected to. If it does not then "
"there is probably some other device or no device at all at this address."
msgstr ""
"Ahora que tenemos acceso a los registros de los puertos mapeados podemos "
"mirar en el dispositivo y comprobar si reacciona como se supone que debería "
"hacerlo. Si no lo hace entonces probablemente haya otro dispositivo o no "
"haya dispositivo en absoluto en esta dirección."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:744
msgid ""
"Normally drivers do not set up the interrupt handlers until the attach "
"routine. Instead they do probes in the polling mode using the `DELAY()` "
"function for timeout. The probe routine must never hang forever, all the "
"waits for the device must be done with timeouts. If the device does not "
"respond within the time it is probably broken or misconfigured and the "
"driver must return error. When determining the timeout interval give the "
"device some extra time to be on the safe side: although `DELAY()` is "
"supposed to delay for the same amount of time on any machine it has some "
"margin of error, depending on the exact CPU."
msgstr ""
"Normalmente los controladores con configuran manejadores de interrupción "
"hasta la rutina de adjuntar. En su lugar sondean en modo encuesta usando la "
"función `DELAY()` como timeout. La rutina de sondeo nunca debe esperar para "
"siempre, todas las esperas del dispositivo deben hacerse con timeouts. Si el "
"dispositivo no responde dentro del tiempo está probablemente roto o mal "
"configurado y el controlador debe devolver error. Cuando determines el "
"intervalo de timeout concede algo de tiempo extra el dispositivo para "
"asegurarte: aunque se supone que `DELAY()` debe esperar la misma cantidad de "
"tiempo en cualquier máquina tiene algo de margen de error, dependiendo de la "
"CPU exacta."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:746
msgid ""
"If the probe routine really wants to check that the interrupts really work "
"it may configure and probe the interrupts too. But that is not recommended."
msgstr ""
"Si la rutina de sondeo realmente quiere comprobar que las interrupciones "
"funcionan puede configurar y sondear las interrupciones. Pero no se "
"recomienda."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:753
#, no-wrap
msgid ""
"          /* implemented in some very device-specific way */\n"
"          if(error = xxx_probe_ports(sc))\n"
"              goto bad; /* will deallocate the resources before returning */\n"
msgstr ""
"          /* implemented in some very device-specific way */\n"
"          if(error = xxx_probe_ports(sc))\n"
"              goto bad; /* will deallocate the resources before returning */\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:756
msgid ""
"The function `xxx_probe_ports()` may also set the device description "
"depending on the exact model of device it discovers. But if there is only "
"one supported device model this can be as well done in a hardcoded way. Of "
"course, for the PnP devices the PnP support sets the description from the "
"table automatically."
msgstr ""
"La función `xxx_probe_ports()`también puede establecer la descripción del "
"dispositivo dependiendo del modelo exacto que descubre. Pero si sólo hay un "
"modelo de dispositivo soportado también se puede establecer estáticamente. "
"Por supuesto, para los dispositivos PnP el soporte de PnP establece la "
"descripción desde la tabla automáticamente."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:761
#, no-wrap
msgid ""
"          if(pnperror)\n"
"              device_set_desc(dev, \"Our device model 1234\");\n"
msgstr ""
"          if(pnperror)\n"
"              device_set_desc(dev, \"Our device model 1234\");\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:764
msgid ""
"Then the probe routine should either discover the ranges of all the "
"resources by reading the device configuration registers or make sure that "
"they were set explicitly by the user. We will consider it with an example of "
"on-board memory. The probe routine should be as non-intrusive as possible, "
"so allocation and check of functionality of the rest of resources (besides "
"the ports) would be better left to the attach routine."
msgstr ""
"Después la rutina de sondeo debería descubrir los rangos de todos los "
"recursos mediante la lectura de los registros de configuración del "
"dispositivo o asegurarse de que fueron configurados explícitamente por el "
"usuario. Lo consideraremos con el ejemplo de una memoria. La rutina de "
"sondeo debería ser lo menos intrusiva posible, de forma que la reserva y "
"comprobación de funcionalidad y resto de recursos (aparte de los puertos) "
"sería mejor dejarlos para la rutina de adjuntar."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:766
msgid ""
"The memory address may be specified in the kernel configuration file or on "
"some devices it may be pre-configured in non-volatile configuration "
"registers. If both sources are available and different, which one should be "
"used? Probably if the user bothered to set the address explicitly in the "
"kernel configuration file they know what they are doing and this one should "
"take precedence. An example of implementation could be:"
msgstr ""
"La dirección de memoria puede ser especificada en el fichero de "
"configuración del núcleo o en algunos dispositivos puede estar "
"preconfigurada en registros de configuración no volátiles. Si ambas fuentes "
"están disponibles y son distintas, ¿cuál se debería usar? Probablemente si "
"el usuario se ha molestado en establecer la dirección explícitamente en el "
"fichero de configuración del núcleo entonces sabe lo que está haciendo y "
"éste debería tomar precedencia. Un ejemplo de implementación podría ser:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:774
#, no-wrap
msgid ""
"          /* try to find out the config address first */\n"
"          sc->mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          if(sc->mem0_p == 0) { /* nope, not specified by user */\n"
"              sc->mem0_p = xxx_read_mem0_from_device_config(sc);\n"
msgstr ""
"          /* try to find out the config address first */\n"
"          sc->mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          if(sc->mem0_p == 0) { /* nope, not specified by user */\n"
"              sc->mem0_p = xxx_read_mem0_from_device_config(sc);\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:782
#, no-wrap
msgid ""
"          if(sc->mem0_p == 0)\n"
"                  /* can't get it from device config registers either */\n"
"                  goto bad;\n"
"          } else {\n"
"              if(xxx_set_mem0_address_on_device(sc) < 0)\n"
"                  goto bad; /* device does not support that address */\n"
"          }\n"
msgstr ""
"          if(sc->mem0_p == 0)\n"
"                  /* can't get it from device config registers either */\n"
"                  goto bad;\n"
"          } else {\n"
"              if(xxx_set_mem0_address_on_device(sc) < 0)\n"
"                  goto bad; /* device does not support that address */\n"
"          }\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:794
#, no-wrap
msgid ""
"          /* just like the port, set the memory size,\n"
"           * for some devices the memory size would not be constant\n"
"           * but should be read from the device configuration registers instead\n"
"           * to accommodate different models of devices. Another option would\n"
"           * be to let the user set the memory size as \"msize\" configuration\n"
"           * resource which will be automatically handled by the ISA bus.\n"
"           */\n"
"           if(pnperror) { /* only for non-PnP devices */\n"
"              sc->mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"              if(sc->mem0_size == 0) /* not specified by user */\n"
"                  sc->mem0_size = xxx_read_mem0_size_from_device_config(sc);\n"
msgstr ""
"          /* just like the port, set the memory size,\n"
"           * for some devices the memory size would not be constant\n"
"           * but should be read from the device configuration registers instead\n"
"           * to accommodate different models of devices. Another option would\n"
"           * be to let the user set the memory size as \"msize\" configuration\n"
"           * resource which will be automatically handled by the ISA bus.\n"
"           */\n"
"           if(pnperror) { /* only for non-PnP devices */\n"
"              sc->mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"              if(sc->mem0_size == 0) /* not specified by user */\n"
"                  sc->mem0_size = xxx_read_mem0_size_from_device_config(sc);\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:803
#, no-wrap
msgid ""
"              if(sc->mem0_size == 0) {\n"
"                  /* suppose this is a very old model of device without\n"
"                   * auto-configuration features and the user gave no preference,\n"
"                   * so assume the minimalistic case\n"
"                   * (of course, the real value will vary with the driver)\n"
"                   */\n"
"                  sc->mem0_size = 8*1024;\n"
"              }\n"
msgstr ""
"              if(sc->mem0_size == 0) {\n"
"                  /* suppose this is a very old model of device without\n"
"                   * auto-configuration features and the user gave no preference,\n"
"                   * so assume the minimalistic case\n"
"                   * (of course, the real value will vary with the driver)\n"
"                   */\n"
"                  sc->mem0_size = 8*1024;\n"
"              }\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:806
#, no-wrap
msgid ""
"              if(xxx_set_mem0_size_on_device(sc) < 0)\n"
"                  goto bad; /* device does not support that size */\n"
msgstr ""
"              if(xxx_set_mem0_size_on_device(sc) < 0)\n"
"                  goto bad; /* device does not support that size */\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:813
#, no-wrap
msgid ""
"              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,\n"
"                      sc->mem0_p, sc->mem0_size)<0)\n"
"                  goto bad;\n"
"          } else {\n"
"              sc->mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          }\n"
msgstr ""
"              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,\n"
"                      sc->mem0_p, sc->mem0_size)<0)\n"
"                  goto bad;\n"
"          } else {\n"
"              sc->mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, 0 /*rid*/);\n"
"          }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:816
msgid "Resources for IRQ and DRQ are easy to check by analogy."
msgstr ""
"Los recursos para las IRQ y DRQ son fáciles de comprobar de forma análoga."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:818
msgid "If all went well then release all the resources and return success."
msgstr "Si todo fue bien entonces libera todos los recursos y devuelve éxito."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:823
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1086
#, no-wrap
msgid ""
"          xxx_free_resources(sc);\n"
"          return 0;\n"
msgstr ""
"          xxx_free_resources(sc);\n"
"          return 0;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:826
msgid ""
"Finally, handle the troublesome situations. All the resources should be "
"deallocated before returning. We make use of the fact that before the "
"structure softc is passed to us it gets zeroed out, so we can find out if "
"some resource was allocated: then its descriptor is non-zero."
msgstr ""
"Por último, maneja las situaciones problemáticas. Todos los recursos se "
"deberían liberar antes de volver. Utilizamos el echo de que la estructura "
"softc que se nos pasa está inicializada a cero, de forma que podemos "
"averiguar si algún recurso ha sido reservado: entonces su descriptor es "
"distinto de cero."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:830
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1047
#, no-wrap
msgid "          bad:\n"
msgstr "          bad:\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:836
#, no-wrap
msgid ""
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"                return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;\n"
msgstr ""
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"                return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:839
msgid ""
"That would be all for the probe routine. Freeing of resources is done from "
"multiple places, so it is moved to a function which may look like:"
msgstr ""
"Eso sería todo para la rutina de comprobación. La liberación de los recursos "
"se hace desde distintos sitios, de forma que se mueve a una función que "
"podría parecerse a esta:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:847
#, no-wrap
msgid ""
"static void\n"
"           xxx_free_resources(sc)\n"
"              struct xxx_softc *sc;\n"
"          {\n"
"              /* check every resource and free if not zero */\n"
msgstr ""
"static void\n"
"           xxx_free_resources(sc)\n"
"              struct xxx_softc *sc;\n"
"          {\n"
"              /* check every resource and free if not zero */\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:855
#, no-wrap
msgid ""
"              /* interrupt handler */\n"
"              if(sc->intr_r) {\n"
"                  bus_teardown_intr(sc->dev, sc->intr_r, sc->intr_cookie);\n"
"                  bus_release_resource(sc->dev, SYS_RES_IRQ, sc->intr_rid,\n"
"                      sc->intr_r);\n"
"                  sc->intr_r = 0;\n"
"              }\n"
msgstr ""
"              /* interrupt handler */\n"
"              if(sc->intr_r) {\n"
"                  bus_teardown_intr(sc->dev, sc->intr_r, sc->intr_cookie);\n"
"                  bus_release_resource(sc->dev, SYS_RES_IRQ, sc->intr_rid,\n"
"                      sc->intr_r);\n"
"                  sc->intr_r = 0;\n"
"              }\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:870
#, no-wrap
msgid ""
"              /* all kinds of memory maps we could have allocated */\n"
"              if(sc->data_p) {\n"
"                  bus_dmamap_unload(sc->data_tag, sc->data_map);\n"
"                  sc->data_p = 0;\n"
"              }\n"
"               if(sc->data) { /* sc->data_map may be legitimately equal to 0 */\n"
"                  /* the map will also be freed */\n"
"                  bus_dmamem_free(sc->data_tag, sc->data, sc->data_map);\n"
"                  sc->data = 0;\n"
"              }\n"
"              if(sc->data_tag) {\n"
"                  bus_dma_tag_destroy(sc->data_tag);\n"
"                  sc->data_tag = 0;\n"
"              }\n"
msgstr ""
"              /* all kinds of memory maps we could have allocated */\n"
"              if(sc->data_p) {\n"
"                  bus_dmamap_unload(sc->data_tag, sc->data_map);\n"
"                  sc->data_p = 0;\n"
"              }\n"
"               if(sc->data) { /* sc->data_map may be legitimately equal to 0 */\n"
"                  /* the map will also be freed */\n"
"                  bus_dmamem_free(sc->data_tag, sc->data, sc->data_map);\n"
"                  sc->data = 0;\n"
"              }\n"
"              if(sc->data_tag) {\n"
"                  bus_dma_tag_destroy(sc->data_tag);\n"
"                  sc->data_tag = 0;\n"
"              }\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:872
#, no-wrap
msgid "              ... free other maps and tags if we have them ...\n"
msgstr "              ... free other maps and tags if we have them ...\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:877
#, no-wrap
msgid ""
"              if(sc->parent_tag) {\n"
"                  bus_dma_tag_destroy(sc->parent_tag);\n"
"                  sc->parent_tag = 0;\n"
"              }\n"
msgstr ""
"              if(sc->parent_tag) {\n"
"                  bus_dma_tag_destroy(sc->parent_tag);\n"
"                  sc->parent_tag = 0;\n"
"              }\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:891
#, no-wrap
msgid ""
"              /* release all the bus resources */\n"
"              if(sc->mem0_r) {\n"
"                  bus_release_resource(sc->dev, SYS_RES_MEMORY, sc->mem0_rid,\n"
"                      sc->mem0_r);\n"
"                  sc->mem0_r = 0;\n"
"              }\n"
"              ...\n"
"              if(sc->port0_r) {\n"
"                  bus_release_resource(sc->dev, SYS_RES_IOPORT, sc->port0_rid,\n"
"                      sc->port0_r);\n"
"                  sc->port0_r = 0;\n"
"              }\n"
"          }\n"
msgstr ""
"              /* release all the bus resources */\n"
"              if(sc->mem0_r) {\n"
"                  bus_release_resource(sc->dev, SYS_RES_MEMORY, sc->mem0_rid,\n"
"                      sc->mem0_r);\n"
"                  sc->mem0_r = 0;\n"
"              }\n"
"              ...\n"
"              if(sc->port0_r) {\n"
"                  bus_release_resource(sc->dev, SYS_RES_IOPORT, sc->port0_rid,\n"
"                      sc->port0_r);\n"
"                  sc->port0_r = 0;\n"
"              }\n"
"          }\n"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:894
#, no-wrap
msgid "xxx_isa_attach"
msgstr "xxx_isa_attach"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:897
msgid ""
"The attach routine actually connects the driver to the system if the probe "
"routine returned success and the system had chosen to attach that driver. If "
"the probe routine returned 0 then the attach routine may expect to receive "
"the device structure softc intact, as it was set by the probe routine. Also "
"if the probe routine returns 0 it may expect that the attach routine for "
"this device shall be called at some point in the future. If the probe "
"routine returns a negative value then the driver may make none of these "
"assumptions."
msgstr ""
"La rutina de adjuntar conecta el controlador al sistema si la rutina de "
"sondeo devolvió éxito y si el sistema ha escogido adjuntar el controlar. Si "
"la rutina de sondeo devolvió 0 entonces la rutina puede esperar recibir una "
"estructura de dispositivo softc intacta, tal como ha sido configurada por la "
"rutina de sondeo. Además si la rutina de sondeo devuelve 0 puede esperar que "
"la rutina de adjuntar para este dispositivo se llame en algún momento en el "
"futuro. Si la rutina de sondeo devuelve un valor negativo entonces el "
"controlador no puede asumir ninguna de estas cosas."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:899
msgid ""
"The attach routine returns 0 if it completed successfully or error code "
"otherwise."
msgstr ""
"La rutina de adjuntar devuelve 0 si ha finalizado correctamente y devuelve "
"un error en caso contrario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:901
msgid ""
"The attach routine starts just like the probe routine, with getting some "
"frequently used data into more accessible variables."
msgstr ""
"La rutina de adjuntar comienza como cualquier otra rutina de comprobación, "
"obteniendo datos accedidos frecuentemente y guardándolos en variables más "
"accesibles."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:907
#, no-wrap
msgid ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int error = 0;\n"
msgstr ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int error = 0;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:910
msgid ""
"Then allocate and activate all the necessary resources. As normally the port "
"range will be released before returning from probe, it has to be allocated "
"again. We expect that the probe routine had properly set all the resource "
"ranges, as well as saved them in the structure softc. If the probe routine "
"had left some resource allocated then it does not need to be allocated again "
"(which would be considered an error)."
msgstr ""
"Después reserva y activa todos los recursos necesarios. Como en general el "
"rango de puertos será liberado antes de volver del sondeo, tiene que ser "
"reservado de nuevo. Esperamos que la rutina de sondeo haya establecido "
"correctamente todos los rangos de recursos, así como haberlos salvado en la "
"estructura softc. Si la rutina de sondeo ha dejado algunos recursos "
"reservados entonces no tiene que reservarlos de nuevo (lo que sería "
"considerado un error)."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:916
#, no-wrap
msgid ""
"          sc->port0_rid = 0;\n"
"          sc->port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &sc->port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
msgstr ""
"          sc->port0_rid = 0;\n"
"          sc->port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &sc->port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:919
#, no-wrap
msgid ""
"          if(sc->port0_r == NULL)\n"
"               return ENXIO;\n"
msgstr ""
"          if(sc->port0_r == NULL)\n"
"               return ENXIO;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:924
#, no-wrap
msgid ""
"          /* on-board memory */\n"
"          sc->mem0_rid = 0;\n"
"          sc->mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &sc->mem0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
msgstr ""
"          /* on-board memory */\n"
"          sc->mem0_rid = 0;\n"
"          sc->mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &sc->mem0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:927
#, no-wrap
msgid ""
"          if(sc->mem0_r == NULL)\n"
"                goto bad;\n"
msgstr ""
"          if(sc->mem0_r == NULL)\n"
"                goto bad;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:930
#, no-wrap
msgid ""
"          /* get its virtual address */\n"
"          sc->mem0_v = rman_get_virtual(sc->mem0_r);\n"
msgstr ""
"          /* get its virtual address */\n"
"          sc->mem0_v = rman_get_virtual(sc->mem0_r);\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:933
msgid ""
"The DMA request channel (DRQ) is allocated likewise. To initialize it use "
"functions of the `isa_dma*()` family. For example:"
msgstr ""
"El canal de peticiones de DMA (DRQ) se reserva del mismo modo. Para "
"inicializarlo utiliza funciones de la familia de `isa_dma*()`. Por ejemplo:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:935
msgid "`isa_dmacascade(sc->drq0);`"
msgstr "`isa_dmacascade(sc->drq0);`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:937
msgid ""
"The interrupt request line (IRQ) is a bit special. Besides allocation the "
"driver's interrupt handler should be associated with it. Historically in the "
"old ISA drivers the argument passed by the system to the interrupt handler "
"was the device unit number. But in modern drivers the convention suggests "
"passing the pointer to structure softc. The important reason is that when "
"the structures softc are allocated dynamically then getting the unit number "
"from softc is easy while getting softc from the unit number is difficult. "
"Also this convention makes the drivers for different buses look more uniform "
"and allows them to share the code: each bus gets its own probe, attach, "
"detach and other bus-specific routines while the bulk of the driver code may "
"be shared among them."
msgstr ""
"La línea de petición de interrupción (IRQ) es un poco especial. Además de la "
"asignación el manejador de interrupción del controlador debería estar "
"asociado a ella. Históricamente en los controladores ISA antiguos el "
"argumento que el sistema pasaba al manejador de interrupción era el número "
"de unidad del dispositivo. Pero en controladores modernos la convención "
"sugiere pasar un puntero a la estructura softc. La razón importante es que "
"cuando las structuras softc son asignadas dinámicamente obtener el número a "
"partir de softc es fácil mientras que obtener softc a partir del número de "
"unidad es difícil. Además esta convención hace que los controladores de los "
"diferentes buses parezcan más uniformes y les permite compartir código: cada "
"bus tiene su propio sondeo, adjuntar, liberar y otras rutinas de bus "
"específicas mientras que el grueso del código del controlador puede estar "
"compartido entre ellos."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:944
#, no-wrap
msgid ""
"          sc->intr_rid = 0;\n"
"          sc->intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &sc->intr_rid,\n"
"                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
msgstr ""
"          sc->intr_rid = 0;\n"
"          sc->intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &sc->intr_rid,\n"
"                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:947
#, no-wrap
msgid ""
"          if(sc->intr_r == NULL)\n"
"              goto bad;\n"
msgstr ""
"          if(sc->intr_r == NULL)\n"
"              goto bad;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:956
#, no-wrap
msgid ""
"          /*\n"
"           * XXX_INTR_TYPE is supposed to be defined depending on the type of\n"
"           * the driver, for example as INTR_TYPE_CAM for a CAM driver\n"
"           */\n"
"          error = bus_setup_intr(dev, sc->intr_r, XXX_INTR_TYPE,\n"
"              (driver_intr_t *) xxx_intr, (void *) sc, &sc->intr_cookie);\n"
"          if(error)\n"
"              goto bad;\n"
msgstr ""
"          /*\n"
"           * XXX_INTR_TYPE is supposed to be defined depending on the type of\n"
"           * the driver, for example as INTR_TYPE_CAM for a CAM driver\n"
"           */\n"
"          error = bus_setup_intr(dev, sc->intr_r, XXX_INTR_TYPE,\n"
"              (driver_intr_t *) xxx_intr, (void *) sc, &sc->intr_cookie);\n"
"          if(error)\n"
"              goto bad;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:959
msgid ""
"If the device needs to make DMA to the main memory then this memory should "
"be allocated like described before:"
msgstr ""
"Si el dispositivo necesita hacer DMA a la memoria principal entonces esta "
"memoria se debería asignar como se describe anteriormente:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:971
#, no-wrap
msgid ""
"          error=bus_dma_tag_create(NULL, /*alignment*/ 4,\n"
"              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,\n"
"              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,\n"
"              /*nsegments*/ BUS_SPACE_UNRESTRICTED,\n"
"              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,\n"
"              &sc->parent_tag);\n"
"          if(error)\n"
"              goto bad;\n"
msgstr ""
"          error=bus_dma_tag_create(NULL, /*alignment*/ 4,\n"
"              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,\n"
"              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,\n"
"              /*nsegments*/ BUS_SPACE_UNRESTRICTED,\n"
"              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,\n"
"              &sc->parent_tag);\n"
"          if(error)\n"
"              goto bad;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:988
#, no-wrap
msgid ""
"          /* many things get inherited from the parent tag\n"
"           * sc->data is supposed to point to the structure with the shared data,\n"
"           * for example for a ring buffer it could be:\n"
"           * struct {\n"
"           *   u_short rd_pos;\n"
"           *   u_short wr_pos;\n"
"           *   char    bf[XXX_RING_BUFFER_SIZE]\n"
"           * } *data;\n"
"           */\n"
"          error=bus_dma_tag_create(sc->parent_tag, 1,\n"
"              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ sizeof(* sc->data), /*nsegments*/ 1,\n"
"              /*maxsegsz*/ sizeof(* sc->data), /*flags*/ 0,\n"
"              &sc->data_tag);\n"
"          if(error)\n"
"              goto bad;\n"
msgstr ""
"          /* many things get inherited from the parent tag\n"
"           * sc->data is supposed to point to the structure with the shared data,\n"
"           * for example for a ring buffer it could be:\n"
"           * struct {\n"
"           *   u_short rd_pos;\n"
"           *   u_short wr_pos;\n"
"           *   char    bf[XXX_RING_BUFFER_SIZE]\n"
"           * } *data;\n"
"           */\n"
"          error=bus_dma_tag_create(sc->parent_tag, 1,\n"
"              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ sizeof(* sc->data), /*nsegments*/ 1,\n"
"              /*maxsegsz*/ sizeof(* sc->data), /*flags*/ 0,\n"
"              &sc->data_tag);\n"
"          if(error)\n"
"              goto bad;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:993
#, no-wrap
msgid ""
"          error = bus_dmamem_alloc(sc->data_tag, &sc->data, /* flags*/ 0,\n"
"              &sc->data_map);\n"
"          if(error)\n"
"               goto bad;\n"
msgstr ""
"          error = bus_dmamem_alloc(sc->data_tag, &sc->data, /* flags*/ 0,\n"
"              &sc->data_map);\n"
"          if(error)\n"
"               goto bad;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1009
#, no-wrap
msgid ""
"          /* xxx_alloc_callback() just saves the physical address at\n"
"           * the pointer passed as its argument, in this case &sc->data_p.\n"
"           * See details in the section on bus memory mapping.\n"
"           * It can be implemented like:\n"
"           *\n"
"           * static void\n"
"           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,\n"
"           *     int nseg, int error)\n"
"           * {\n"
"           *    *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"           * }\n"
"           */\n"
"          bus_dmamap_load(sc->data_tag, sc->data_map, (void *)sc->data,\n"
"              sizeof (* sc->data), xxx_alloc_callback, (void *) &sc->data_p,\n"
"              /*flags*/0);\n"
msgstr ""
"          /* xxx_alloc_callback() just saves the physical address at\n"
"           * the pointer passed as its argument, in this case &sc->data_p.\n"
"           * See details in the section on bus memory mapping.\n"
"           * It can be implemented like:\n"
"           *\n"
"           * static void\n"
"           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,\n"
"           *     int nseg, int error)\n"
"           * {\n"
"           *    *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"           * }\n"
"           */\n"
"          bus_dmamap_load(sc->data_tag, sc->data_map, (void *)sc->data,\n"
"              sizeof (* sc->data), xxx_alloc_callback, (void *) &sc->data_p,\n"
"              /*flags*/0);\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1012
msgid ""
"After all the necessary resources are allocated the device should be "
"initialized. The initialization may include testing that all the expected "
"features are functional."
msgstr ""
"Después de que todos los recursos necesarios estén asignados el dispositivo "
"se debería inicializar. La inicialización podría incluir la comprobación de "
"que todas las características esperadas son funcionales."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1017
#, no-wrap
msgid ""
"          if(xxx_initialize(sc) < 0)\n"
"               goto bad;\n"
msgstr ""
"          if(xxx_initialize(sc) < 0)\n"
"               goto bad;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1020
msgid ""
"The bus subsystem will automatically print on the console the device "
"description set by probe. But if the driver wants to print some extra "
"information about the device it may do so, for example:"
msgstr ""
"El subsistema del bus imprimirá automáticamente en la consola la descripción "
"del dispositivo establecida mediante el sondeo. Pero si un controlador "
"quiere imprimir información extra acerca del dispositivo puede hacerlo, por "
"ejemplo:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1025
#, no-wrap
msgid "        device_printf(dev, \"has on-card FIFO buffer of %d bytes\\n\", sc->fifosize);\n"
msgstr "        device_printf(dev, \"has on-card FIFO buffer of %d bytes\\n\", sc->fifosize);\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1028
msgid ""
"If the initialization routine experiences any problems then printing "
"messages about them before returning error is also recommended."
msgstr ""
"Si la rutina de inicialización sufre algún problema entonces también es "
"recomendable imprimir mensajes sobre ellos antes de devolver error."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1030
msgid ""
"The final step of the attach routine is attaching the device to its "
"functional subsystem in the kernel. The exact way to do it depends on the "
"type of the driver: a character device, a block device, a network device, a "
"CAM SCSI bus device and so on."
msgstr ""
"El paso final de la rutina de adjuntar es adjuntar el dispositivo al su "
"subsistema funcional en el núcleo. La forma exacta de hacerlo depende del "
"tipo de controlador: un dispositivo de caracteres, un dispositivo de "
"bloques, un dispositivo de red, un dispositivo de bus CAM SCSI y así."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1032
msgid "If all went well then return success."
msgstr "Si todo ha ido bien entonces devuelve éxito."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1038
#, no-wrap
msgid ""
"          error = xxx_attach_subsystem(sc);\n"
"          if(error)\n"
"              goto bad;\n"
msgstr ""
"          error = xxx_attach_subsystem(sc);\n"
"          if(error)\n"
"              goto bad;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1040
#, no-wrap
msgid "          return 0;\n"
msgstr "          return 0;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1043
msgid ""
"Finally, handle the troublesome situations. All the resources should be "
"deallocated before returning an error. We make use of the fact that before "
"the structure softc is passed to us it gets zeroed out, so we can find out "
"if some resource was allocated: then its descriptor is non-zero."
msgstr ""
"Por último, maneja las situaciones problemáticas. Todos los recursos "
"deberían ser desasignados antes de devolver un error. Utilizamos el hecho de "
"que la estructura softc se pone a cero antes de que se nos pase, de forma "
"que podemos averiguar si se ha asignado algún recurso: entonces su "
"descriptor no es cero."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1053
#, no-wrap
msgid ""
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"              return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;\n"
msgstr ""
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"              return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1056
msgid "That would be all for the attach routine."
msgstr "Eso sería todo para la rutina de adjuntar."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1058
#, no-wrap
msgid "xxx_isa_detach"
msgstr "xxx_isa_detach"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1061
msgid ""
"If this function is present in the driver and the driver is compiled as a "
"loadable module then the driver gets the ability to be unloaded. This is an "
"important feature if the hardware supports hot plug. But the ISA bus does "
"not support hot plug, so this feature is not particularly important for the "
"ISA devices. The ability to unload a driver may be useful when debugging it, "
"but in many cases installation of the new version of the driver would be "
"required only after the old version somehow wedges the system and a reboot "
"will be needed anyway, so the efforts spent on writing the detach routine "
"may not be worth it. Another argument that unloading would allow upgrading "
"the drivers on a production machine seems to be mostly theoretical. "
"Installing a new version of a driver is a dangerous operation which should "
"never be performed on a production machine (and which is not permitted when "
"the system is running in secure mode). Still, the detach routine may be "
"provided for the sake of completeness."
msgstr ""
"Si esta función está presente en el controlador y éste está compilado como "
"un módulo cargable entonces el controlador tiene la habilidad de ser "
"descargado. Esta es una característica importante si el hardware soporta ser "
"enchufado en caliente. Pero el bus ISA no soporta enchufes en caliente, así "
"que esta característica no es particularmente importante para los "
"dispositivos ISA. La habilidad para descargar un controlador podría ser útil "
"al depurar, pero en muchos casos la instalación de una nueva versión del "
"controlador sólo sería requerida si de algún modo la antigua versión del "
"hace que se necesite reiniciar, de forma que los esfuerzos en escribir la "
"rutina de desadjuntar podrían no merecer la pena. Argumentar que la descarga "
"permitiría actualizar los controladores en una máquina de producción parece "
"más bien teórico. Instalar una nueva versión de un controlador es una "
"operación peligrosa que nunca se debería hacer en una máquina en producción "
"(y que no se permite cuando el sistema está corriendo en modo seguro). Aún "
"así, la rutina de desadjuntar podría proporcionarse por consistencia."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1063
msgid ""
"The detach routine returns 0 if the driver was successfully detached or the "
"error code otherwise."
msgstr ""
"La rutina de desadjuntar devuelve 0 si el controlador se desadjuntó "
"correctamente o el código de error en caso contrario."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1065
msgid ""
"The logic of detach is a mirror of the attach. The first thing to do is to "
"detach the driver from its kernel subsystem. If the device is currently open "
"then the driver has two choices: refuse to be detached or forcibly close and "
"proceed with detach. The choice used depends on the ability of the "
"particular kernel subsystem to do a forced close and on the preferences of "
"the driver's author. Generally the forced close seems to be the preferred "
"alternative."
msgstr ""
"La lógica para desadjuntar es un espejo de la de adjuntar. Lo primero que se "
"hace es desconectar el controlador del subsistema del núcleo. Si el "
"dispositivo está abierto el controlador tiene dos opciones: oponerse a ser "
"desconectado o forzar que se cierre y proseguir. La opción depende de la "
"habilidad de un subsistema particular del núcleo para hacer un cierre "
"forzado según las preferencias del autor del controlador. Normalmente forzar "
"el cierre parece ser la alternativa preferida."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1070
#, no-wrap
msgid ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int error;\n"
msgstr ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int error;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1074
#, no-wrap
msgid ""
"          error = xxx_detach_subsystem(sc);\n"
"          if(error)\n"
"              return error;\n"
msgstr ""
"          error = xxx_detach_subsystem(sc);\n"
"          if(error)\n"
"              return error;\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1077
msgid ""
"Next the driver may want to reset the hardware to some consistent state. "
"That includes stopping any ongoing transfers, disabling the DMA channels and "
"interrupts to avoid memory corruption by the device. For most of the drivers "
"this is exactly what the shutdown routine does, so if it is included in the "
"driver we can just call it."
msgstr ""
"Después el controlador puede querer resetear el hardware a un estado "
"consistente. Esto incluye parar cualquier transferencia en curso, "
"deshabilitar los canales DMA y las interrupciones para evitar corrupciones "
"de memoria por parte del dispositivo. Para la mayoría de los controladores "
"esto es exactamente lo que hace la rutina de parada, de forma que si se "
"incluye en el controlador simplemente podemos llamarla."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1079
msgid "`xxx_isa_shutdown(dev);`"
msgstr "`xxx_isa_shutdown(dev);`"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1081
msgid "And finally release all the resources and return success."
msgstr "Y finalmente libera todos los recursos y devuelve éxito."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1089
#, no-wrap
msgid "xxx_isa_shutdown"
msgstr "xxx_isa_shutdown"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1092
msgid ""
"This routine is called when the system is about to be shut down. It is "
"expected to bring the hardware to some consistent state. For most of the ISA "
"devices no special action is required, so the function is not really "
"necessary because the device will be re-initialized on reboot anyway. But "
"some devices have to be shut down with a special procedure, to make sure "
"that they will be properly detected after soft reboot (this is especially "
"true for many devices with proprietary identification protocols). In any "
"case disabling DMA and interrupts in the device registers and stopping any "
"ongoing transfers is a good idea. The exact action depends on the hardware, "
"so we do not consider it here in any detail."
msgstr ""
"Esta rutina se llama cuando el sistema está a punto de apagarse. Se espera "
"que lleve el hardware a un estado consistente. Para la mayoría de los "
"dispositivos ISA no se requiere ninguna acción especial, así que la función "
"no es realmente necesaria ya que el dispositivo se reinicializará al "
"reiniciar de todas formas. Pero algunos dispositivos tienen que apagarse con "
"un procedimiento especial, para asegurarse de que serán detectados después "
"de un reinicio suave (esto es especialmente cierto para muchos dispositivos "
"con protocolos de identificación propietarios). En cualquier caso desactivar "
"DMA y las interrupciones en los registros del dispositivo y parar las "
"transferencias en curso es una buena idea. La acción exacta depende del "
"hardware, así que no la consideramos aquí con detalle."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1094
#, no-wrap
msgid "xxx_intr"
msgstr "xxx_intr"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1097
msgid ""
"The interrupt handler is called when an interrupt is received which may be "
"from this particular device. The ISA bus does not support interrupt sharing "
"(except in some special cases) so in practice if the interrupt handler is "
"called then the interrupt almost for sure came from its device. Still, the "
"interrupt handler must poll the device registers and make sure that the "
"interrupt was generated by its device. If not it should just return."
msgstr ""
"El manejador de interrupción se llama cuando se recibe una interrupción que "
"podría ser de este dispositivo particular. El bus ISA no tiene soporte para "
"compartir interrupciones (excepto en algunos casos especiales) así que en la "
"práctica el manejador de interrupción se llama cuando la interrupción casi "
"seguro que proviene de este dispositivo. Aún así, el manejador de "
"interrupción debe sondear los registros del dispositivo y asegurarse que la "
"interrupción vino de él. Si no es así simplemente debe retornar."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1099
msgid ""
"The old convention for the ISA drivers was getting the device unit number as "
"an argument. This is obsolete, and the new drivers receive whatever argument "
"was specified for them in the attach routine when calling "
"`bus_setup_intr()`. By the new convention it should be the pointer to the "
"structure softc. So the interrupt handler commonly starts as:"
msgstr ""
"La antigua convención para los controladores ISA era obtener el número de "
"unidad del dispositivo como un argumento. Esto está obsoleto, y los nuevos "
"controladores reciben cualquier argumento que se haya especificado en la "
"rutina de adjuntar cuando se llama a `bus_setup_intr()`. Según la nueva "
"convención debería ser un puntero a la estructura softc. De forma que el "
"manejador de interrupción normalmente comienza así:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1106
#, no-wrap
msgid ""
"          static void\n"
"          xxx_intr(struct xxx_softc *sc)\n"
"          {\n"
msgstr ""
"          static void\n"
"          xxx_intr(struct xxx_softc *sc)\n"
"          {\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1109
msgid ""
"It runs at the interrupt priority level specified by the interrupt type "
"parameter of `bus_setup_intr()`. That means that all the other interrupts of "
"the same type as well as all the software interrupts are disabled."
msgstr ""
"Se ejecuta en el nivel de prioridad de la interrupción especificado por el "
"parámetro tipo de interrupción de `bus_setup_intr()`. Eso significa que las "
"demás interrupciones del mismo tipo así como las interrupciones software "
"están deshabilitadas."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1111
msgid "To avoid races it is commonly written as a loop:"
msgstr "Pare evitar carreras se suele escribir como un bucle:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1119
#, no-wrap
msgid ""
"          while(xxx_interrupt_pending(sc)) {\n"
"              xxx_process_interrupt(sc);\n"
"              xxx_acknowledge_interrupt(sc);\n"
"          }\n"
msgstr ""
"          while(xxx_interrupt_pending(sc)) {\n"
"              xxx_process_interrupt(sc);\n"
"              xxx_acknowledge_interrupt(sc);\n"
"          }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/isa/_index.adoc:1121
msgid ""
"The interrupt handler has to acknowledge interrupt to the device only but "
"not to the interrupt controller, the system takes care of the latter."
msgstr ""
"El manejador de interrupción tiene que reconocer la interrupción ante el "
"dispositivo pero no ante el controlador, el sistema se encarga de esto "
"último."

#~ msgid ""
#~ "include::shared/attributes/attributes-{{% lang %}}.adoc[] include::shared/"
#~ "{{% lang %}}/teams.adoc[] include::shared/{{% lang %}}/mailing-lists."
#~ "adoc[] include::shared/{{% lang %}}/urls.adoc[]"
#~ msgstr ""
#~ "include::shared/attributes/attributes-{{% lang %}}.adoc[]\n"
#~ "include::shared/{{% lang %}}/teams.adoc[]\n"
#~ "include::shared/{{% lang %}}/mailing-lists.adoc[]\n"
#~ "include::shared/{{% lang %}}/urls.adoc[]"
