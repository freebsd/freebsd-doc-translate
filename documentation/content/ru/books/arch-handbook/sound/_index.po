# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Vladlen Popolitov <vladlenpopolitov@list.ru>, 2025.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2025-05-01 19:56-0300\n"
"PO-Revision-Date: 2025-07-12 04:45+0000\n"
"Last-Translator: Vladlen Popolitov <vladlenpopolitov@list.ru>\n"
"Language-Team: Russian <https://translate-dev.freebsd.org/projects/"
"documentation/booksarch-handbooksound_index/ru/>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
"X-Generator: Weblate 4.17\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:1
#, no-wrap
msgid "FreeBSD Sound Subsystem"
msgstr "Звуковая подсистема FreeBSD"

#. type: YAML Front Matter: title
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:1
#, no-wrap
msgid "Chapter 15. Sound Subsystem"
msgstr "Глава 15. Звуковая подсистема"

#. type: Title =
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:14
#, no-wrap
msgid "Sound Subsystem"
msgstr "Звуковая подсистема"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:52
#, no-wrap
msgid "Introduction"
msgstr "Введение"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:55
msgid ""
"The FreeBSD sound subsystem cleanly separates generic sound handling issues "
"from device-specific ones. This makes it easier to add support for new "
"hardware."
msgstr ""
"Подсистема звука FreeBSD чётко разделяет общие вопросы обработки звука и "
"детали, специфичные для устройств. Это упрощает добавление поддержки нового "
"оборудования."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:57
msgid ""
"The man:pcm[4] framework is the central piece of the sound subsystem. It "
"mainly implements the following elements:"
msgstr ""
"man:pcm[4] — это центральный компонент подсистемы звука. В основном он "
"реализует следующие элементы:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:59
msgid ""
"A system call interface (read, write, ioctls) to digitized sound and mixer "
"functions. The ioctl command set is compatible with the legacy _OSS_ or "
"_Voxware_ interface, allowing common multimedia applications to be ported "
"without modification."
msgstr ""
"Интерфейс системных вызовов (read, write, ioctls) для работы с оцифрованным "
"звуком и функциями микшера. Набор команд ioctl совместим с устаревшим "
"интерфейсом _OSS_ или _Voxware_, что позволяет портировать распространённые "
"мультимедийные приложения без изменений."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:60
msgid ""
"Common code for processing sound data (format conversions, virtual channels)."
msgstr ""
"Общий код для обработки звуковых данных (преобразование форматов, "
"виртуальные каналы)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:61
msgid ""
"A uniform software interface to hardware-specific audio interface modules."
msgstr ""
"Единый программный интерфейс к аппаратно-зависимым модулям аудиоинтерфейсов."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:62
msgid ""
"Additional support for some common hardware interfaces (ac97), or shared "
"hardware-specific code (ex: ISA DMA routines)."
msgstr ""
"Дополнительная поддержка некоторых распространённых аппаратных интерфейсов "
"(ac97) или общий код для специфичного оборудования (например: подпрограммы "
"ISA DMA)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:64
msgid ""
"The support for specific sound cards is implemented by hardware-specific "
"drivers, which provide channel and mixer interfaces to plug into the generic "
"[.filename]#pcm# code."
msgstr ""
"Поддержка конкретных звуковых карт реализована аппаратно-специфичными "
"драйверами, которые предоставляют интерфейсы каналов и микшера для "
"подключения к общему коду [.filename]#pcm#."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:66
msgid ""
"In this chapter, the term [.filename]#pcm# will refer to the central, common "
"part of the sound driver, as opposed to the hardware-specific modules."
msgstr ""
"В этой главе термин [.filename]#pcm# будет относиться к центральной, общей "
"части звукового драйвера, в отличие от аппаратно-зависимых модулей."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:68
msgid ""
"The prospective driver writer will of course want to start from an existing "
"module and use the code as the ultimate reference. But, while the sound code "
"is nice and clean, it is also mostly devoid of comments. This document tries "
"to give an overview of the framework interface and answer some questions "
"that may arise while adapting the existing code."
msgstr ""
"Разработчик драйверов, только начинающий свою разработку, конечно, захочет "
"начать с существующего модуля и использовать его код в качестве основного "
"источника информации. Однако, хотя код подсистемы звука чист и аккуратен, он "
"в основном лишён комментариев. Этот документ пытается дать обзор интерфейса "
"фреймворка и ответить на некоторые вопросы, которые могут возникнуть при "
"адаптации существующего кода."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:70
msgid ""
"As an alternative, or in addition to starting from a working example, you "
"can find a commented driver template at https://people.FreeBSD.org/~cg/"
"template.c[ https://people.FreeBSD.org/~cg/template.c]"
msgstr ""
"В качестве альтернативы или в дополнение к началу разработки с примера "
"драйвера из кода системы, вы можете найти шаблон драйвера с комментариями по "
"адресу https://people.FreeBSD.org/~cg/template.c[ https://people.FreeBSD.org/"
"~cg/template.c]"

#. type: Title ==
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:72
#, no-wrap
msgid "Files"
msgstr "Файлы"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:75
msgid ""
"All the relevant code lives in [.filename]#/usr/src/sys/dev/sound/#, except "
"for the public ioctl interface definitions, found in [.filename]#/usr/src/"
"sys/sys/soundcard.h#"
msgstr ""
"Весь соответствующий код находится в [.filename]#/usr/src/sys/dev/sound/#, "
"за исключением определений публичного интерфейса ioctl, которые можно найти "
"в [.filename]#/usr/src/sys/sys/soundcard.h#"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:77
msgid ""
"Under [.filename]#/usr/src/sys/dev/sound/#, the [.filename]#pcm/# directory "
"holds the central code, while the [.filename]#pci/#, [.filename]#isa/# and "
"[.filename]#usb/# directories have the drivers for PCI and ISA boards, and "
"for USB audio devices."
msgstr ""
"В каталоге [.filename]#/usr/src/sys/dev/sound/#, папка [.filename]#pcm/# "
"содержит основной код, тогда как каталоги [.filename]#pci/#, [.filename]#isa/"
"# и [.filename]#usb/# содержат драйверы для плат PCI и ISA, а также для "
"USB-аудиоустройств."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:79
#, no-wrap
msgid "Probing, Attaching, etc."
msgstr "Обнаружение, присоединение и т.д."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:82
msgid ""
"Sound drivers probe and attach in almost the same way as any hardware driver "
"module. You might want to look at the crossref:isa-driver[isa-driver,ISA] or "
"crossref:pci[pci,PCI] specific sections of the handbook for more information."
msgstr ""
"Драйверы звуковых устройств выполняют обнаружение и подключение почти так "
"же, как и любой модуль драйвера оборудования. Возможно, вам будет полезно "
"ознакомиться с разделами руководства, посвящёнными crossref:isa-driver[isa-"
"driver,ISA] или crossref:pci[pci,PCI], для получения дополнительной "
"информации."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:84
msgid "However, sound drivers differ in some ways:"
msgstr "Однако драйверы звука отличаются в некоторых аспектах:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:86
msgid ""
"They declare themselves as [.filename]#pcm# class devices, with a `struct "
"snddev_info` device private structure:"
msgstr ""
"Они объявляют себя как устройства класса [.filename]#pcm#, с приватной "
"структурой устройства `struct snddev_info`:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:94
#, no-wrap
msgid ""
"          static driver_t xxx_driver = {\n"
"              \"pcm\",\n"
"              xxx_methods,\n"
"              sizeof(struct snddev_info)\n"
"          };\n"
msgstr ""
"          static driver_t xxx_driver = {\n"
"              \"pcm\",\n"
"              xxx_methods,\n"
"              sizeof(struct snddev_info)\n"
"          };\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:97
#, no-wrap
msgid ""
"          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);\n"
"          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, PCM_PREFVER,PCM_MAXVER);\n"
msgstr ""
"          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);\n"
"          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, "
"PCM_PREFVER,PCM_MAXVER);\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:100
msgid ""
"Most sound drivers need to store additional private information about their "
"device. A private data structure is usually allocated in the attach routine. "
"Its address is passed to [.filename]#pcm# by the calls to `pcm_register()` "
"and `mixer_init()`. [.filename]#pcm# later passes back this address as a "
"parameter in calls to the sound driver interfaces."
msgstr ""
"Большинству звуковых драйверов необходимо хранить дополнительную приватную "
"информацию о своём устройстве. Приватная структура данных обычно выделяется "
"в процедуре attach. Её адрес передаётся в [.filename]#pcm# через вызовы "
"`pcm_register()` и `mixer_init()`. [.filename]#pcm# позже передаёт обратно "
"этот адрес в качестве параметра при вызовах интерфейсов звукового драйвера."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:103
msgid ""
"The sound driver attach routine should declare its MIXER or AC97 interface "
"to [.filename]#pcm# by calling `mixer_init()`. For a MIXER interface, this "
"causes in turn a call to crossref:sound[xxxmixer-init,`xxxmixer_init()`]."
msgstr ""
"Подпрограмма подключения звукового драйвера должна объявить свой интерфейс "
"MIXER или AC97 для [.filename]#pcm#, вызвав `mixer_init()`. Для интерфейса "
"MIXER это, в свою очередь, приводит к вызову crossref:sound[xxxmixer-"
"init,`xxxmixer_init()`]."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:104
msgid ""
"The sound driver attach routine declares its general CHANNEL configuration "
"to [.filename]#pcm# by calling `pcm_register(dev, sc, nplay, nrec)`, where "
"`sc` is the address for the device data structure, used in further calls "
"from [.filename]#pcm#, and `nplay` and `nrec` are the number of play and "
"record channels."
msgstr ""
"Функция подключения драйвера звука объявляет свою общую конфигурацию CHANNEL "
"для [.filename]#pcm#, вызывая `pcm_register(dev, sc, nplay, nrec)`, где `sc` "
"— это адрес структуры данных устройства, используемый при последующих "
"вызовах из [.filename]#pcm#, а `nplay` и `nrec` — количество каналов "
"воспроизведения и записи."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:107
msgid ""
"The sound driver attach routine declares each of its channel objects by "
"calls to `pcm_addchan()`. This sets up the channel glue in [.filename]#pcm# "
"and causes in turn a call to crossref:sound[xxxchannel-"
"init,`xxxchannel_init()`]."
msgstr ""
"Подпрограмма подключения звукового драйвера объявляет каждый из своих "
"каналов вызовами `pcm_addchan()`. Это настраивает связующий слой канала в [."
"filename]#pcm# и, в свою очередь, вызывает вызов crossref:sound[xxxchannel-"
"init,`xxxchannel_init()`]."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:108
msgid ""
"The sound driver detach routine should call `pcm_unregister()` before "
"releasing its resources."
msgstr ""
"Драйвер звука должен вызвать `pcm_unregister()` в процедуре отключения перед "
"освобождением своих ресурсов."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:110
msgid "There are two possible methods to handle non-PnP devices:"
msgstr ""
"Существует два возможных способа работы с устройствами, не поддерживающими "
"PnP:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:112
msgid ""
"Use a `device_identify()` method (example: [.filename]#sound/isa/es1888.c#). "
"The `device_identify()` method probes for the hardware at known addresses "
"and, if it finds a supported device, creates a new pcm device which is then "
"passed to probe/attach."
msgstr ""
"Используйте метод `device_identify()` (пример: [.filename]#sound/isa/es1888."
"c#). Метод `device_identify()` проверяет наличие оборудования по известным "
"адресам и, если находит поддерживаемое устройство, создает новое pcm-"
"устройство, которое затем передается для probe/attach."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:113
msgid ""
"Use a custom kernel configuration with appropriate hints for pcm devices "
"(example: [.filename]#sound/isa/mss.c#)."
msgstr ""
"Используйте пользовательскую конфигурацию ядра с соответствующими "
"подсказками для устройств pcm (пример: [.filename]#sound/isa/mss.c#)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:115
msgid ""
"[.filename]#pcm# drivers should implement `device_suspend`, `device_resume` "
"and `device_shutdown` routines, so that power management and module "
"unloading function correctly."
msgstr ""
"[.filename]#pcm# драйверы должны реализовывать подпрограммы `device_suspend`"
", `device_resume` и `device_shutdown`, чтобы управление питанием и выгрузка "
"модулей работали корректно."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:117
#, no-wrap
msgid "Interfaces"
msgstr "Interfaces"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:121
msgid ""
"The interface between the [.filename]#pcm# core and the sound drivers is "
"defined in terms of crossref:kobj[kernel-objects,kernel objects]."
msgstr ""
"Интерфейс между ядром [.filename]#pcm# и звуковыми драйверами определяется в "
"терминах crossref:kobj[kernel-objects,объектов ядра Kobj]."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:123
msgid ""
"There are two main interfaces that a sound driver will usually provide: "
"_CHANNEL_ and either _MIXER_ or _AC97_."
msgstr ""
"Существует два основных интерфейса, которые обычно предоставляет драйвер "
"звука: _CHANNEL_ и либо _MIXER_, либо _AC97_."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:125
msgid ""
"The _AC97_ interface is a very small hardware access (register read/write) "
"interface, implemented by drivers for hardware with an AC97 codec. In this "
"case, the actual MIXER interface is provided by the shared AC97 code in "
"[.filename]#pcm#."
msgstr ""
"Интерфейс _AC97_ — это очень небольшой интерфейс доступа к оборудованию "
"(чтение/запись регистров), реализованный драйверами для устройств с кодеком "
"AC97. В этом случае фактический интерфейс MIXER предоставляется общим кодом "
"AC97 в [.filename]#pcm#."

#. type: Title ===
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:126
#, no-wrap
msgid "The CHANNEL Interface"
msgstr "Интерфейс CHANNEL"

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:128
#, no-wrap
msgid "Common Notes for Function Parameters"
msgstr "Общие примечания для параметров функций"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:131
msgid ""
"Sound drivers usually have a private data structure to describe their "
"device, and one structure for each play and record data channel that it "
"supports."
msgstr ""
"Драйверы звука обычно имеют приватную структуру данных для описания своего "
"устройства и по одной структуре для каждого канала воспроизведения и записи, "
"который они поддерживают."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:133
msgid ""
"For all CHANNEL interface functions, the first parameter is an opaque "
"pointer."
msgstr ""
"Для всех функций интерфейса CHANNEL первый параметр — это непрозрачный "
"указатель."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:135
msgid ""
"The second parameter is a pointer to the private channel data structure, "
"except for `channel_init()` which has a pointer to the private device "
"structure (and returns the channel pointer for further use by "
"[.filename]#pcm#)."
msgstr ""
"Второй параметр представляет собой указатель на приватную структуру данных "
"канала, за исключением `channel_init()`, где передается указатель на "
"приватную структуру устройства (и возвращается указатель на канал для "
"дальнейшего использования [.filename]#pcm#)."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:136
#, no-wrap
msgid "Overview of Data Transfer Operations"
msgstr "Обзор операций передачи данных"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:139
msgid ""
"For sound data transfers, the [.filename]#pcm# core and the sound drivers "
"communicate through a shared memory area, described by a `struct snd_dbuf`."
msgstr ""
"Для надежной передачи звуковых данных ядро [.filename]#pcm# и драйверы звука "
"взаимодействуют через общую область памяти, описываемую структурой `struct "
"snd_dbuf`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:141
msgid ""
"`struct snd_dbuf` is private to [.filename]#pcm#, and sound drivers obtain "
"values of interest by calls to accessor functions (`sndbuf_getxxx()`)."
msgstr ""
"`struct snd_dbuf` является приватной для [.filename]#pcm#, и драйверы звука "
"получают нужные значения через вызовы функций доступа (`sndbuf_getxxx()`)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:143
msgid ""
"The shared memory area has a size of `sndbuf_getsize()` and is divided into "
"fixed size blocks of `sndbuf_getblksz()` bytes."
msgstr ""
"Область разделяемой памяти имеет размер `sndbuf_getsize()` и разделена на "
"блоки фиксированного размера по `sndbuf_getblksz()` байт."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:145
msgid ""
"When playing, the general transfer mechanism is as follows (reverse the idea "
"for recording):"
msgstr ""
"При воспроизведении общий механизм передачи выглядит следующим образом (для "
"записи идея обратная):"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:148
msgid ""
"[.filename]#pcm# initially fills up the buffer, then calls the sound "
"driver's crossref:sound[channel-trigger,`xxxchannel_trigger()`] function "
"with a parameter of PCMTRIG_START."
msgstr ""
"[.filename]#pcm# сначала заполняет буфер, затем вызывает функцию "
"crossref:sound[channel-trigger,`xxxchannel_trigger()`] драйвера звука с "
"параметром PCMTRIG_START."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:149
msgid ""
"The sound driver then arranges to repeatedly transfer the whole memory area "
"(`sndbuf_getbuf()`, `sndbuf_getsize()`) to the device, in blocks of "
"`sndbuf_getblksz()` bytes. It calls back the `chn_intr()`[.filename]#pcm# "
"function for each transferred block (this will typically happen at interrupt "
"time)."
msgstr ""
"Звуковой драйвер затем организует повторяющуюся передачу всей области памяти "
"(`sndbuf_getbuf()`, `sndbuf_getsize()`) на устройство блоками по "
"`sndbuf_getblksz()` байт. Для каждого переданного блока он вызывает функцию "
"`chn_intr()`[.filename]#pcm# (обычно это происходит во время прерывания)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:150
msgid ""
"`chn_intr()` arranges to copy new data to the area that was transferred to "
"the device (now free), and make appropriate updates to the `snd_dbuf` "
"structure."
msgstr ""
"`chn_intr()` организует копирование новых данных в область, которая была "
"передана устройству (теперь свободна), и вносит соответствующие обновления в "
"структуру `snd_dbuf`."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:152
#, no-wrap
msgid "channel_init"
msgstr "channel_init"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:156
msgid ""
"`xxxchannel_init()` is called to initialize each of the play or record "
"channels.  The calls are initiated from the sound driver attach routine. "
"(See the crossref:sound[pcm-probe-and-attach,probe and attach section)."
msgstr ""
"`xxxchannel_init()` вызывается для инициализации каждого из каналов "
"воспроизведения или записи. Вызовы инициируются из процедуры присоединения "
"драйвера звука. (См. раздел crossref:sound[pcm-probe-and-attach,зондирование "
"и присоединение])."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:168
#, no-wrap
msgid ""
"          static void *\n"
"          xxxchannel_init(kobj_t obj, void *data,\n"
"             struct snd_dbuf *b, struct pcm_channel *c, int dir) <.>\n"
"          {\n"
"              struct xxx_info *sc = data;\n"
"              struct xxx_chinfo *ch;\n"
"               ...\n"
"              return ch; <.>\n"
"           }\n"
msgstr ""
"          static void *\n"
"          xxxchannel_init(kobj_t obj, void *data,\n"
"             struct snd_dbuf *b, struct pcm_channel *c, int dir) <.>\n"
"          {\n"
"              struct xxx_info *sc = data;\n"
"              struct xxx_chinfo *ch;\n"
"               ...\n"
"              return ch; <.>\n"
"           }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:171
msgid ""
"`b` is the address for the channel `struct snd_dbuf`. It should be "
"initialized in the function by calling `sndbuf_alloc()`. The buffer size to "
"use is normally a small multiple of the 'typical' unit transfer size for "
"your device.`c` is the [.filename]#pcm# channel control structure pointer. "
"This is an opaque object. The function should store it in the local channel "
"structure, to be used in later calls to [.filename]#pcm# (ie: "
"`chn_intr(c)`).`dir` indicates the channel direction (`PCMDIR_PLAY` or "
"`PCMDIR_REC`)."
msgstr ""
"`b` — это адрес для канала `struct snd_dbuf`. Он должен быть инициализирован "
"в функции вызовом `sndbuf_alloc()`. Размер буфера, который следует "
"использовать, обычно представляет собой небольшое кратное от 'типичного' "
"размера единицы передачи данных для вашего устройства. `c` — это указатель "
"на структуру управления каналом [.filename]#pcm#. Это непрозрачный объект. "
"Функция должна сохранить его в локальной структуре канала для использования "
"в последующих вызовах [.filename]#pcm# (например: `chn_intr(c)`). `dir` "
"указывает направление канала (`PCMDIR_PLAY` или `PCMDIR_REC`)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:173
msgid ""
"The function should return a pointer to the private area used to control "
"this channel. This will be passed as a parameter to other channel interface "
"calls."
msgstr ""
"Функция должна возвращать указатель на приватную область, используемую для "
"управления этим каналом. Этот указатель будет передаваться в качестве "
"параметра при других вызовах интерфейса канала."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:174
#, no-wrap
msgid "channel_setformat"
msgstr "channel_setformat"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:177
msgid ""
"`xxxchannel_setformat()` should set up the hardware for the specified "
"channel for the specified sound format."
msgstr ""
"`xxxchannel_setformat()` должен настроить оборудование для указанного канала "
"под указанный звуковой формат."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:187
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format) <.>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }\n"
msgstr ""
"          static int\n"
"          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format) <.>"
"\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:190
msgid ""
"`format` is specified as an `AFMT_XXX value` ([.filename]#soundcard.h#)."
msgstr ""
"`format` указывается как значение `AFMT_XXX` ([.filename]#soundcard.h#)."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:191
#, no-wrap
msgid "channel_setspeed"
msgstr "channel_setspeed"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:194
msgid ""
"`xxxchannel_setspeed()` sets up the channel hardware for the specified "
"sampling speed, and returns the possibly adjusted speed."
msgstr ""
"`xxxchannel_setspeed()` настраивает оборудование канала для указанной "
"скорости дискретизации и возвращает возможно скорректированную скорость."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:204
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return speed;\n"
"           }\n"
msgstr ""
"          static int\n"
"          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return speed;\n"
"           }\n"

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:206
#, no-wrap
msgid "channel_setblocksize"
msgstr "channel_setblocksize"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:209
msgid ""
"`xxxchannel_setblocksize()` sets the block size, which is the size of unit "
"transactions between [.filename]#pcm# and the sound driver, and between the "
"sound driver and the device. Typically, this would be the number of bytes "
"transferred before an interrupt occurs. During a transfer, the sound driver "
"should call [.filename]#pcm#'s `chn_intr()` every time this size has been "
"transferred."
msgstr ""
"`xxxchannel_setblocksize()` устанавливает размер блока, который является "
"размером единичных транзакций между [.filename]#pcm# и звуковым драйвером, а "
"также между звуковым драйвером и устройством. Обычно это количество байт, "
"передаваемых до возникновения прерывания. Во время передачи звуковой драйвер "
"должен вызывать `chn_intr()` из [.filename]#pcm# каждый раз, когда "
"передается данный размер."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:211
msgid ""
"Most sound drivers only take note of the block size here, to be used when an "
"actual transfer will be started."
msgstr ""
"Большинство драйверов звука здесь учитывают только размер блока, который "
"будет использоваться при начале фактической передачи."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:221
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t blocksize)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"                ...\n"
"              return blocksize; <.>\n"
"           }\n"
msgstr ""
"          static int\n"
"          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t "
"blocksize)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"                ...\n"
"              return blocksize; <.>\n"
"           }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:224
msgid ""
"The function returns the possibly adjusted block size. In case the block "
"size is indeed changed, `sndbuf_resize()` should be called to adjust the "
"buffer."
msgstr ""
"Функция возвращает, возможно, скорректированный размер блока. Если размер "
"блока действительно изменён, следует вызвать `sndbuf_resize()` для "
"корректировки буфера."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:226
#, no-wrap
msgid "channel_trigger"
msgstr "channel_trigger"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:229
msgid ""
"`xxxchannel_trigger()` is called by [.filename]#pcm# to control data "
"transfer operations in the driver."
msgstr ""
"`xxxchannel_trigger()` вызывается [.filename]#pcm# для управления операциями "
"передачи данных в драйвере."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:239
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_trigger(kobj_t obj, void *data, int go) <.>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }\n"
msgstr ""
"          static int\n"
"          xxxchannel_trigger(kobj_t obj, void *data, int go) <.>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:242
msgid "`go` defines the action for the current call. The possible values are:"
msgstr "`go` определяет действие для текущего вызова. Возможные значения:"

#. type: delimited block = 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:246
msgid ""
"If the driver uses ISA DMA, `sndbuf_isadma()` should be called before "
"performing actions on the device, and will take care of the DMA chip side of "
"things."
msgstr ""
"Если драйвер использует ISA DMA, перед выполнением действий с устройством "
"следует вызвать `sndbuf_isadma()`, которая позаботится о том, что делает "
"DMA-чип."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:248
#, no-wrap
msgid "channel_getptr"
msgstr "channel_getptr"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:251
msgid ""
"`xxxchannel_getptr()` returns the current offset in the transfer buffer. "
"This will typically be called by `chn_intr()`, and this is how "
"[.filename]#pcm# knows where it can transfer new data."
msgstr ""
"`xxxchannel_getptr()` возвращает текущее смещение в буфере передачи. Обычно "
"этот вызов выполняется функцией `chn_intr()`, и именно так [.filename]#pcm# "
"узнаёт, куда можно передавать новые данные."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:252
#, no-wrap
msgid "channel_free"
msgstr "channel_free"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:255
msgid ""
"`xxxchannel_free()` is called to free up channel resources, for example when "
"the driver is unloaded, and should be implemented if the channel data "
"structures are dynamically allocated or if `sndbuf_alloc()` was not used for "
"buffer allocation."
msgstr ""
"`xxxchannel_free()` вызывается для освобождения ресурсов канала, например, "
"при выгрузке драйвера, и должна быть реализована, если структуры данных "
"канала динамически выделены или если `sndbuf_alloc()` не использовалась для "
"выделения буфера."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:256
#, no-wrap
msgid "channel_getcaps"
msgstr "channel_getcaps"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:265
#, no-wrap
msgid ""
"          struct pcmchan_caps *\n"
"          xxxchannel_getcaps(kobj_t obj, void *data)\n"
"          {\n"
"              return &xxx_caps; <.>\n"
"           }\n"
msgstr ""
"          struct pcmchan_caps *\n"
"          xxxchannel_getcaps(kobj_t obj, void *data)\n"
"          {\n"
"              return &xxx_caps; <.>\n"
"           }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:268
msgid ""
"The routine returns a pointer to a (usually statically-defined) "
"`pcmchan_caps` structure (defined in [.filename]#sound/pcm/channel.h#. The "
"structure holds the minimum and maximum sampling frequencies, and the "
"accepted sound formats. Look at any sound driver for an example."
msgstr ""
"Подпрограмма возвращает указатель на (обычно статически определённую) "
"структуру `pcmchan_caps` (определена в [.filename]#sound/pcm/channel.h#). "
"Эта структура содержит минимальную и максимальную частоты дискретизации, а "
"также поддерживаемые звуковые форматы. Пример можно найти в любом драйвере "
"звукового устройства."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:269
#, no-wrap
msgid "More Functions"
msgstr "Дополнительные Функции"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:272
msgid ""
"`channel_reset()`, `channel_resetdone()`, and `channel_notify()` are for "
"special purposes and should not be implemented in a driver without "
"discussing it on the {freebsd-multimedia}."
msgstr ""
"`channel_reset()`, `channel_resetdone()` и `channel_notify()` предназначены "
"для специальных целей и не должны реализовываться в драйвере без обсуждения "
"на {freebsd-multimedia}."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:274
msgid "`channel_setdir()` is deprecated."
msgstr "`channel_setdir()` устарела."

#. type: Title ===
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:275
#, no-wrap
msgid "The MIXER Interface"
msgstr "Интерфейс MIXER"

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:278
#, no-wrap
msgid "mixer_init"
msgstr "mixer_init"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:281
msgid ""
"`xxxmixer_init()` initializes the hardware and tells [.filename]#pcm# what "
"mixer devices are available for playing and recording"
msgstr ""
"`xxxmixer_init()` инициализирует оборудование и сообщает [.filename]#pcm#, "
"какие устройства микшера доступны для воспроизведения и записи"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:289
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_init(struct snd_mixer *m)\n"
"          {\n"
"              struct xxx_info   *sc = mix_getdevinfo(m);\n"
"              u_int32_t v;\n"
msgstr ""
"          static int\n"
"          xxxmixer_init(struct snd_mixer *m)\n"
"          {\n"
"              struct xxx_info   *sc = mix_getdevinfo(m);\n"
"              u_int32_t v;\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:291
#, no-wrap
msgid "              [Initialize hardware]\n"
msgstr "              [Initialize hardware]\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:296
#, no-wrap
msgid ""
"              [Set appropriate bits in v for play mixers] <.>\n"
"              mix_setdevs(m, v);\n"
"              [Set appropriate bits in v for record mixers]\n"
"              mix_setrecdevs(m, v)\n"
msgstr ""
"              [Set appropriate bits in v for play mixers] <.>\n"
"              mix_setdevs(m, v);\n"
"              [Set appropriate bits in v for record mixers]\n"
"              mix_setrecdevs(m, v)\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:299
#, no-wrap
msgid ""
"              return 0;\n"
"          }\n"
msgstr ""
"              return 0;\n"
"          }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:302
msgid ""
"Set bits in an integer value and call `mix_setdevs()` and `mix_setrecdevs()` "
"to tell [.filename]#pcm# what devices exist."
msgstr ""
"Установите биты в целочисленном значении и вызовите `mix_setdevs()` и "
"`mix_setrecdevs()`, чтобы сообщить [.filename]#pcm#, какие устройства "
"существуют."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:304
msgid ""
"Mixer bits definitions can be found in [.filename]#soundcard.h# "
"(`SOUND_MASK_XXX` values and `SOUND_MIXER_XXX` bit shifts)."
msgstr ""
"Определения битов микшера можно найти в [.filename]#soundcard.h# (значения "
"`SOUND_MASK_XXX` и сдвиги битов `SOUND_MIXER_XXX`)."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:305
#, no-wrap
msgid "mixer_set"
msgstr "mixer_set"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:308
msgid "`xxxmixer_set()` sets the volume level for one mixer device."
msgstr ""
"`xxxmixer_set()` устанавливает уровень громкости для одного устройства "
"микшера."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:319
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_set(struct snd_mixer *m, unsigned dev,\n"
"                           unsigned left, unsigned right) <.>\n"
"          {\n"
"              struct sc_info *sc = mix_getdevinfo(m);\n"
"              [set volume level]\n"
"              return left | (right << 8); <.>\n"
"          }\n"
msgstr ""
"          static int\n"
"          xxxmixer_set(struct snd_mixer *m, unsigned dev,\n"
"                           unsigned left, unsigned right) <.>\n"
"          {\n"
"              struct sc_info *sc = mix_getdevinfo(m);\n"
"              [set volume level]\n"
"              return left | (right << 8); <.>\n"
"          }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:322
msgid ""
"The device is specified as a `SOUND_MIXER_XXX` value. The volume values are "
"specified in range [0-100]. A value of zero should mute the device."
msgstr ""
"Устройство указывается как значение `SOUND_MIXER_XXX`. Значения громкости "
"задаются в диапазоне [0-100]. Значение ноль должно отключать звук устройства."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:323
msgid ""
"As the hardware levels probably will not match the input scale, and some "
"rounding will occur, the routine returns the actual level values (in range "
"0-100) as shown."
msgstr ""
"Поскольку уровни оборудования, вероятно, не совпадут с входной шкалой и "
"будет происходить округление, процедура возвращает фактические значения "
"уровней (в диапазоне 0-100), как показано."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:324
#, no-wrap
msgid "mixer_setrecsrc"
msgstr "mixer_setrecsrc"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:327
msgid "`xxxmixer_setrecsrc()` sets the recording source device."
msgstr "`xxxmixer_setrecsrc()` устанавливает устройство источника записи."

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:334
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src) <.>\n"
"          {\n"
"              struct xxx_info *sc = mix_getdevinfo(m);\n"
msgstr ""
"          static int\n"
"          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src) <.>\n"
"          {\n"
"              struct xxx_info *sc = mix_getdevinfo(m);\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:336
#, no-wrap
msgid "              [look for non zero bit(s) in src, set up hardware]\n"
msgstr "              [look for non zero bit(s) in src, set up hardware]\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:340
#, no-wrap
msgid ""
"              [update src to reflect actual action]\n"
"              return src; <.>\n"
"           }\n"
msgstr ""
"              [update src to reflect actual action]\n"
"              return src; <.>\n"
"           }\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:343
msgid "The desired recording devices are specified as a bit field"
msgstr "Желаемые устройства записи указываются в виде битового поля"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:344
msgid ""
"The actual devices set for recording are returned. Some drivers can only set "
"one device for recording. The function should return -1 if an error occurs."
msgstr ""
"Возвращаются фактические устройства, настроенные для записи. Некоторые "
"драйверы могут настраивать только одно устройство для записи. Функция должна "
"возвращать -1 в случае ошибки."

#. type: Title ====
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:345
#, no-wrap
msgid "mixer_uninit, mixer_reinit"
msgstr "mixer_uninit, mixer_reinit"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:348
msgid ""
"`xxxmixer_uninit()` should ensure that all sound is muted and if possible "
"mixer hardware should be powered down."
msgstr ""
"`xxxmixer_uninit()` должен гарантировать, что весь звук отключен, и, если "
"возможно, аппаратный микшер должен быть переведен в режим пониженного "
"энергопотребления."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:350
msgid ""
"`xxxmixer_reinit()` should ensure that the mixer hardware is powered up and "
"any settings not controlled by `mixer_set()` or `mixer_setrecsrc()` are "
"restored."
msgstr ""
"`xxxmixer_reinit()` должна гарантировать, что аппаратура микшера включена и "
"все настройки, не управляемые `mixer_set()` или `mixer_setrecsrc()`, "
"восстановлены."

#. type: Title ===
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:351
#, no-wrap
msgid "The AC97 Interface"
msgstr "Интерфейс AC97"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:354
msgid ""
"The _AC97_ interface is implemented by drivers with an AC97 codec. It only "
"has three methods:"
msgstr ""
"Интерфейс _AC97_ реализован драйверами с кодеком AC97. У него есть только "
"три метода:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:356
msgid "`xxxac97_init()` returns the number of ac97 codecs found."
msgstr "`xxxac97_init()` возвращает количество найденных кодеков ac97."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:357
msgid "`ac97_read()` and `ac97_write()` read or write a specified register."
msgstr "`ac97_read()` и `ac97_write()` читают или записывают указанный регистр."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/sound/_index.adoc:358
msgid ""
"The _AC97_ interface is used by the AC97 code in [.filename]#pcm# to perform "
"higher level operations. Look at [.filename]#sound/pci/maestro3.c# or many "
"others under [.filename]#sound/pci/# for an example."
msgstr ""
"Интерфейс _AC97_ используется кодом AC97 в [.filename]#pcm# для выполнения "
"операций более высокого уровня. В качестве примера можно посмотреть [."
"filename]#sound/pci/maestro3.c# или другие файлы в [.filename]#sound/pci/#."
