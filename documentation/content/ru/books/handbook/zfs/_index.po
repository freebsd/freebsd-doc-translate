# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Vladlen Popolitov <vladlenpopolitov@list.ru>, 2025.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2025-06-29 21:20+0100\n"
"PO-Revision-Date: 2025-06-22 04:45+0000\n"
"Last-Translator: Vladlen Popolitov <vladlenpopolitov@list.ru>\n"
"Language-Team: Russian <https://translate-dev.freebsd.org/projects/"
"documentation/bookshandbookzfs_index/ru/>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
"X-Generator: Weblate 4.17\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/zfs/_index.adoc:1
#, no-wrap
msgid "ZFS is an advanced file system designed to solve major problems found in previous storage subsystem software"
msgstr "ZFS — это современная файловая система, разработанная для решения основных проблем, присущих предыдущему программному обеспечению подсистем хранения данных"

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/zfs/_index.adoc:1
#, no-wrap
msgid "Part III. System Administration"
msgstr "Часть III. Администрирование системы"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/zfs/_index.adoc:1
#, no-wrap
msgid "Chapter 22. The Z File System (ZFS)"
msgstr "Глава 22. Файловая система Z (ZFS)"

#. type: Title =
#: documentation/content/en/books/handbook/zfs/_index.adoc:15
#, no-wrap
msgid "The Z File System (ZFS)"
msgstr "Файловая система Z (ZFS)"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:53
msgid ""
"ZFS is an advanced file system designed to solve major problems found in "
"previous storage subsystem software."
msgstr ""
"ZFS — это продвинутая файловая система, разработанная для решения основных "
"проблем, присущих предыдущему программному обеспечению подсистем хранения "
"данных."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:55
msgid ""
"Originally developed at Sun(TM), ongoing open source ZFS development has "
"moved to the http://open-zfs.org[OpenZFS Project]."
msgstr ""
"Первоначально разработанная в Sun(TM), дальнейшая разработка открытой версии "
"ZFS переместилась в http://open-zfs.org[проект OpenZFS]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:57
msgid "ZFS has three major design goals:"
msgstr "ZFS имеет три основные цели проектирования:"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:59
msgid ""
"Data integrity: All data includes a crossref:zfs[zfs-term-checksum,checksum] "
"of the data. ZFS calculates checksums and writes them along with the data. "
"When reading that data later, ZFS recalculates the checksums. If the "
"checksums do not match, meaning detecting one or more data errors, ZFS will "
"attempt to automatically correct errors when ditto-, mirror-, or parity-"
"blocks are available."
msgstr ""
"Целостность данных: Все данные включают crossref:zfs[zfs-term-checksum,"
"контрольную сумму]. ZFS вычисляет контрольные суммы и записывает их вместе с "
"данными. При последующем чтении этих данных ZFS пересчитывает контрольные "
"суммы. Если контрольные суммы не совпадают, что означает обнаружение одной "
"или нескольких ошибок данных, ZFS попытается автоматически исправить ошибки, "
"если доступны двойные-, зеркальные- или блоки четности."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:60
msgid ""
"Pooled storage: adding physical storage devices to a pool, and allocating "
"storage space from that shared pool. Space is available to all file systems "
"and volumes, and increases by adding new storage devices to the pool."
msgstr ""
"Объединенное хранилище: добавление физических устройств хранения в пул и "
"выделение пространства из этого общего пула. Пространство доступно для всех "
"файловых систем и томов и увеличивается за счет добавления новых устройств "
"хранения в пул."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:65
msgid ""
"Performance: caching mechanisms provide increased performance.  crossref:"
"zfs[zfs-term-arc,ARC] is an advanced memory-based read cache. ZFS provides a "
"second level disk-based read cache with crossref:zfs[zfs-term-l2arc,L2ARC], "
"and a disk-based synchronous write cache named crossref:zfs[zfs-term-zil,"
"ZIL]."
msgstr ""
"Производительность: механизмы кэширования обеспечивают повышенную "
"производительность.  crossref:zfs[zfs-term-arc,ARC] — это продвинутый кэш "
"для чтения, основанный на оперативной памяти. ZFS предоставляет второй "
"уровень кэша для чтения на основе диска — crossref:zfs[zfs-term-l2arc,"
"L2ARC], а также кэш для синхронной записи на основе диска под названием "
"crossref:zfs[zfs-term-zil,ZIL]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:67
msgid ""
"A complete list of features and terminology is in crossref:zfs[zfs-term, ZFS "
"Features and Terminology]."
msgstr ""
"Полный список возможностей и терминологии приведен в crossref:zfs[zfs-term, "
"Особенности и терминология ZFS]."

#. type: Title ==
#: documentation/content/en/books/handbook/zfs/_index.adoc:69
#, no-wrap
msgid "What Makes ZFS Different"
msgstr "Что отличает ZFS от других"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:82
msgid ""
"More than a file system, ZFS is fundamentally different from traditional "
"file systems.  Combining the traditionally separate roles of volume manager "
"and file system provides ZFS with unique advantages.  The file system is now "
"aware of the underlying structure of the disks.  Traditional file systems "
"could exist on a single disk alone at a time.  If there were two disks then "
"creating two separate file systems was necessary.  A traditional hardware "
"RAID configuration avoided this problem by presenting the operating system "
"with a single logical disk made up of the space provided by physical disks "
"on top of which the operating system placed a file system.  Even with "
"software RAID solutions like those provided by GEOM, the UFS file system "
"living on top of the RAID believes it's dealing with a single device.  ZFS' "
"combination of the volume manager and the file system solves this and allows "
"the creation of file systems that all share a pool of available storage.  "
"One big advantage of ZFS' awareness of the physical disk layout is that "
"existing file systems grow automatically when adding extra disks to the "
"pool.  This new space then becomes available to the file systems.  ZFS can "
"also apply different properties to each file system. This makes it useful to "
"create separate file systems and datasets instead of a single monolithic "
"file system."
msgstr ""
"ZFS — это не просто файловая система, она принципиально отличается от "
"традиционных файловых систем. Объединение традиционно разделенных ролей "
"менеджера томов и файловой системы дает ZFS уникальные преимущества. Теперь "
"файловая система осведомлена о структуре нижележащих дисков. Традиционные "
"файловые системы могли существовать только на одном диске. Если было два "
"диска, приходилось создавать две отдельные файловые системы. Традиционная "
"конфигурация аппаратного RAID решала эту проблему, предоставляя операционной "
"системе один логический диск, состоящий из пространства физических дисков, "
"поверх которого операционная система размещала файловую систему. Даже в "
"программных решениях RAID, таких как предоставляемые GEOM, файловая система "
"UFS, находящаяся поверх RAID, считает, что работает с одним устройством. "
"Комбинация менеджера томов и файловой системы в ZFS решает эту проблему и "
"позволяет создавать файловые системы, которые совместно используют общий пул "
"доступного хранилища. Одно из больших преимуществ осведомленности ZFS о "
"физической структуре дисков заключается в том, что существующие файловые "
"системы автоматически расширяются при добавлении дополнительных дисков в "
"пул. Это новое пространство становится доступным для файловых систем. ZFS "
"также может применять разные свойства к каждой файловой системе. Это делает "
"полезным создание отдельных файловых систем и наборов данных вместо единой "
"монолитной файловой системы."

#. type: Title ==
#: documentation/content/en/books/handbook/zfs/_index.adoc:84
#, no-wrap
msgid "Quick Start Guide"
msgstr "Краткое руководство по началу работы"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:88
msgid ""
"FreeBSD can mount ZFS pools and datasets during system initialization.  To "
"enable it, add this line to [.filename]#/etc/rc.conf#:"
msgstr ""
"FreeBSD может монтировать пулы и наборы данных ZFS во время инициализации "
"системы. Чтобы включить эту функцию, добавьте следующую строку в [."
"filename]#/etc/rc.conf#:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:92
#, no-wrap
msgid "zfs_enable=\"YES\"\n"
msgstr "zfs_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:95
msgid "Then start the service:"
msgstr "Затем запустите службу:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:99
#, no-wrap
msgid "# service zfs start\n"
msgstr "# service zfs start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:103
msgid ""
"The examples in this section assume three SCSI disks with the device names [."
"filename]#da0#, [.filename]#da1#, and [.filename]#da2#.  Users of SATA "
"hardware should instead use [.filename]#ada# device names."
msgstr ""
"Примеры в этом разделе предполагают использование трех SCSI-дисков с именами "
"устройств [.filename]#da0#, [.filename]#da1# и [.filename]#da2#. "
"Пользователям оборудования SATA следует использовать имена устройств [."
"filename]#ada#."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:105
#, no-wrap
msgid "Single Disk Pool"
msgstr "Пул на одном диске"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:108
msgid "To create a simple, non-redundant pool using a single disk device:"
msgstr ""
"Чтобы создать простой, не избыточный пул, используя одно дисковое устройство:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:112
#, no-wrap
msgid "# zpool create example /dev/da0\n"
msgstr "# zpool create example /dev/da0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:115
msgid "To view the new pool, review the output of `df`:"
msgstr "Для просмотра нового пула ознакомьтесь с выводом команды `df`:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:124
#, no-wrap
msgid ""
"# df\n"
"Filesystem  1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a   2026030  235230  1628718    13%    /\n"
"devfs               1       1        0   100%    /dev\n"
"/dev/ad0s1d  54098308 1032846 48737598     2%    /usr\n"
"example      17547136       0 17547136     0%    /example\n"
msgstr ""
"# df\n"
"Filesystem  1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a   2026030  235230  1628718    13%    /\n"
"devfs               1       1        0   100%    /dev\n"
"/dev/ad0s1d  54098308 1032846 48737598     2%    /usr\n"
"example      17547136       0 17547136     0%    /example\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:128
msgid ""
"This output shows creating and mounting of the `example` pool, and that is "
"now accessible as a file system.  Create files for users to browse:"
msgstr ""
"Этот вывод показывает создание и монтирование пула `example`, который теперь "
"доступен как файловая система. Создайте файлы для пользователей, чтобы "
"посмотреть, что все работает:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:139
#, no-wrap
msgid ""
"# cd /example\n"
"# ls\n"
"# touch testfile\n"
"# ls -al\n"
"total 4\n"
"drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .\n"
"drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..\n"
"-rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile\n"
msgstr ""
"# cd /example\n"
"# ls\n"
"# touch testfile\n"
"# ls -al\n"
"total 4\n"
"drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .\n"
"drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..\n"
"-rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:143
msgid ""
"This pool is not using any advanced ZFS features and properties yet.  To "
"create a dataset on this pool with compression enabled:"
msgstr ""
"Этот пул пока не использует расширенные функции и свойства ZFS. Чтобы "
"создать набор данных в этом пуле с включенным сжатием:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:148
#, no-wrap
msgid ""
"# zfs create example/compressed\n"
"# zfs set compression=gzip example/compressed\n"
msgstr ""
"# zfs create example/compressed\n"
"# zfs set compression=gzip example/compressed\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:152
msgid ""
"The `example/compressed` dataset is now a ZFS compressed file system.  Try "
"copying some large files to [.filename]#/example/compressed#."
msgstr ""
"Набор данных `example/compressed` теперь представляет собой сжатую файловую "
"систему ZFS. Попробуйте скопировать несколько больших файлов в [.filename]#/"
"example/compressed#."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:154
msgid "Disable compression with:"
msgstr "Отключите сжатие с помощью:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:158
#, no-wrap
msgid "# zfs set compression=off example/compressed\n"
msgstr "# zfs set compression=off example/compressed\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:161
msgid "To unmount a file system, use `zfs umount` and then verify with `df`:"
msgstr ""
"Чтобы отмонтировать файловую систему, используйте `zfs umount`, а затем "
"проверьте с помощью `df`:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:171
#, no-wrap
msgid ""
"# zfs umount example/compressed\n"
"# df\n"
"Filesystem  1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a   2026030  235232  1628716    13%    /\n"
"devfs               1       1        0   100%    /dev\n"
"/dev/ad0s1d  54098308 1032864 48737580     2%    /usr\n"
"example      17547008       0 17547008     0%    /example\n"
msgstr ""
"# zfs umount example/compressed\n"
"# df\n"
"Filesystem  1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a   2026030  235232  1628716    13%    /\n"
"devfs               1       1        0   100%    /dev\n"
"/dev/ad0s1d  54098308 1032864 48737580     2%    /usr\n"
"example      17547008       0 17547008     0%    /example\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:174
msgid ""
"To re-mount the file system to make it accessible again, use `zfs mount` and "
"verify with `df`:"
msgstr ""
"Для повторного монтирования файловой системы, чтобы сделать её снова "
"доступной, используйте `zfs mount` и проверьте с помощью `df`:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:185
#, no-wrap
msgid ""
"# zfs mount example/compressed\n"
"# df\n"
"Filesystem         1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a          2026030  235234  1628714    13%    /\n"
"devfs                      1       1        0   100%    /dev\n"
"/dev/ad0s1d         54098308 1032864 48737580     2%    /usr\n"
"example             17547008       0 17547008     0%    /example\n"
"example/compressed  17547008       0 17547008     0%    /example/compressed\n"
msgstr ""
"# zfs mount example/compressed\n"
"# df\n"
"Filesystem         1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a          2026030  235234  1628714    13%    /\n"
"devfs                      1       1        0   100%    /dev\n"
"/dev/ad0s1d         54098308 1032864 48737580     2%    /usr\n"
"example             17547008       0 17547008     0%    /example\n"
"example/compressed  17547008       0 17547008     0%    /example/compressed\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:188
msgid "Running `mount` shows the pool and file systems:"
msgstr "Выполнение команды `mount` отображает пул и файловые системы:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:197
#, no-wrap
msgid ""
"# mount\n"
"/dev/ad0s1a on / (ufs, local)\n"
"devfs on /dev (devfs, local)\n"
"/dev/ad0s1d on /usr (ufs, local, soft-updates)\n"
"example on /example (zfs, local)\n"
"example/compressed on /example/compressed (zfs, local)\n"
msgstr ""
"# mount\n"
"/dev/ad0s1a on / (ufs, local)\n"
"devfs on /dev (devfs, local)\n"
"/dev/ad0s1d on /usr (ufs, local, soft-updates)\n"
"example on /example (zfs, local)\n"
"example/compressed on /example/compressed (zfs, local)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:203
msgid ""
"Use ZFS datasets like any file system after creation.  Set other available "
"features on a per-dataset basis when needed.  The example below creates a "
"new file system called `data`.  It assumes the file system contains "
"important files and configures it to store two copies of each data block."
msgstr ""
"Используйте наборы данных ZFS как любую файловую систему после создания. "
"Настраивайте другие доступные функции для каждого набора данных по мере "
"необходимости. В примере ниже создается новая файловая система с именем "
"`data`. Предполагается, что файловая система содержит важные файлы, и для "
"нее настроено хранение двух копий каждого блока данных."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:208
#, no-wrap
msgid ""
"# zfs create example/data\n"
"# zfs set copies=2 example/data\n"
msgstr ""
"# zfs create example/data\n"
"# zfs set copies=2 example/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:211
msgid "Use `df` to see the data and space usage:"
msgstr "Используйте `df` для просмотра данных и использования пространства:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:222
#, no-wrap
msgid ""
"# df\n"
"Filesystem         1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a          2026030  235234  1628714    13%    /\n"
"devfs                      1       1        0   100%    /dev\n"
"/dev/ad0s1d         54098308 1032864 48737580     2%    /usr\n"
"example             17547008       0 17547008     0%    /example\n"
"example/compressed  17547008       0 17547008     0%    /example/compressed\n"
"example/data        17547008       0 17547008     0%    /example/data\n"
msgstr ""
"# df\n"
"Filesystem         1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a          2026030  235234  1628714    13%    /\n"
"devfs                      1       1        0   100%    /dev\n"
"/dev/ad0s1d         54098308 1032864 48737580     2%    /usr\n"
"example             17547008       0 17547008     0%    /example\n"
"example/compressed  17547008       0 17547008     0%    /example/compressed\n"
"example/data        17547008       0 17547008     0%    /example/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:227
msgid ""
"Notice that all file systems in the pool have the same available space.  "
"Using `df` in these examples shows that the file systems use the space they "
"need and all draw from the same pool.  ZFS gets rid of concepts such as "
"volumes and partitions, and allows several file systems to share the same "
"pool."
msgstr ""
"Обратите внимание, что все файловые системы в пуле имеют одинаковое "
"доступное пространство. Использование `df` в этих примерах показывает, что "
"файловые системы занимают столько места, сколько им нужно, и все используют "
"один и тот же пул. ZFS устраняет такие понятия, как тома и разделы, и "
"позволяет нескольким файловым системам совместно использовать один пул."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:229
msgid "To destroy the file systems and then the pool that is no longer needed:"
msgstr ""
"Чтобы уничтожить файловые системы, а затем пул, который больше не нужен:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:235
#, no-wrap
msgid ""
"# zfs destroy example/compressed\n"
"# zfs destroy example/data\n"
"# zpool destroy example\n"
msgstr ""
"# zfs destroy example/compressed\n"
"# zfs destroy example/data\n"
"# zpool destroy example\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:238
#, no-wrap
msgid "RAID-Z"
msgstr "RAID-Z"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:244
msgid ""
"Disks fail.  One way to avoid data loss from disk failure is to use RAID.  "
"ZFS supports this feature in its pool design.  RAID-Z pools require three or "
"more disks but provide more usable space than mirrored pools."
msgstr ""
"Диски выходят из строя. Один из способов избежать потери данных при отказе "
"диска — использование RAID. ZFS поддерживает эту возможность в своей "
"конструкции пула. Пуллы RAID-Z требуют трёх или более дисков, но "
"предоставляют больше полезного пространства, чем зеркальные пуллы."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:246
msgid ""
"This example creates a RAID-Z pool, specifying the disks to add to the pool:"
msgstr ""
"В этом примере создается пул RAID-Z с указанием дисков для добавления в пул:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:250
#, no-wrap
msgid "# zpool create storage raidz da0 da1 da2\n"
msgstr "# zpool create storage raidz da0 da1 da2\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:258
msgid ""
"Sun(TM) recommends that the number of devices used in a RAID-Z configuration "
"be between three and nine.  For environments requiring a single pool "
"consisting of 10 disks or more, consider breaking it up into smaller RAID-Z "
"groups.  If two disks are available, ZFS mirroring provides redundancy if "
"required.  Refer to man:zpool[8] for more details."
msgstr ""
"Sun(TM) рекомендует использовать от трёх до девяти устройств в конфигурации "
"RAID-Z. Для сред, требующих единого пула из 10 или более дисков, "
"рекомендуется разбить его на меньшие группы RAID-Z. Если доступно два диска, "
"ZFS-зеркалирование обеспечит избыточность при необходимости. Подробнее см. в "
"man:zpool[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:262
msgid ""
"The previous example created the `storage` zpool.  This example makes a new "
"file system called `home` in that pool:"
msgstr ""
"Предыдущий пример создал пул `storage`. В этом примере в этом пуле создаётся "
"новая файловая система с именем `home`:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:266
#, no-wrap
msgid "# zfs create storage/home\n"
msgstr "# zfs create storage/home\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:269
msgid "Enable compression and store an extra copy of directories and files:"
msgstr "Включить сжатие и сохранить дополнительную копию каталогов и файлов:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:274
#, no-wrap
msgid ""
"# zfs set copies=2 storage/home\n"
"# zfs set compression=gzip storage/home\n"
msgstr ""
"# zfs set copies=2 storage/home\n"
"# zfs set compression=gzip storage/home\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:277
msgid ""
"To make this the new home directory for users, copy the user data to this "
"directory and create the appropriate symbolic links:"
msgstr ""
"Чтобы сделать это новым домашним каталогом для пользователей, скопируйте "
"пользовательские данные в этот каталог и создайте соответствующие "
"символические ссылки:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:284
#, no-wrap
msgid ""
"# cp -rp /home/* /storage/home\n"
"# rm -rf /home /usr/home\n"
"# ln -s /storage/home /home\n"
"# ln -s /storage/home /usr/home\n"
msgstr ""
"# cp -rp /home/* /storage/home\n"
"# rm -rf /home /usr/home\n"
"# ln -s /storage/home /home\n"
"# ln -s /storage/home /usr/home\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:288
msgid ""
"Users data is now stored on the freshly-created [.filename]#/storage/home#.  "
"Test by adding a new user and logging in as that user."
msgstr ""
"Данные пользователей теперь хранятся в только что созданном [.filename]#/"
"storage/home#. Проверьте это, добавив нового пользователя и войдя в систему "
"под его учётной записью."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:290
msgid "Create a file system snapshot to roll back to later:"
msgstr "Создайте снимок файловой системы для последующего отката:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:294
#, no-wrap
msgid "# zfs snapshot storage/home@08-30-08\n"
msgstr "# zfs snapshot storage/home@08-30-08\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:297
msgid "ZFS creates snapshots of a dataset, not a single directory or file."
msgstr "ZFS создает снимки набора данных, а не отдельного каталога или файла."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:300
msgid ""
"The `@` character is a delimiter between the file system name or the volume "
"name.  Before deleting an important directory, back up the file system, then "
"roll back to an earlier snapshot in which the directory still exists:"
msgstr ""
"Символ `@` является разделителем между именем файловой системы или именем "
"тома. Перед удалением важного каталога создайте резервную копию файловой "
"системы, а затем откатитесь к более раннему снимку, в котором каталог ещё "
"существует:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:304
#, no-wrap
msgid "# zfs rollback storage/home@08-30-08\n"
msgstr "# zfs rollback storage/home@08-30-08\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:308
msgid ""
"To list all available snapshots, run `ls` in the file system's [.filename]#."
"zfs/snapshot# directory.  For example, to see the snapshot taken:"
msgstr ""
"Чтобы перечислить все доступные снимки, выполните команду `ls` в каталоге [."
"filename]#.zfs/snapshot# файловой системы. Например, чтобы увидеть сделанный "
"снимок:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:312
#, no-wrap
msgid "# ls /storage/home/.zfs/snapshot\n"
msgstr "# ls /storage/home/.zfs/snapshot\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:317
msgid ""
"Write a script to take regular snapshots of user data.  Over time, snapshots "
"can use up a lot of disk space.  Remove the previous snapshot using the "
"command:"
msgstr ""
"Напишите скрипт для создания регулярных снимков пользовательских данных. Со "
"временем снимки могут занимать много места на диске. Удалите предыдущий "
"снимок с помощью команды:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:321
#, no-wrap
msgid "# zfs destroy storage/home@08-30-08\n"
msgstr "# zfs destroy storage/home@08-30-08\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:325
msgid ""
"After testing, make [.filename]#/storage/home# the real [.filename]#/home# "
"with this command:"
msgstr ""
"После тестирования сделайте [.filename]#/storage/home# настоящим [."
"filename]#/home# с помощью следующей команды:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:329
#, no-wrap
msgid "# zfs set mountpoint=/home storage/home\n"
msgstr "# zfs set mountpoint=/home storage/home\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:332
msgid ""
"Run `df` and `mount` to confirm that the system now treats the file system "
"as the real [.filename]#/home#:"
msgstr ""
"Выполните команды `df` и `mount`, чтобы убедиться, что система теперь "
"распознает файловую систему как настоящий [.filename]#/home#:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:348
#, no-wrap
msgid ""
"# mount\n"
"/dev/ad0s1a on / (ufs, local)\n"
"devfs on /dev (devfs, local)\n"
"/dev/ad0s1d on /usr (ufs, local, soft-updates)\n"
"storage on /storage (zfs, local)\n"
"storage/home on /home (zfs, local)\n"
"# df\n"
"Filesystem   1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a    2026030  235240  1628708    13%    /\n"
"devfs                1       1        0   100%    /dev\n"
"/dev/ad0s1d   54098308 1032826 48737618     2%    /usr\n"
"storage       26320512       0 26320512     0%    /storage\n"
"storage/home  26320512       0 26320512     0%    /home\n"
msgstr ""
"# mount\n"
"/dev/ad0s1a on / (ufs, local)\n"
"devfs on /dev (devfs, local)\n"
"/dev/ad0s1d on /usr (ufs, local, soft-updates)\n"
"storage on /storage (zfs, local)\n"
"storage/home on /home (zfs, local)\n"
"# df\n"
"Filesystem   1K-blocks    Used    Avail Capacity  Mounted on\n"
"/dev/ad0s1a    2026030  235240  1628708    13%    /\n"
"devfs                1       1        0   100%    /dev\n"
"/dev/ad0s1d   54098308 1032826 48737618     2%    /usr\n"
"storage       26320512       0 26320512     0%    /storage\n"
"storage/home  26320512       0 26320512     0%    /home\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:352
msgid ""
"This completes the RAID-Z configuration.  Add daily status updates about the "
"created file systems to the nightly man:periodic[8] runs by adding this line "
"to [.filename]#/etc/periodic.conf#:"
msgstr ""
"Настройка RAID-Z завершена. Для добавления ежедневных отчетов о состоянии "
"созданных файловых систем в ночные запуски man:periodic[8] добавьте "
"следующую строку в [.filename]#/etc/periodic.conf#:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:356
#, no-wrap
msgid "daily_status_zfs_enable=\"YES\"\n"
msgstr "daily_status_zfs_enable=\"YES\"\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:359
#, no-wrap
msgid "Recovering RAID-Z"
msgstr "Восстановление RAID-Z"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:363
msgid ""
"Every software RAID has a method of monitoring its `state`.  View the status "
"of RAID-Z devices using:"
msgstr ""
"Каждый программный RAID имеет метод контроля своего `состояния`. Просмотр "
"состояния устройств RAID-Z осуществляется с помощью:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:367
#, no-wrap
msgid "# zpool status -x\n"
msgstr "# zpool status -x\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:370
msgid ""
"If all pools are crossref:zfs[zfs-term-online,Online] and everything is "
"normal, the message shows:"
msgstr ""
"Если все пулы находятся в состоянии crossref:zfs[zfs-term-online,онлайн] и "
"все работает нормально, сообщение будет следующим:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:374
#, no-wrap
msgid "all pools are healthy\n"
msgstr "all pools are healthy\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:378
msgid ""
"If there is a problem, perhaps a disk being in the crossref:zfs[zfs-term-"
"offline,Offline] state, the pool state will look like this:"
msgstr ""
"Если возникла проблема, например, диск находится в состоянии crossref:"
"zfs[zfs-term-offline,оффлайн], состояние пула будет выглядеть так:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:390
#, no-wrap
msgid ""
"  pool: storage\n"
" state: DEGRADED\n"
"status: One or more devices has been taken offline by the administrator.\n"
"\tSufficient replicas exist for the pool to continue functioning in a\n"
"\tdegraded state.\n"
"action: Online the device using 'zpool online' or replace the device with\n"
"\t'zpool replace'.\n"
" scrub: none requested\n"
"config:\n"
msgstr ""
"  pool: storage\n"
" state: DEGRADED\n"
"status: One or more devices has been taken offline by the administrator.\n"
"\tSufficient replicas exist for the pool to continue functioning in a\n"
"\tdegraded state.\n"
"action: Online the device using 'zpool online' or replace the device with\n"
"\t'zpool replace'.\n"
" scrub: none requested\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:397
#, no-wrap
msgid ""
"\tNAME        STATE     READ WRITE CKSUM\n"
"\tstorage     DEGRADED     0     0     0\n"
"\t  raidz1    DEGRADED     0     0     0\n"
"\t    da0     ONLINE       0     0     0\n"
"\t    da1     OFFLINE      0     0     0\n"
"\t    da2     ONLINE       0     0     0\n"
msgstr ""
"\tNAME        STATE     READ WRITE CKSUM\n"
"\tstorage     DEGRADED     0     0     0\n"
"\t  raidz1    DEGRADED     0     0     0\n"
"\t    da0     ONLINE       0     0     0\n"
"\t    da1     OFFLINE      0     0     0\n"
"\t    da2     ONLINE       0     0     0\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:399
#: documentation/content/en/books/handbook/zfs/_index.adoc:434
#: documentation/content/en/books/handbook/zfs/_index.adoc:480
#: documentation/content/en/books/handbook/zfs/_index.adoc:525
#: documentation/content/en/books/handbook/zfs/_index.adoc:548
#: documentation/content/en/books/handbook/zfs/_index.adoc:580
#: documentation/content/en/books/handbook/zfs/_index.adoc:659
#: documentation/content/en/books/handbook/zfs/_index.adoc:713
#: documentation/content/en/books/handbook/zfs/_index.adoc:750
#: documentation/content/en/books/handbook/zfs/_index.adoc:779
#: documentation/content/en/books/handbook/zfs/_index.adoc:859
#: documentation/content/en/books/handbook/zfs/_index.adoc:935
#: documentation/content/en/books/handbook/zfs/_index.adoc:967
#: documentation/content/en/books/handbook/zfs/_index.adoc:1067
#: documentation/content/en/books/handbook/zfs/_index.adoc:1111
#: documentation/content/en/books/handbook/zfs/_index.adoc:1136
#: documentation/content/en/books/handbook/zfs/_index.adoc:1157
#, no-wrap
msgid "errors: No known data errors\n"
msgstr "errors: No known data errors\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:402
msgid ""
"\"OFFLINE\" shows the administrator took [.filename]#da1# offline using:"
msgstr ""
"\"OFFLINE\" показывает, что администратор перевел [.filename]#da1# в "
"автономный режим с помощью:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:406
#, no-wrap
msgid "# zpool offline storage da1\n"
msgstr "# zpool offline storage da1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:410
msgid ""
"Power down the computer now and replace [.filename]#da1#.  Power up the "
"computer and return [.filename]#da1# to the pool:"
msgstr ""
"Выключите компьютер и замените диск [.filename]#da1#. Включите компьютер и "
"верните [.filename]#da1# в пул:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:414
#, no-wrap
msgid "# zpool replace storage da1\n"
msgstr "# zpool replace storage da1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:417
msgid ""
"Next, check the status again, this time without `-x` to display all pools:"
msgstr ""
"Далее снова проверьте статус, на этот раз без `-x`, чтобы отобразить все "
"пулы:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:425
#, no-wrap
msgid ""
"# zpool status storage\n"
" pool: storage\n"
" state: ONLINE\n"
" scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008\n"
"config:\n"
msgstr ""
"# zpool status storage\n"
" pool: storage\n"
" state: ONLINE\n"
" scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:432
#: documentation/content/en/books/handbook/zfs/_index.adoc:478
#, no-wrap
msgid ""
"\tNAME        STATE     READ WRITE CKSUM\n"
"\tstorage     ONLINE       0     0     0\n"
"\t  raidz1    ONLINE       0     0     0\n"
"\t    da0     ONLINE       0     0     0\n"
"\t    da1     ONLINE       0     0     0\n"
"\t    da2     ONLINE       0     0     0\n"
msgstr ""
"\tNAME        STATE     READ WRITE CKSUM\n"
"\tstorage     ONLINE       0     0     0\n"
"\t  raidz1    ONLINE       0     0     0\n"
"\t    da0     ONLINE       0     0     0\n"
"\t    da1     ONLINE       0     0     0\n"
"\t    da2     ONLINE       0     0     0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:437
msgid "In this example, everything is normal."
msgstr "В этом примере все в порядке."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:439
#, no-wrap
msgid "Data Verification"
msgstr "Проверка данных"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:443
msgid ""
"ZFS uses checksums to verify the integrity of stored data.  Creating file "
"systems automatically enables them."
msgstr ""
"ZFS использует контрольные суммы для проверки целостности хранимых данных. "
"Создание файловых систем автоматически включает их."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:450
msgid ""
"Disabling Checksums is possible but _not_ recommended! Checksums take little "
"storage space and provide data integrity.  Most ZFS features will not work "
"properly with checksums disabled.  Disabling these checksums will not "
"increase performance noticeably."
msgstr ""
"Отключение контрольных сумм возможно, но _не_ рекомендуется! Контрольные "
"суммы занимают мало места и обеспечивают целостность данных. Большинство "
"функций ZFS не будут работать корректно при отключенных контрольных суммах. "
"Их отключение не приведет к заметному повышению производительности."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:453
msgid ""
"Verifying the data checksums (called _scrubbing_) ensures integrity of the "
"`storage` pool with:"
msgstr ""
"Проверка контрольных сумм данных (называемая _scrubbing_) обеспечивает "
"целостность пула `storage` с помощью:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:457
#, no-wrap
msgid "# zpool scrub storage\n"
msgstr "# zpool scrub storage\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:463
msgid ""
"The duration of a scrub depends on the amount of data stored.  Larger "
"amounts of data will take proportionally longer to verify.  Since scrubbing "
"is I/O intensive, ZFS allows a single scrub to run at a time.  After "
"scrubbing completes, view the status with `zpool status`:"
msgstr ""
"Продолжительность очистки зависит от объема хранимых данных. Большие объемы "
"данных требуют пропорционально больше времени для проверки. Поскольку "
"очистка интенсивно использует операции ввода-вывода, ZFS позволяет выполнять "
"только одну очистку одновременно. После завершения очистки просмотрите "
"статус с помощью `zpool status`:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:471
#, no-wrap
msgid ""
"# zpool status storage\n"
" pool: storage\n"
" state: ONLINE\n"
" scrub: scrub completed with 0 errors on Sat Jan 26 19:57:37 2013\n"
"config:\n"
msgstr ""
"# zpool status storage\n"
" pool: storage\n"
" state: ONLINE\n"
" scrub: scrub completed with 0 errors on Sat Jan 26 19:57:37 2013\n"
"config:\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:484
msgid ""
"Displaying the completion date of the last scrubbing helps decide when to "
"start another.  Routine scrubs help protect data from silent corruption and "
"ensure the integrity of the pool."
msgstr ""
"Отображение даты завершения последней очистки помогает определить, когда "
"начать следующую. Регулярная очистка защищает данные от тихих повреждений и "
"гарантирует целостность пула."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:486
msgid "Refer to man:zfs[8] and man:zpool[8] for other ZFS options."
msgstr "См. man:zfs[8] и man:zpool[8] для других опций ZFS."

#. type: Title ==
#: documentation/content/en/books/handbook/zfs/_index.adoc:488
#, no-wrap
msgid "`zpool` Administration"
msgstr "Администрирование `zpool`"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:495
msgid ""
"ZFS administration uses two main utilities.  The `zpool` utility controls "
"the operation of the pool and allows adding, removing, replacing, and "
"managing disks.  The crossref:zfs[zfs-zfs,`zfs`] utility allows creating, "
"destroying, and managing datasets, both crossref:zfs[zfs-term-filesystem,"
"file systems] and crossref:zfs[zfs-term-volume,volumes]."
msgstr ""
"Управление ZFS осуществляется с помощью двух основных утилит. Утилита "
"`zpool` контролирует работу пула и позволяет добавлять, удалять, заменять и "
"управлять дисками. Утилита crossref:zfs[zfs-zfs,`zfs`] позволяет создавать, "
"уничтожать и управлять наборами данных, включая как crossref:zfs[zfs-term-"
"filesystem,файловые системы], так и crossref:zfs[zfs-term-volume,тома]."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:497
#, no-wrap
msgid "Creating and Destroying Storage Pools"
msgstr "Создание и удаление пулов хранения данных"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:506
msgid ""
"Creating a ZFS storage pool requires permanent decisions, as the pool "
"structure cannot change after creation.  The most important decision is "
"which types of vdevs to group the physical disks into.  See the list of "
"crossref:zfs[zfs-term-vdev,vdev types] for details about the possible "
"options.  After creating the pool, most vdev types do not allow adding disks "
"to the vdev.  The exceptions are mirrors, which allow adding new disks to "
"the vdev, and stripes, which upgrade to mirrors by attaching a new disk to "
"the vdev.  Although adding new vdevs expands a pool, the pool layout cannot "
"change after pool creation.  Instead, back up the data, destroy the pool, "
"and recreate it."
msgstr ""
"Создание пула хранения ZFS требует принятия постоянных решений, так как "
"структура пула не может быть изменена после создания. Наиболее важное "
"решение — это выбор типов vdev, в которые будут объединены физические диски. "
"Подробнее о возможных вариантах см. в списке crossref:zfs[zfs-term-vdev,"
"типов vdev]. После создания пула большинство типов vdev не позволяют "
"добавлять диски в vdev. Исключения составляют зеркала (mirror), которые "
"позволяют добавлять новые диски в vdev, и страйпы (stripe), которые могут "
"быть преобразованы в зеркала путём добавления нового диска к vdev. Хотя "
"добавление новых vdev расширяет пул, компоновка пула не может быть изменена "
"после его создания. Вместо этого необходимо создать резервную копию данных, "
"удалить пул и воссоздать его."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:508
msgid "Create a simple mirror pool:"
msgstr "Создание простого зеркального пула:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:517
#, no-wrap
msgid ""
"# zpool create mypool mirror /dev/ada1 /dev/ada2\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"
msgstr ""
"# zpool create mypool mirror /dev/ada1 /dev/ada2\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:523
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada1    ONLINE       0     0     0\n"
"            ada2    ONLINE       0     0     0\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada1    ONLINE       0     0     0\n"
"            ada2    ONLINE       0     0     0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:528
msgid ""
"To create more than one vdev with a single command, specify groups of disks "
"separated by the vdev type keyword, `mirror` in this example:"
msgstr ""
"Чтобы создать более одного vdev одной командой, укажите группы дисков, "
"разделенные ключевым словом типа vdev, в данном примере `mirror`:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:537
#, no-wrap
msgid ""
"# zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"
msgstr ""
"# zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:546
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada1    ONLINE       0     0     0\n"
"            ada2    ONLINE       0     0     0\n"
"          mirror-1  ONLINE       0     0     0\n"
"            ada3    ONLINE       0     0     0\n"
"            ada4    ONLINE       0     0     0\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada1    ONLINE       0     0     0\n"
"            ada2    ONLINE       0     0     0\n"
"          mirror-1  ONLINE       0     0     0\n"
"            ada3    ONLINE       0     0     0\n"
"            ada4    ONLINE       0     0     0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:557
msgid ""
"Pools can also use partitions rather than whole disks.  Putting ZFS in a "
"separate partition allows the same disk to have other partitions for other "
"purposes.  In particular, it allows adding partitions with bootcode and file "
"systems needed for booting.  This allows booting from disks that are also "
"members of a pool.  ZFS adds no performance penalty on FreeBSD when using a "
"partition rather than a whole disk.  Using partitions also allows the "
"administrator to _under-provision_ the disks, using less than the full "
"capacity.  If a future replacement disk of the same nominal size as the "
"original actually has a slightly smaller capacity, the smaller partition "
"will still fit, using the replacement disk."
msgstr ""
"Пулы также могут использовать разделы вместо целых дисков. Размещение ZFS в "
"отдельном разделе позволяет одному диску иметь другие разделы для иных "
"целей. В частности, это позволяет добавлять разделы с загрузочным кодом и "
"файловыми системами, необходимыми для загрузки. Это дает возможность "
"загружаться с дисков, которые также являются членами пула. ZFS не приводит к "
"снижению производительности на FreeBSD при использовании раздела вместо "
"целого диска. Использование разделов также позволяет администратору "
"_недоиспользовать_ диски, задействуя не всю их емкость. Если будущий "
"заменяемый диск того же номинального размера, что и оригинальный, на самом "
"деле имеет немного меньшую емкость, меньший раздел все равно поместится на "
"заменяемом диске."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:559
msgid ""
"Create a crossref:zfs[zfs-term-vdev-raidz,RAID-Z2] pool using partitions:"
msgstr ""
"Создание пула crossref:zfs[zfs-term-vdev-raidz,RAID-Z2] с использованием "
"разделов:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:568
#, no-wrap
msgid ""
"# zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"
msgstr ""
"# zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:578
#: documentation/content/en/books/handbook/zfs/_index.adoc:777
#: documentation/content/en/books/handbook/zfs/_index.adoc:965
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          raidz2-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0\n"
"            ada2p3  ONLINE       0     0     0\n"
"            ada3p3  ONLINE       0     0     0\n"
"            ada4p3  ONLINE       0     0     0\n"
"            ada5p3  ONLINE       0     0     0\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          raidz2-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0\n"
"            ada2p3  ONLINE       0     0     0\n"
"            ada3p3  ONLINE       0     0     0\n"
"            ada4p3  ONLINE       0     0     0\n"
"            ada5p3  ONLINE       0     0     0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:587
msgid ""
"Destroy a pool that is no longer needed to reuse the disks.  Destroying a "
"pool requires unmounting the file systems in that pool first.  If any "
"dataset is in use, the unmount operation fails without destroying the pool.  "
"Force the pool destruction with `-f`.  This can cause undefined behavior in "
"applications which had open files on those datasets."
msgstr ""
"Уничтожьте пул, который больше не нужен, чтобы повторно использовать диски. "
"Перед уничтожением пула необходимо размонтировать файловые системы в этом "
"пуле. Если какой-либо набор данных используется, операция размонтирования "
"завершится неудачей без уничтожения пула. Принудительное уничтожение пула "
"выполняется с помощью `-f`. Это может привести к неопределённому поведению "
"приложений, у которых были открыты файлы в этих наборах данных."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:589
#, no-wrap
msgid "Adding and Removing Devices"
msgstr "Добавление и удаление устройств"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:593
msgid ""
"Two ways exist for adding disks to a pool: attaching a disk to an existing "
"vdev with `zpool attach`, or adding vdevs to the pool with `zpool add`.  "
"Some crossref:zfs[zfs-term-vdev,vdev types] allow adding disks to the vdev "
"after creation."
msgstr ""
"Существует два способа добавления дисков в пул: подключение диска к "
"существующему vdev с помощью `zpool attach` или добавление vdev в пул с "
"помощью `zpool add`. Некоторые crossref:zfs[zfs-term-vdev,типы vdev] "
"позволяют добавлять диски в vdev после его создания."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:602
msgid ""
"A pool created with a single disk lacks redundancy.  It can detect "
"corruption but can not repair it, because there is no other copy of the "
"data.  The crossref:zfs[zfs-term-copies,copies] property may be able to "
"recover from a small failure such as a bad sector, but does not provide the "
"same level of protection as mirroring or RAID-Z.  Starting with a pool "
"consisting of a single disk vdev, use `zpool attach` to add a new disk to "
"the vdev, creating a mirror.  Also use `zpool attach` to add new disks to a "
"mirror group, increasing redundancy and read performance.  When partitioning "
"the disks used for the pool, replicate the layout of the first disk on to "
"the second.  Use `gpart backup` and `gpart restore` to make this process "
"easier."
msgstr ""
"Пул, созданный с одним диском, не обладает избыточностью. Он может "
"обнаружить повреждение данных, но не может его исправить, так как нет другой "
"копии данных. Свойство crossref:zfs[zfs-term-copies,Копии (copies)] может "
"восстановить данные после небольшого сбоя, например, повреждённого сектора, "
"но не обеспечивает такой же уровень защиты, как зеркалирование или RAID-Z. "
"Начиная с пула, состоящего из однодискового vdev, используйте `zpool attach` "
"для добавления нового диска в vdev, создавая зеркало. Также используйте "
"`zpool attach` для добавления новых дисков в зеркальную группу, увеличивая "
"избыточность и производительность чтения. При разметке дисков, используемых "
"для пула, повторите разметку первого диска на втором. Используйте `gpart "
"backup` и `gpart restore` для упрощения этого процесса."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:604
msgid ""
"Upgrade the single disk (stripe) vdev [.filename]#ada0p3# to a mirror by "
"attaching [.filename]#ada1p3#:"
msgstr ""
"Обновите однодисковый vdev (stripe) [.filename]#ada0p3# до зеркала, "
"присоединив [.filename]#ada1p3#:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:612
#: documentation/content/en/books/handbook/zfs/_index.adoc:809
#, no-wrap
msgid ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"
msgstr ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:616
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          ada0p3    ONLINE       0     0     0\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          ada0p3    ONLINE       0     0     0\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:620
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool attach mypool ada0p3 ada1p3\n"
"Make sure to wait until resilvering finishes before rebooting.\n"
msgstr ""
"errors: No known data errors\n"
"# zpool attach mypool ada0p3 ada1p3\n"
"Make sure to wait until resilvering finishes before rebooting.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:622
#, no-wrap
msgid "If you boot from pool 'mypool', you may need to update boot code on newly attached disk _ada1p3_.\n"
msgstr "If you boot from pool 'mypool', you may need to update boot code on newly attached disk _ada1p3_.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:624
#, no-wrap
msgid "Assuming you use GPT partitioning and _da0_ is your new boot disk you may use the following command:\n"
msgstr "Assuming you use GPT partitioning and _da0_ is your new boot disk you may use the following command:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:638
#, no-wrap
msgid ""
"        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0\n"
"# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1\n"
"bootcode written to ada1\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"status: One or more devices is currently being resilvered.  The pool will\n"
"        continue to function, possibly in a degraded state.\n"
"action: Wait for the resilver to complete.\n"
"  scan: resilver in progress since Fri May 30 08:19:19 2014\n"
"        527M scanned out of 781M at 47.9M/s, 0h0m to go\n"
"        527M resilvered, 67.53% done\n"
"config:\n"
msgstr ""
"        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0\n"
"# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1\n"
"bootcode written to ada1\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"status: One or more devices is currently being resilvered.  The pool will\n"
"        continue to function, possibly in a degraded state.\n"
"action: Wait for the resilver to complete.\n"
"  scan: resilver in progress since Fri May 30 08:19:19 2014\n"
"        527M scanned out of 781M at 47.9M/s, 0h0m to go\n"
"        527M resilvered, 67.53% done\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:644
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0  (resilvering)\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0  (resilvering)\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:651
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: resilvered 781M in 0h0m with 0 errors on Fri May 30 08:15:58 2014\n"
"config:\n"
msgstr ""
"errors: No known data errors\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: resilvered 781M in 0h0m with 0 errors on Fri May 30 08:15:58 2014\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:657
#: documentation/content/en/books/handbook/zfs/_index.adoc:690
#: documentation/content/en/books/handbook/zfs/_index.adoc:748
#: documentation/content/en/books/handbook/zfs/_index.adoc:815
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:667
msgid ""
"When adding disks to the existing vdev is not an option, as for RAID-Z, an "
"alternative method is to add another vdev to the pool.  Adding vdevs "
"provides higher performance by distributing writes across the vdevs.  Each "
"vdev provides its own redundancy.  Mixing vdev types like `mirror` and `RAID-"
"Z` is possible but discouraged.  Adding a non-redundant vdev to a pool "
"containing mirror or RAID-Z vdevs risks the data on the entire pool.  "
"Distributing writes means a failure of the non-redundant disk will result in "
"the loss of a fraction of every block written to the pool."
msgstr ""
"Если добавление дисков к существующему vdev невозможно, как в случае с RAID-"
"Z, альтернативным методом является добавление другого vdev в пул. Добавление "
"vdev повышает производительность за счет распределения записей между vdev. "
"Каждый vdev обеспечивает свою собственную избыточность. Возможно смешивание "
"типов vdev, таких как `mirror` и `RAID-Z`, но это не рекомендуется. "
"Добавление не избыточного vdev к пулу, содержащему mirror или RAID-Z vdev, "
"подвергает риску данные во всем пуле. Распределение записей означает, что "
"отказ не избыточного диска приведет к потере части каждого блока, "
"записанного в пул."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:672
msgid ""
"ZFS stripes data across each of the vdevs.  For example, with two mirror "
"vdevs, this is effectively a RAID 10 that stripes writes across two sets of "
"mirrors.  ZFS allocates space so that each vdev reaches 100% full at the "
"same time.  Having vdevs with different amounts of free space will lower "
"performance, as more data writes go to the less full vdev."
msgstr ""
"ZFS распределяет данные по всем vdev. Например, при использовании двух "
"зеркальных vdev это фактически эквивалентно RAID 10, где записи "
"распределяются по двум наборам зеркал. ZFS выделяет пространство таким "
"образом, что каждый vdev достигает 100% заполненности одновременно. Наличие "
"vdev с разным количеством свободного места снижает производительность, так "
"как больше данных записывается на менее заполненный vdev."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:674
msgid ""
"When attaching new devices to a boot pool, remember to update the bootcode."
msgstr ""
"При подключении новых устройств к загрузочному пулу не забудьте обновить "
"загрузочный код."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:676
msgid ""
"Attach a second mirror group ([.filename]#ada2p3# and [.filename]#ada3p3#) "
"to the existing mirror:"
msgstr ""
"Присоедините вторую группу зеркал ([.filename]#ada2p3# и [."
"filename]#ada3p3#) к существующему зеркалу:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:684
#, no-wrap
msgid ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: resilvered 781M in 0h0m with 0 errors on Fri May 30 08:19:35 2014\n"
"config:\n"
msgstr ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: resilvered 781M in 0h0m with 0 errors on Fri May 30 08:19:35 2014\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:702
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool add mypool mirror ada2p3 ada3p3\n"
"# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2\n"
"bootcode written to ada2\n"
"# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada3\n"
"bootcode written to ada3\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014\n"
"config:\n"
msgstr ""
"errors: No known data errors\n"
"# zpool add mypool mirror ada2p3 ada3p3\n"
"# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2\n"
"bootcode written to ada2\n"
"# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada3\n"
"bootcode written to ada3\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:711
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0\n"
"          mirror-1  ONLINE       0     0     0\n"
"            ada2p3  ONLINE       0     0     0\n"
"            ada3p3  ONLINE       0     0     0\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0\n"
"          mirror-1  ONLINE       0     0     0\n"
"            ada2p3  ONLINE       0     0     0\n"
"            ada3p3  ONLINE       0     0     0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:717
msgid ""
"Removing vdevs from a pool is impossible and removal of disks from a mirror "
"is exclusive if there is enough remaining redundancy.  If a single disk "
"remains in a mirror group, that group ceases to be a mirror and becomes a "
"stripe, risking the entire pool if that remaining disk fails."
msgstr ""
"Удаление устройств vdev из пула невозможно, а удаление дисков из зеркала "
"возможно только при сохранении достаточной избыточности. Если в группе "
"зеркала остается единственный диск, эта группа перестает быть зеркалом и "
"становится страйпом, что подвергает весь пул риску в случае выхода из строя "
"оставшегося диска."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:719
msgid "Remove a disk from a three-way mirror group:"
msgstr "Удалить диск из трёхдисковой зеркальной группы:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:727
#, no-wrap
msgid ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014\n"
"config:\n"
msgstr ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:734
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0\n"
"            ada2p3  ONLINE       0     0     0\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada1p3  ONLINE       0     0     0\n"
"            ada2p3  ONLINE       0     0     0\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:742
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool detach mypool ada2p3\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014\n"
"config:\n"
msgstr ""
"errors: No known data errors\n"
"# zpool detach mypool ada2p3\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014\n"
"config:\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:753
#, no-wrap
msgid "Checking the Status of a Pool"
msgstr "Проверка состояния пула"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:759
msgid ""
"Pool status is important.  If a drive goes offline or ZFS detects a read, "
"write, or checksum error, the corresponding error count increases.  The "
"`status` output shows the configuration and status of each device in the "
"pool and the status of the entire pool.  Actions to take and details about "
"the last crossref:zfs[zfs-zpool-scrub,`scrub`] are also shown."
msgstr ""
"Статус пула важен. Если диск отключается или ZFS обнаруживает ошибку чтения, "
"записи или контрольной суммы, соответствующий счетчик ошибок увеличивается. "
"Вывод команды `status` показывает конфигурацию и состояние каждого "
"устройства в пуле, а также состояние всего пула. Также отображаются "
"действия, которые следует предпринять, и детали последнего crossref:zfs[zfs-"
"zpool-scrub,`scrub`]."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:767
#, no-wrap
msgid ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub repaired 0 in 2h25m with 0 errors on Sat Sep 14 04:25:50 2013\n"
"config:\n"
msgstr ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub repaired 0 in 2h25m with 0 errors on Sat Sep 14 04:25:50 2013\n"
"config:\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:782
#, no-wrap
msgid "Clearing Errors"
msgstr "Сброс состояния ошибки"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:788
msgid ""
"When detecting an error, ZFS increases the read, write, or checksum error "
"counts.  Clear the error message and reset the counts with `zpool clear "
"_mypool_`.  Clearing the error state can be important for automated scripts "
"that alert the administrator when the pool encounters an error.  Without "
"clearing old errors, the scripts may fail to report further errors."
msgstr ""
"При обнаружении ошибки ZFS увеличивает счетчики ошибок чтения, записи или "
"контрольных сумм. Чтобы очистить сообщение об ошибке и сбросить счетчики, "
"используйте команду `zpool clear _mypool_`. Сброс состояния ошибки может "
"быть важен для автоматизированных скриптов, которые уведомляют "
"администратора при возникновении ошибки в пуле. Без очистки старых ошибок "
"скрипты могут не сообщать о новых ошибках."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:790
#, no-wrap
msgid "Replacing a Functioning Device"
msgstr "Замена рабочего устройства"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:799
msgid ""
"It may be desirable to replace one disk with a different disk.  When "
"replacing a working disk, the process keeps the old disk online during the "
"replacement.  The pool never enters a crossref:zfs[zfs-term-degraded,"
"degraded] state, reducing the risk of data loss.  Running `zpool replace` "
"copies the data from the old disk to the new one.  After the operation "
"completes, ZFS disconnects the old disk from the vdev.  If the new disk is "
"larger than the old disk, it may be possible to grow the zpool, using the "
"new space.  See crossref:zfs[zfs-zpool-online,Growing a Pool]."
msgstr ""
"Может потребоваться заменить один диск на другой. При замене рабочего диска "
"процесс сохраняет старый диск в режиме онлайн во время замены. Пул никогда "
"не переходит в состояние crossref:zfs[zfs-term-degraded,деградировавшего], "
"что снижает риск потери данных. Выполнение команды `zpool replace` копирует "
"данные со старого диска на новый. После завершения операции ZFS отключает "
"старый диск от vdev. Если новый диск больше старого, можно расширить zpool, "
"используя новое пространство. См. crossref:zfs[zfs-zpool-online,Расширение "
"пула]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:801
msgid "Replace a functioning device in the pool:"
msgstr "Заменить работающее устройство в пуле:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:819
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool replace mypool ada1p3 ada2p3\n"
"Make sure to wait until resilvering finishes before rebooting.\n"
msgstr ""
"errors: No known data errors\n"
"# zpool replace mypool ada1p3 ada2p3\n"
"Make sure to wait until resilvering finishes before rebooting.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:821
#, no-wrap
msgid "When booting from the pool 'zroot', update the boot code on the newly attached disk 'ada2p3'.\n"
msgstr "When booting from the pool 'zroot', update the boot code on the newly attached disk 'ada2p3'.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:823
#, no-wrap
msgid "Assuming GPT partitioning is used and [.filename]#da0# is the new boot disk, use the following command:\n"
msgstr "Assuming GPT partitioning is used and [.filename]#da0# is the new boot disk, use the following command:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:836
#, no-wrap
msgid ""
"        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0\n"
"# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"status: One or more devices is currently being resilvered.  The pool will\n"
"        continue to function, possibly in a degraded state.\n"
"action: Wait for the resilver to complete.\n"
"  scan: resilver in progress since Mon Jun  2 14:21:35 2014\n"
"        604M scanned out of 781M at 46.5M/s, 0h0m to go\n"
"        604M resilvered, 77.39% done\n"
"config:\n"
msgstr ""
"        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0\n"
"# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"status: One or more devices is currently being resilvered.  The pool will\n"
"        continue to function, possibly in a degraded state.\n"
"action: Wait for the resilver to complete.\n"
"  scan: resilver in progress since Mon Jun  2 14:21:35 2014\n"
"        604M scanned out of 781M at 46.5M/s, 0h0m to go\n"
"        604M resilvered, 77.39% done\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:844
#, no-wrap
msgid ""
"        NAME             STATE     READ WRITE CKSUM\n"
"        mypool           ONLINE       0     0     0\n"
"          mirror-0       ONLINE       0     0     0\n"
"            ada0p3       ONLINE       0     0     0\n"
"            replacing-1  ONLINE       0     0     0\n"
"              ada1p3     ONLINE       0     0     0\n"
"              ada2p3     ONLINE       0     0     0  (resilvering)\n"
msgstr ""
"        NAME             STATE     READ WRITE CKSUM\n"
"        mypool           ONLINE       0     0     0\n"
"          mirror-0       ONLINE       0     0     0\n"
"            ada0p3       ONLINE       0     0     0\n"
"            replacing-1  ONLINE       0     0     0\n"
"              ada1p3     ONLINE       0     0     0\n"
"              ada2p3     ONLINE       0     0     0  (resilvering)\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:851
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: resilvered 781M in 0h0m with 0 errors on Mon Jun  2 14:21:52 2014\n"
"config:\n"
msgstr ""
"errors: No known data errors\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: resilvered 781M in 0h0m with 0 errors on Mon Jun  2 14:21:52 2014\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:857
#: documentation/content/en/books/handbook/zfs/_index.adoc:933
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada2p3  ONLINE       0     0     0\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"            ada0p3  ONLINE       0     0     0\n"
"            ada2p3  ONLINE       0     0     0\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:862
#, no-wrap
msgid "Dealing with Failed Devices"
msgstr "Обработка неисправных устройств"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:871
msgid ""
"When a disk in a pool fails, the vdev to which the disk belongs enters the "
"crossref:zfs[zfs-term-degraded,degraded] state.  The data is still "
"available, but with reduced performance because ZFS computes missing data "
"from the available redundancy.  To restore the vdev to a fully functional "
"state, replace the failed physical device.  ZFS is then instructed to begin "
"the crossref:zfs[zfs-term-resilver,resilver] operation.  ZFS recomputes data "
"on the failed device from available redundancy and writes it to the "
"replacement device.  After completion, the vdev returns to crossref:zfs[zfs-"
"term-online,online] status."
msgstr ""
"Когда диск в пуле выходит из строя, устройство vdev, к которому принадлежит "
"этот диск, переходит в crossref:zfs[zfs-term-degraded,деградировавшее] "
"состояние. Данные остаются доступными, но с пониженной производительностью, "
"поскольку ZFS вычисляет недостающие данные из доступной избыточности. Чтобы "
"восстановить устройство vdev в полностью работоспособное состояние, замените "
"вышедший из строя физический диск. Затем ZFS получает указание начать "
"операцию crossref:zfs[zfs-term-resilver,восстановления]. ZFS пересчитывает "
"данные с вышедшего из строя устройства из доступной избыточности и "
"записывает их на заменённый диск. После завершения процесса устройство vdev "
"возвращается в состояние crossref:zfs[zfs-term-online,онлайн]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:876
msgid ""
"If the vdev does not have any redundancy, or if devices have failed and "
"there is not enough redundancy to compensate, the pool enters the crossref:"
"zfs[zfs-term-faulted,faulted] state.  Unless enough devices can reconnect "
"the pool becomes inoperative requiring a data restore from backups."
msgstr ""
"Если vdev не имеет избыточности или если устройства вышли из строя и "
"недостаточно избыточности для компенсации, пул переходит в состояние "
"crossref:zfs[zfs-term-faulted,faulted]. Если недостаточно устройств для "
"восстановления связи, пул становится неработоспособным, что требует "
"восстановления данных из резервных копий."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:879
msgid ""
"When replacing a failed disk, the name of the failed disk changes to the "
"GUID of the new disk.  A new device name parameter for `zpool replace` is "
"not required if the replacement device has the same device name."
msgstr ""
"При замене вышедшего из строя диска имя отказавшего диска изменяется на GUID "
"нового диска. Новый параметр имени устройства для `zpool replace` не "
"требуется, если заменяющее устройство имеет то же имя устройства."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:881
msgid "Replace a failed disk using `zpool replace`:"
msgstr "Заменить вышедший из строя диск с помощью `zpool replace`:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:893
#, no-wrap
msgid ""
"# zpool status\n"
"  pool: mypool\n"
" state: DEGRADED\n"
"status: One or more devices could not be opened.  Sufficient replicas exist for\n"
"        the pool to continue functioning in a degraded state.\n"
"action: Attach the missing device and online it using 'zpool online'.\n"
"   see: http://illumos.org/msg/ZFS-8000-2Q\n"
"  scan: none requested\n"
"config:\n"
msgstr ""
"# zpool status\n"
"  pool: mypool\n"
" state: DEGRADED\n"
"status: One or more devices could not be opened.  Sufficient replicas exist for\n"
"        the pool to continue functioning in a degraded state.\n"
"action: Attach the missing device and online it using 'zpool online'.\n"
"   see: http://illumos.org/msg/ZFS-8000-2Q\n"
"  scan: none requested\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:899
#, no-wrap
msgid ""
"        NAME                    STATE     READ WRITE CKSUM\n"
"        mypool                  DEGRADED     0     0     0\n"
"          mirror-0              DEGRADED     0     0     0\n"
"            ada0p3              ONLINE       0     0     0\n"
"            316502962686821739  UNAVAIL      0     0     0  was /dev/ada1p3\n"
msgstr ""
"        NAME                    STATE     READ WRITE CKSUM\n"
"        mypool                  DEGRADED     0     0     0\n"
"          mirror-0              DEGRADED     0     0     0\n"
"            ada0p3              ONLINE       0     0     0\n"
"            316502962686821739  UNAVAIL      0     0     0  was /dev/ada1p3\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:912
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool replace mypool 316502962686821739 ada2p3\n"
"# zpool status\n"
"  pool: mypool\n"
" state: DEGRADED\n"
"status: One or more devices is currently being resilvered.  The pool will\n"
"        continue to function, possibly in a degraded state.\n"
"action: Wait for the resilver to complete.\n"
"  scan: resilver in progress since Mon Jun  2 14:52:21 2014\n"
"        641M scanned out of 781M at 49.3M/s, 0h0m to go\n"
"        640M resilvered, 82.04% done\n"
"config:\n"
msgstr ""
"errors: No known data errors\n"
"# zpool replace mypool 316502962686821739 ada2p3\n"
"# zpool status\n"
"  pool: mypool\n"
" state: DEGRADED\n"
"status: One or more devices is currently being resilvered.  The pool will\n"
"        continue to function, possibly in a degraded state.\n"
"action: Wait for the resilver to complete.\n"
"  scan: resilver in progress since Mon Jun  2 14:52:21 2014\n"
"        641M scanned out of 781M at 49.3M/s, 0h0m to go\n"
"        640M resilvered, 82.04% done\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:920
#, no-wrap
msgid ""
"        NAME                        STATE     READ WRITE CKSUM\n"
"        mypool                      DEGRADED     0     0     0\n"
"          mirror-0                  DEGRADED     0     0     0\n"
"            ada0p3                  ONLINE       0     0     0\n"
"            replacing-1             UNAVAIL      0     0     0\n"
"              15732067398082357289  UNAVAIL      0     0     0  was /dev/ada1p3/old\n"
"              ada2p3                ONLINE       0     0     0  (resilvering)\n"
msgstr ""
"        NAME                        STATE     READ WRITE CKSUM\n"
"        mypool                      DEGRADED     0     0     0\n"
"          mirror-0                  DEGRADED     0     0     0\n"
"            ada0p3                  ONLINE       0     0     0\n"
"            replacing-1             UNAVAIL      0     0     0\n"
"              15732067398082357289  UNAVAIL      0     0     0  was /dev/ada1p3/old\n"
"              ada2p3                ONLINE       0     0     0  (resilvering)\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:927
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: resilvered 781M in 0h0m with 0 errors on Mon Jun  2 14:52:38 2014\n"
"config:\n"
msgstr ""
"errors: No known data errors\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: resilvered 781M in 0h0m with 0 errors on Mon Jun  2 14:52:38 2014\n"
"config:\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:938
#, no-wrap
msgid "Scrubbing a Pool"
msgstr "Чистка пула"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:944
msgid ""
"Routinely crossref:zfs[zfs-term-scrub,scrub] pools, ideally at least once "
"every month.  The `scrub` operation is disk-intensive and will reduce "
"performance while running.  Avoid high-demand periods when scheduling "
"`scrub` or use crossref:zfs[zfs-advanced-tuning-scrub_delay,`vfs.zfs."
"scrub_delay`] to adjust the relative priority of the `scrub` to keep it from "
"slowing down other workloads."
msgstr ""
"Регулярно выполняйте crossref:zfs[zfs-term-scrub,scrub] для пулов, "
"желательно не реже одного раза в месяц. Операция `scrub` интенсивно "
"использует диски и может снизить производительность во время выполнения. "
"Избегайте периодов высокой нагрузки при планировании `scrub` или используйте "
"crossref:zfs[zfs-advanced-tuning-scrub_delay,`vfs.zfs.scrub_delay`] для "
"настройки относительного приоритета `scrub`, чтобы предотвратить замедление "
"других задач."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:955
#, no-wrap
msgid ""
"# zpool scrub mypool\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub in progress since Wed Feb 19 20:52:54 2014\n"
"        116G scanned out of 8.60T at 649M/s, 3h48m to go\n"
"        0 repaired, 1.32% done\n"
"config:\n"
msgstr ""
"# zpool scrub mypool\n"
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"  scan: scrub in progress since Wed Feb 19 20:52:54 2014\n"
"        116G scanned out of 8.60T at 649M/s, 3h48m to go\n"
"        0 repaired, 1.32% done\n"
"config:\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:970
msgid "To cancel a scrub operation if needed, run `zpool scrub -s _mypool_`."
msgstr ""
"Если возникла необходимость отменить операцию scrub, выполните `zpool scrub -"
"s _mypool_`."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:972
#, no-wrap
msgid "Self-Healing"
msgstr "Самолечение"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:983
msgid ""
"The checksums stored with data blocks enable the file system to _self-"
"heal_.  This feature will automatically repair data whose checksum does not "
"match the one recorded on another device that is part of the storage pool.  "
"For example, a mirror configuration with two disks where one drive is "
"starting to malfunction and cannot properly store the data any more.  This "
"is worse when the data was not accessed for a long time, as with long term "
"archive storage.  Traditional file systems need to run commands that check "
"and repair the data like man:fsck[8].  These commands take time, and in "
"severe cases, an administrator has to decide which repair operation to "
"perform.  When ZFS detects a data block with a mismatched checksum, it tries "
"to read the data from the mirror disk.  If that disk can provide the correct "
"data, ZFS will give that to the application and correct the data on the disk "
"with the wrong checksum.  This happens without any interaction from a system "
"administrator during normal pool operation."
msgstr ""
"Контрольные суммы, хранимые с блоками данных, позволяют файловой системе "
"_самовосстанавливаться_. Эта функция автоматически исправляет данные, "
"контрольная сумма которых не совпадает с записанной на другом устройстве, "
"входящем в состав пула хранения. Например, в конфигурации зеркала с двумя "
"дисками, где один из дисков начинает работать со сбоями и больше не может "
"корректно хранить данные. Это становится ещё хуже, если данные долгое время "
"не были доступны, как в случае долгосрочного архивного хранения. "
"Традиционные файловые системы требуют выполнения команд для проверки и "
"исправления данных, таких как man:fsck[8]. Эти команды занимают время, а в "
"сложных случаях администратору приходится выбирать, какую операцию "
"восстановления выполнить. Когда ZFS обнаруживает блок данных с несовпадающей "
"контрольной суммой, он пытается прочитать данные с зеркального диска. Если "
"этот диск может предоставить корректные данные, ZFS передаст их приложению и "
"исправит данные на диске с ошибочной контрольной суммой. Это происходит без "
"какого-либо вмешательства администратора в ходе обычной работы пула."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:985
msgid ""
"The next example shows this self-healing behavior by creating a mirrored "
"pool of disks [.filename]#/dev/ada0# and [.filename]#/dev/ada1#."
msgstr ""
"Следующий пример демонстрирует самовосстановление при создании зеркального "
"пула из дисков [.filename]#/dev/ada0# и [.filename]#/dev/ada1#."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:994
#, no-wrap
msgid ""
"# zpool create healer mirror /dev/ada0 /dev/ada1\n"
"# zpool status healer\n"
"  pool: healer\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"
msgstr ""
"# zpool create healer mirror /dev/ada0 /dev/ada1\n"
"# zpool status healer\n"
"  pool: healer\n"
" state: ONLINE\n"
"  scan: none requested\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1000
#: documentation/content/en/books/handbook/zfs/_index.adoc:1155
#, no-wrap
msgid ""
"    NAME        STATE     READ WRITE CKSUM\n"
"    healer      ONLINE       0     0     0\n"
"      mirror-0  ONLINE       0     0     0\n"
"       ada0     ONLINE       0     0     0\n"
"       ada1     ONLINE       0     0     0\n"
msgstr ""
"    NAME        STATE     READ WRITE CKSUM\n"
"    healer      ONLINE       0     0     0\n"
"      mirror-0  ONLINE       0     0     0\n"
"       ada0     ONLINE       0     0     0\n"
"       ada1     ONLINE       0     0     0\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1005
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool list\n"
"NAME     SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT\n"
"healer   960M  92.5K   960M         -         -     0%    0%  1.00x  ONLINE  -\n"
msgstr ""
"errors: No known data errors\n"
"# zpool list\n"
"NAME     SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT\n"
"healer   960M  92.5K   960M         -         -     0%    0%  1.00x  ONLINE  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1008
msgid ""
"Copy some important data to the pool to protect from data errors using the "
"self-healing feature and create a checksum of the pool for later comparison."
msgstr ""
"Скопируйте какие-нибудь важные данные в пул для защиты от ошибок данных с "
"использованием функции самовосстановления и создайте контрольную сумму пула "
"для последующего сравнения."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1018
#, no-wrap
msgid ""
"# cp /some/important/data /healer\n"
"# zfs list\n"
"NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT\n"
"healer   960M  67.7M   892M     7%  1.00x  ONLINE  -\n"
"# sha1 /healer > checksum.txt\n"
"# cat checksum.txt\n"
"SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f\n"
msgstr ""
"# cp /some/important/data /healer\n"
"# zfs list\n"
"NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT\n"
"healer   960M  67.7M   892M     7%  1.00x  ONLINE  -\n"
"# sha1 /healer > checksum.txt\n"
"# cat checksum.txt\n"
"SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1022
msgid ""
"Simulate data corruption by writing random data to the beginning of one of "
"the disks in the mirror.  To keep ZFS from healing the data when detected, "
"export the pool before the corruption and import it again afterwards."
msgstr ""
"Симулируйте повреждение данных, записав случайные данные в начало одного из "
"дисков в зеркале. Чтобы предотвратить восстановление данных ZFS при "
"обнаружении, экспортируйте пул перед повреждением и снова импортируйте его "
"после."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1030
msgid ""
"This is a dangerous operation that can destroy vital data, shown here for "
"demonstration alone.  *Do not try* it during normal operation of a storage "
"pool.  Nor should this intentional corruption example run on any disk with a "
"file system not using ZFS on another partition in it.  Do not use any other "
"disk device names other than the ones that are part of the pool.  Ensure "
"proper backups of the pool exist and test them before running the command!"
msgstr ""
"Это опасная операция, которая может уничтожить важные данные, и приведена "
"здесь только для демонстрации. *Не пытайтесь* выполнить её во время "
"нормальной работы хранилища данных. Также этот пример преднамеренного "
"повреждения не должен выполняться на диске, содержащем файловую систему, не "
"использующую ZFS на другом разделе. Не используйте имена дисковых устройств, "
"кроме тех, что входят в пул. Убедитесь, что существуют резервные копии пула, "
"и проверьте их перед выполнением команды!"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1040
#, no-wrap
msgid ""
"# zpool export healer\n"
"# dd if=/dev/random of=/dev/ada1 bs=1m count=200\n"
"200+0 records in\n"
"200+0 records out\n"
"209715200 bytes transferred in 62.992162 secs (3329227 bytes/sec)\n"
"# zpool import healer\n"
msgstr ""
"# zpool export healer\n"
"# dd if=/dev/random of=/dev/ada1 bs=1m count=200\n"
"200+0 records in\n"
"200+0 records out\n"
"209715200 bytes transferred in 62.992162 secs (3329227 bytes/sec)\n"
"# zpool import healer\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1046
msgid ""
"The pool status shows that one device has experienced an error.  Note that "
"applications reading data from the pool did not receive any incorrect data.  "
"ZFS provided data from the [.filename]#ada0# device with the correct "
"checksums.  To find the device with the wrong checksum, look for one whose "
"`CKSUM` column contains a nonzero value."
msgstr ""
"Статус пула показывает, что на одном устройстве произошла ошибка. Обратите "
"внимание, что приложения, читающие данные из пула, не получили некорректных "
"данных. ZFS предоставил данные с устройства [.filename]#ada0# с правильными "
"контрольными суммами. Чтобы найти устройство с неверной контрольной суммой, "
"ищите то, у которого в столбце `CKSUM` указано ненулевое значение."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1059
#, no-wrap
msgid ""
"# zpool status healer\n"
"    pool: healer\n"
"   state: ONLINE\n"
"  status: One or more devices has experienced an unrecoverable error.  An\n"
"          attempt was made to correct the error.  Applications are unaffected.\n"
"  action: Determine if the device needs to be replaced, and clear the errors\n"
"          using 'zpool clear' or replace the device with 'zpool replace'.\n"
"     see: http://illumos.org/msg/ZFS-8000-4J\n"
"    scan: none requested\n"
"  config:\n"
msgstr ""
"# zpool status healer\n"
"    pool: healer\n"
"   state: ONLINE\n"
"  status: One or more devices has experienced an unrecoverable error.  An\n"
"          attempt was made to correct the error.  Applications are unaffected.\n"
"  action: Determine if the device needs to be replaced, and clear the errors\n"
"          using 'zpool clear' or replace the device with 'zpool replace'.\n"
"     see: http://illumos.org/msg/ZFS-8000-4J\n"
"    scan: none requested\n"
"  config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1065
#, no-wrap
msgid ""
"      NAME        STATE     READ WRITE CKSUM\n"
"      healer      ONLINE       0     0     0\n"
"        mirror-0  ONLINE       0     0     0\n"
"         ada0     ONLINE       0     0     0\n"
"         ada1     ONLINE       0     0     1\n"
msgstr ""
"      NAME        STATE     READ WRITE CKSUM\n"
"      healer      ONLINE       0     0     0\n"
"        mirror-0  ONLINE       0     0     0\n"
"         ada0     ONLINE       0     0     0\n"
"         ada1     ONLINE       0     0     1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1071
msgid ""
"ZFS detected the error and handled it by using the redundancy present in the "
"unaffected [.filename]#ada0# mirror disk.  A checksum comparison with the "
"original one will reveal whether the pool is consistent again."
msgstr ""
"ZFS обнаружил ошибку и обработал её, используя избыточность на "
"неповреждённом зеркальном диске [.filename]#ada0#. Сравнение контрольных "
"сумм с исходными покажет, восстановлена ли согласованность пула."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1078
#, no-wrap
msgid ""
"# sha1 /healer >> checksum.txt\n"
"# cat checksum.txt\n"
"SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f\n"
"SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f\n"
msgstr ""
"# sha1 /healer >> checksum.txt\n"
"# cat checksum.txt\n"
"SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f\n"
"SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1087
msgid ""
"Generate checksums before and after the intentional tampering while the pool "
"data still matches.  This shows how ZFS is capable of detecting and "
"correcting any errors automatically when the checksums differ.  Note this is "
"possible with enough redundancy present in the pool.  A pool consisting of a "
"single device has no self-healing capabilities.  That is also the reason why "
"checksums are so important in ZFS; do not disable them for any reason.  ZFS "
"requires no man:fsck[8] or similar file system consistency check program to "
"detect and correct this, and keeps the pool available while there is a "
"problem.  A scrub operation is now required to overwrite the corrupted data "
"on [.filename]#ada1#."
msgstr ""
"Генерируйте контрольные суммы до и после намеренного изменения данных, пока "
"данные в пуле еще совпадают. Это демонстрирует, как ZFS способен "
"автоматически обнаруживать и исправлять любые ошибки, когда контрольные "
"суммы различаются. Обратите внимание, что это возможно только при наличии "
"достаточной избыточности в пуле. Пул, состоящий из одного устройства, не "
"обладает возможностями самовосстановления. Именно поэтому контрольные суммы "
"так важны в ZFS — не отключайте их ни по какой причине. ZFS не требует "
"использования man:fsck[8] или аналогичной программы проверки целостности "
"файловой системы для обнаружения и исправления ошибок, а также поддерживает "
"доступность пула даже при наличии проблемы. Теперь требуется операция scrub "
"для перезаписи поврежденных данных на [.filename]#ada1#."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1103
#, no-wrap
msgid ""
"# zpool scrub healer\n"
"# zpool status healer\n"
"  pool: healer\n"
" state: ONLINE\n"
"status: One or more devices has experienced an unrecoverable error.  An\n"
"            attempt was made to correct the error.  Applications are unaffected.\n"
"action: Determine if the device needs to be replaced, and clear the errors\n"
"            using 'zpool clear' or replace the device with 'zpool replace'.\n"
"   see: http://illumos.org/msg/ZFS-8000-4J\n"
"  scan: scrub in progress since Mon Dec 10 12:23:30 2012\n"
"        10.4M scanned out of 67.0M at 267K/s, 0h3m to go\n"
"        9.63M repaired, 15.56% done\n"
"config:\n"
msgstr ""
"# zpool scrub healer\n"
"# zpool status healer\n"
"  pool: healer\n"
" state: ONLINE\n"
"status: One or more devices has experienced an unrecoverable error.  An\n"
"            attempt was made to correct the error.  Applications are unaffected.\n"
"action: Determine if the device needs to be replaced, and clear the errors\n"
"            using 'zpool clear' or replace the device with 'zpool replace'.\n"
"   see: http://illumos.org/msg/ZFS-8000-4J\n"
"  scan: scrub in progress since Mon Dec 10 12:23:30 2012\n"
"        10.4M scanned out of 67.0M at 267K/s, 0h3m to go\n"
"        9.63M repaired, 15.56% done\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1109
#, no-wrap
msgid ""
"    NAME        STATE     READ WRITE CKSUM\n"
"    healer      ONLINE       0     0     0\n"
"      mirror-0  ONLINE       0     0     0\n"
"       ada0     ONLINE       0     0     0\n"
"       ada1     ONLINE       0     0   627  (repairing)\n"
msgstr ""
"    NAME        STATE     READ WRITE CKSUM\n"
"    healer      ONLINE       0     0     0\n"
"      mirror-0  ONLINE       0     0     0\n"
"       ada0     ONLINE       0     0     0\n"
"       ada1     ONLINE       0     0   627  (repairing)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1115
msgid ""
"The scrub operation reads data from [.filename]#ada0# and rewrites any data "
"with a wrong checksum on [.filename]#ada1#, shown by the `(repairing)` "
"output from `zpool status`.  After the operation is complete, the pool "
"status changes to:"
msgstr ""
"Операция scrub читает данные с [.filename]#ada0# и перезаписывает любые "
"данные с некорректной контрольной суммой на [.filename]#ada1#, что "
"отображается как `(repairing)` в выводе `zpool status`. После завершения "
"операции состояние пула изменяется на:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1128
#, no-wrap
msgid ""
"# zpool status healer\n"
"  pool: healer\n"
" state: ONLINE\n"
"status: One or more devices has experienced an unrecoverable error.  An\n"
"        attempt was made to correct the error.  Applications are unaffected.\n"
"action: Determine if the device needs to be replaced, and clear the errors\n"
"             using 'zpool clear' or replace the device with 'zpool replace'.\n"
"   see: http://illumos.org/msg/ZFS-8000-4J\n"
"  scan: scrub repaired 66.5M in 0h2m with 0 errors on Mon Dec 10 12:26:25 2012\n"
"config:\n"
msgstr ""
"# zpool status healer\n"
"  pool: healer\n"
" state: ONLINE\n"
"status: One or more devices has experienced an unrecoverable error.  An\n"
"        attempt was made to correct the error.  Applications are unaffected.\n"
"action: Determine if the device needs to be replaced, and clear the errors\n"
"             using 'zpool clear' or replace the device with 'zpool replace'.\n"
"   see: http://illumos.org/msg/ZFS-8000-4J\n"
"  scan: scrub repaired 66.5M in 0h2m with 0 errors on Mon Dec 10 12:26:25 2012\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1134
#, no-wrap
msgid ""
"    NAME        STATE     READ WRITE CKSUM\n"
"    healer      ONLINE       0     0     0\n"
"      mirror-0  ONLINE       0     0     0\n"
"       ada0     ONLINE       0     0     0\n"
"       ada1     ONLINE       0     0 2.72K\n"
msgstr ""
"    NAME        STATE     READ WRITE CKSUM\n"
"    healer      ONLINE       0     0     0\n"
"      mirror-0  ONLINE       0     0     0\n"
"       ada0     ONLINE       0     0     0\n"
"       ada1     ONLINE       0     0 2.72K\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1140
msgid ""
"After the scrubbing operation completes with all the data synchronized from "
"[.filename]#ada0# to [.filename]#ada1#, crossref:zfs[zfs-zpool-clear,clear] "
"the error messages from the pool status by running `zpool clear`."
msgstr ""
"После завершения операции очистки, когда все данные синхронизированы с [."
"filename]#ada0# на [.filename]#ada1#, сбросьте сообщения об ошибках из "
"состояния пула, выполнив команду `zpool clear`, как описано в разделе "
"crossref:zfs[zfs-zpool-clear, Сброс состояния ошибки]."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1149
#, no-wrap
msgid ""
"# zpool clear healer\n"
"# zpool status healer\n"
"  pool: healer\n"
" state: ONLINE\n"
"  scan: scrub repaired 66.5M in 0h2m with 0 errors on Mon Dec 10 12:26:25 2012\n"
"config:\n"
msgstr ""
"# zpool clear healer\n"
"# zpool status healer\n"
"  pool: healer\n"
" state: ONLINE\n"
"  scan: scrub repaired 66.5M in 0h2m with 0 errors on Mon Dec 10 12:26:25 2012\n"
"config:\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1160
msgid ""
"The pool is now back to a fully working state, with all error counts now "
"zero."
msgstr ""
"Пулу возвращено полностью рабочее состояние, все счётчики ошибок теперь "
"обнулены."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1162
#, no-wrap
msgid "Growing a Pool"
msgstr "Увеличение размера пула"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1172
msgid ""
"The smallest device in each vdev limits the usable size of a redundant "
"pool.  Replace the smallest device with a larger device.  After completing a "
"crossref:zfs[zfs-zpool-replace,replace] or crossref:zfs[zfs-term-resilver,"
"resilver] operation, the pool can grow to use the capacity of the new "
"device.  For example, consider a mirror of a 1 TB drive and a 2 TB drive.  "
"The usable space is 1 TB.  When replacing the 1 TB drive with another 2 TB "
"drive, the resilvering process copies the existing data onto the new drive.  "
"As both of the devices now have 2 TB capacity, the mirror's available space "
"grows to 2 TB."
msgstr ""
"Наименьшее устройство в каждом vdev ограничивает полезный размер избыточного "
"пула. Замените наименьшее устройство на устройство большего размера. После "
"завершения операции crossref:zfs[zfs-zpool-replace,замены] или crossref:"
"zfs[zfs-term-resilver,пересинхронизации] пул может расшириться для "
"использования ёмкости нового устройства. Например, рассмотрим зеркало из "
"диска на 1 ТБ и диска на 2 ТБ. Полезное пространство составляет 1 ТБ. При "
"замене диска на 1 ТБ другим диском на 2 ТБ процесс пересинхронизации "
"копирует существующие данные на новый диск. Поскольку оба устройства теперь "
"имеют ёмкость 2 ТБ, доступное пространство зеркала увеличивается до 2 ТБ."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1175
msgid ""
"Start expansion by using `zpool online -e` on each device.  After expanding "
"all devices, the extra space becomes available to the pool."
msgstr ""
"Начните расширение, используя `zpool online -e` для каждого устройства. "
"После расширения всех устройств дополнительное пространство становится "
"доступным для пула."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1177
#, no-wrap
msgid "Importing and Exporting Pools"
msgstr "Импорт и экспорт пулов"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1185
msgid ""
"_Export_ pools before moving them to another system.  ZFS unmounts all "
"datasets, marking each device as exported but still locked to prevent use by "
"other disks.  This allows pools to be _imported_ on other machines, other "
"operating systems that support ZFS, and even different hardware "
"architectures (with some caveats, see man:zpool[8]).  When a dataset has "
"open files, use `zpool export -f` to force exporting the pool.  Use this "
"with caution.  The datasets are forcibly unmounted, potentially resulting in "
"unexpected behavior by the applications which had open files on those "
"datasets."
msgstr ""
"_Экспортируйте_ пулы перед перемещением на другую систему. ZFS отмонтирует "
"все наборы данных, помечая каждое устройство как экспортированное, но все "
"еще заблокированное, чтобы предотвратить использование другими дисками. Это "
"позволяет импортировать пулы на других машинах, операционных системах с "
"поддержкой ZFS и даже на аппаратных архитектурах другого типа (с некоторыми "
"оговорками, см. man:zpool[8]). Если в наборе данных есть открытые файлы, "
"используйте `zpool export -f` для принудительного экспорта пула. Используйте "
"эту команду с осторожностью. Наборы данных будут принудительно "
"отмонтированы, что может привести к неожиданному поведению приложений, "
"работавших с открытыми файлами в этих наборах данных."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1187
msgid "Export a pool that is not in use:"
msgstr "Экспортируйте пул, который не используется:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1191
#, no-wrap
msgid "# zpool export mypool\n"
msgstr "# zpool export mypool\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1199
msgid ""
"Importing a pool automatically mounts the datasets.  If this is undesired "
"behavior, use `zpool import -N` to prevent it.  `zpool import -o` sets "
"temporary properties for this specific import.  `zpool import altroot=` "
"allows importing a pool with a base mount point instead of the root of the "
"file system.  If the pool was last used on a different system and was not "
"properly exported, force the import using `zpool import -f`.  `zpool import -"
"a` imports all pools that do not appear to be in use by another system."
msgstr ""
"Импорт пула автоматически монтирует наборы данных. Если такое поведение "
"нежелательно, используйте `zpool import -N`, чтобы предотвратить это. `zpool "
"import -o` устанавливает временные свойства для данного конкретного импорта. "
"`zpool import altroot=` позволяет импортировать пул с базовой точкой "
"монтирования вместо корня файловой системы. Если пул последний раз "
"использовался в другой системе и не был корректно экспортирован, "
"принудительно импортируйте его с помощью `zpool import -f`. `zpool import -"
"a` импортирует все пулы, которые, по-видимому, не используются другой "
"системой."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1201
msgid "List all available pools for import:"
msgstr "Выведите список всех доступных пулов для импорта:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1210
#, no-wrap
msgid ""
"# zpool import\n"
"   pool: mypool\n"
"     id: 9930174748043525076\n"
"  state: ONLINE\n"
" action: The pool can be imported using its name or numeric identifier.\n"
" config:\n"
msgstr ""
"# zpool import\n"
"   pool: mypool\n"
"     id: 9930174748043525076\n"
"  state: ONLINE\n"
" action: The pool can be imported using its name or numeric identifier.\n"
" config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1213
#, no-wrap
msgid ""
"        mypool      ONLINE\n"
"          ada2p3    ONLINE\n"
msgstr ""
"        mypool      ONLINE\n"
"          ada2p3    ONLINE\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1216
msgid "Import the pool with an alternative root directory:"
msgstr "Импортируйте пул с альтернативным корневым каталогом:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1224
#, no-wrap
msgid ""
"# zpool import -o altroot=/mnt mypool\n"
"# zfs list\n"
"zfs list\n"
"NAME                 USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool               110K  47.0G    31K  /mnt/mypool\n"
msgstr ""
"# zpool import -o altroot=/mnt mypool\n"
"# zfs list\n"
"zfs list\n"
"NAME                 USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool               110K  47.0G    31K  /mnt/mypool\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1227
#, no-wrap
msgid "Upgrading a Storage Pool"
msgstr "Обновление пула дисков"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1233
msgid ""
"After upgrading FreeBSD, or if importing a pool from a system using an older "
"version, manually upgrade the pool to the latest ZFS version to support "
"newer features.  Consider whether the pool may ever need importing on an "
"older system before upgrading.  Upgrading is a one-way process.  Upgrade "
"older pools is possible, but downgrading pools with newer features is not."
msgstr ""
"После обновления FreeBSD или при импорте пула с системы, использующей более "
"старую версию, вручную обновите пул до последней версии ZFS для поддержки "
"новых функций. Перед обновлением учтите, может ли пул потребоваться для "
"импорта на более старой системе. Обновление является необратимым процессом. "
"Обновление старых пулов возможно, но понижение версии пулов с новыми "
"функциями — нет."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1235
msgid "Upgrade a v28 pool to support `Feature Flags`:"
msgstr "Обновление пула v28 для поддержки `Feature Flags`:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1248
#, no-wrap
msgid ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"status: The pool is formatted using a legacy on-disk format.  The pool can\n"
"        still be used, but some features are unavailable.\n"
"action: Upgrade the pool using 'zpool upgrade'.  Once this is done, the\n"
"        pool will no longer be accessible on software that does not support feat\n"
"        flags.\n"
"  scan: none requested\n"
"config:\n"
msgstr ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"status: The pool is formatted using a legacy on-disk format.  The pool can\n"
"        still be used, but some features are unavailable.\n"
"action: Upgrade the pool using 'zpool upgrade'.  Once this is done, the\n"
"        pool will no longer be accessible on software that does not support feat\n"
"        flags.\n"
"  scan: none requested\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1254
#: documentation/content/en/books/handbook/zfs/_index.adoc:1302
#, no-wrap
msgid ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"\t    ada0    ONLINE       0     0     0\n"
"\t    ada1    ONLINE       0     0     0\n"
msgstr ""
"        NAME        STATE     READ WRITE CKSUM\n"
"        mypool      ONLINE       0     0     0\n"
"          mirror-0  ONLINE       0     0     0\n"
"\t    ada0    ONLINE       0     0     0\n"
"\t    ada1    ONLINE       0     0     0\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1258
#: documentation/content/en/books/handbook/zfs/_index.adoc:1306
#, no-wrap
msgid ""
"errors: No known data errors\n"
"# zpool upgrade\n"
"This system supports ZFS pool feature flags.\n"
msgstr ""
"errors: No known data errors\n"
"# zpool upgrade\n"
"This system supports ZFS pool feature flags.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1261
#, no-wrap
msgid ""
"The following pools are formatted with legacy version numbers and are upgraded to use feature flags.\n"
"After being upgraded, these pools will no longer be accessible by software that does not support feature flags.\n"
msgstr ""
"The following pools are formatted with legacy version numbers and are upgraded to use feature flags.\n"
"After being upgraded, these pools will no longer be accessible by software that does not support feature flags.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1265
#, no-wrap
msgid ""
"VER  POOL\n"
"---  ------------\n"
"28   mypool\n"
msgstr ""
"VER  POOL\n"
"---  ------------\n"
"28   mypool\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1270
#, no-wrap
msgid ""
"Use 'zpool upgrade -v' for a list of available legacy versions.\n"
"Every feature flags pool has all supported features enabled.\n"
"# zpool upgrade mypool\n"
"This system supports ZFS pool feature flags.\n"
msgstr ""
"Use 'zpool upgrade -v' for a list of available legacy versions.\n"
"Every feature flags pool has all supported features enabled.\n"
"# zpool upgrade mypool\n"
"This system supports ZFS pool feature flags.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1277
#, no-wrap
msgid ""
"Successfully upgraded 'mypool' from version 28 to feature flags.\n"
"Enabled the following features on 'mypool':\n"
"  async_destroy\n"
"  empty_bpobj\n"
"  lz4_compress\n"
"  multi_vdev_crash_dump\n"
msgstr ""
"Successfully upgraded 'mypool' from version 28 to feature flags.\n"
"Enabled the following features on 'mypool':\n"
"  async_destroy\n"
"  empty_bpobj\n"
"  lz4_compress\n"
"  multi_vdev_crash_dump\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1281
msgid ""
"The newer features of ZFS will not be available until `zpool upgrade` has "
"completed.  Use `zpool upgrade -v` to see what new features the upgrade "
"provides, as well as which features are already supported."
msgstr ""
"Новые возможности ZFS станут доступны только после выполнения команды `zpool "
"upgrade`. Используйте `zpool upgrade -v`, чтобы увидеть, какие новые "
"возможности предоставляет обновление, а также какие функции уже "
"поддерживаются."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1283
msgid "Upgrade a pool to support new feature flags:"
msgstr "Обновление пула для поддержки новых флагов функций:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1296
#, no-wrap
msgid ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"status: Some supported features are not enabled on the pool. The pool can\n"
"        still be used, but some features are unavailable.\n"
"action: Enable all features using 'zpool upgrade'. Once this is done,\n"
"        the pool may no longer be accessible by software that does not support\n"
"        the features. See zpool-features(7) for details.\n"
"  scan: none requested\n"
"config:\n"
msgstr ""
"# zpool status\n"
"  pool: mypool\n"
" state: ONLINE\n"
"status: Some supported features are not enabled on the pool. The pool can\n"
"        still be used, but some features are unavailable.\n"
"action: Enable all features using 'zpool upgrade'. Once this is done,\n"
"        the pool may no longer be accessible by software that does not support\n"
"        the features. See zpool-features(7) for details.\n"
"  scan: none requested\n"
"config:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1308
#, no-wrap
msgid "All pools are formatted using feature flags.\n"
msgstr "All pools are formatted using feature flags.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1312
#, no-wrap
msgid ""
"Some supported features are not enabled on the following pools. Once a\n"
"feature is enabled the pool may become incompatible with software\n"
"that does not support the feature. See zpool-features(7) for details.\n"
msgstr ""
"Some supported features are not enabled on the following pools. Once a\n"
"feature is enabled the pool may become incompatible with software\n"
"that does not support the feature. See zpool-features(7) for details.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1325
#, no-wrap
msgid ""
"POOL  FEATURE\n"
"---------------\n"
"zstore\n"
"      multi_vdev_crash_dump\n"
"      spacemap_histogram\n"
"      enabled_txg\n"
"      hole_birth\n"
"      extensible_dataset\n"
"      bookmarks\n"
"      filesystem_limits\n"
"# zpool upgrade mypool\n"
"This system supports ZFS pool feature flags.\n"
msgstr ""
"POOL  FEATURE\n"
"---------------\n"
"zstore\n"
"      multi_vdev_crash_dump\n"
"      spacemap_histogram\n"
"      enabled_txg\n"
"      hole_birth\n"
"      extensible_dataset\n"
"      bookmarks\n"
"      filesystem_limits\n"
"# zpool upgrade mypool\n"
"This system supports ZFS pool feature flags.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1333
#, no-wrap
msgid ""
"Enabled the following features on 'mypool':\n"
"  spacemap_histogram\n"
"  enabled_txg\n"
"  hole_birth\n"
"  extensible_dataset\n"
"  bookmarks\n"
"  filesystem_limits\n"
msgstr ""
"Enabled the following features on 'mypool':\n"
"  spacemap_histogram\n"
"  enabled_txg\n"
"  hole_birth\n"
"  extensible_dataset\n"
"  bookmarks\n"
"  filesystem_limits\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1340
msgid ""
"Update the boot code on systems that boot from a pool to support the new "
"pool version.  Use `gpart bootcode` on the partition that contains the boot "
"code.  Two types of bootcode are available, depending on way the system "
"boots: GPT (the most common option) and EFI (for more modern systems)."
msgstr ""
"Обновите загрузочный код на системах, которые загружаются с пула, чтобы "
"поддержать новую версию пула. Используйте `gpart bootcode` для раздела, "
"содержащего загрузочный код. Доступны два типа загрузочного кода в "
"зависимости от способа загрузки системы: GPT (наиболее распространённый "
"вариант) и EFI (для более современных систем)."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1342
msgid "For legacy boot using GPT, use the following command:"
msgstr ""
"Для загрузки в устаревшем режиме с использованием GPT используйте следующую "
"команду:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1346
#, no-wrap
msgid "# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1\n"
msgstr "# gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1349
msgid "For systems using EFI to boot, execute the following command:"
msgstr ""
"Для систем, использующих EFI для загрузки, выполните следующую команду:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1353
#, fuzzy, no-wrap
#| msgid "# gpart bootcode -p /boot/boot1.efifat -i 1 ada1\n"
msgid "# gpart bootcode -p /boot/boot1.efi -i 1 ada1\n"
msgstr "# gpart bootcode -p /boot/boot1.efifat -i 1 ada1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1357
msgid ""
"Apply the bootcode to all bootable disks in the pool.  See man:gpart[8] for "
"more information."
msgstr ""
"Примените загрузочный код ко всем загрузочным дискам в пуле. Подробнее см. в "
"man:gpart[8]."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1360
#, no-wrap
msgid "Displaying Recorded Pool History"
msgstr "Отображение записанной истории пулов"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1366
msgid ""
"ZFS records commands that change the pool, including creating datasets, "
"changing properties, or replacing a disk.  Reviewing history about a pool's "
"creation is useful, as is checking which user performed a specific action "
"and when.  History is not kept in a log file, but is part of the pool "
"itself.  The command to review this history is aptly named `zpool history`:"
msgstr ""
"ZFS записывает команды, которые изменяют пул, включая создание наборов "
"данных, изменение свойств или замену диска. Просмотр истории создания пула "
"полезен, так же как и проверка того, какой пользователь выполнил конкретное "
"действие и когда. История не хранится в файле журнала, а является частью "
"самого пула. Команда для просмотра этой истории называется `zpool history`:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1375
#, no-wrap
msgid ""
"# zpool history\n"
"History for 'tank':\n"
"2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1\n"
"2013-02-27.18:50:58 zfs set atime=off tank\n"
"2013-02-27.18:51:09 zfs set checksum=fletcher4 tank\n"
"2013-02-27.18:51:18 zfs create tank/backup\n"
msgstr ""
"# zpool history\n"
"History for 'tank':\n"
"2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1\n"
"2013-02-27.18:50:58 zfs set atime=off tank\n"
"2013-02-27.18:51:09 zfs set checksum=fletcher4 tank\n"
"2013-02-27.18:51:18 zfs create tank/backup\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1380
msgid ""
"The output shows `zpool` and `zfs` commands altering the pool in some way "
"along with a timestamp.  Commands like `zfs list` are not included.  When "
"specifying no pool name, ZFS displays history of all pools."
msgstr ""
"Вывод показывает команды `zpool` и `zfs`, изменяющие пул каким-либо образом, "
"вместе с временной меткой. Команды вроде `zfs list` не включаются. Если имя "
"пула не указано, ZFS отображает историю всех пулов."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1383
msgid ""
"`zpool history` can show even more information when providing the options `-"
"i` or `-l`.  `-i` displays user-initiated events as well as internally "
"logged ZFS events."
msgstr ""
"`zpool history` может отображать еще больше информации при использовании "
"опций `-i` или `-l`. Опция `-i` показывает события, инициированные "
"пользователем, а также внутренние события ZFS, зарегистрированные в журнале."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1395
#, no-wrap
msgid ""
"# zpool history -i\n"
"History for 'tank':\n"
"2013-02-26.23:02:35 [internal pool create txg:5] pool spa 28; zfs spa 28; zpl 5;uts  9.1-RELEASE 901000 amd64\n"
"2013-02-27.18:50:53 [internal property set txg:50] atime=0 dataset = 21\n"
"2013-02-27.18:50:58 zfs set atime=off tank\n"
"2013-02-27.18:51:04 [internal property set txg:53] checksum=7 dataset = 21\n"
"2013-02-27.18:51:09 zfs set checksum=fletcher4 tank\n"
"2013-02-27.18:51:13 [internal create txg:55] dataset = 39\n"
"2013-02-27.18:51:18 zfs create tank/backup\n"
msgstr ""
"# zpool history -i\n"
"History for 'tank':\n"
"2013-02-26.23:02:35 [internal pool create txg:5] pool spa 28; zfs spa 28; zpl 5;uts  9.1-RELEASE 901000 amd64\n"
"2013-02-27.18:50:53 [internal property set txg:50] atime=0 dataset = 21\n"
"2013-02-27.18:50:58 zfs set atime=off tank\n"
"2013-02-27.18:51:04 [internal property set txg:53] checksum=7 dataset = 21\n"
"2013-02-27.18:51:09 zfs set checksum=fletcher4 tank\n"
"2013-02-27.18:51:13 [internal create txg:55] dataset = 39\n"
"2013-02-27.18:51:18 zfs create tank/backup\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1399
msgid ""
"Show more details by adding `-l`.  Showing history records in a long format, "
"including information like the name of the user who issued the command and "
"the hostname on which the change happened."
msgstr ""
"Показать более подробную информацию, добавив `-l`.  Отображение записей "
"истории в длинном формате, включая такие сведения, как имя пользователя, "
"выполнившего команду, и имя хоста, на котором произошло изменение."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1408
#, no-wrap
msgid ""
"# zpool history -l\n"
"History for 'tank':\n"
"2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1 [user 0 (root) on :global]\n"
"2013-02-27.18:50:58 zfs set atime=off tank [user 0 (root) on myzfsbox:global]\n"
"2013-02-27.18:51:09 zfs set checksum=fletcher4 tank [user 0 (root) on myzfsbox:global]\n"
"2013-02-27.18:51:18 zfs create tank/backup [user 0 (root) on myzfsbox:global]\n"
msgstr ""
"# zpool history -l\n"
"History for 'tank':\n"
"2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1 [user 0 (root) on :global]\n"
"2013-02-27.18:50:58 zfs set atime=off tank [user 0 (root) on myzfsbox:global]\n"
"2013-02-27.18:51:09 zfs set checksum=fletcher4 tank [user 0 (root) on myzfsbox:global]\n"
"2013-02-27.18:51:18 zfs create tank/backup [user 0 (root) on myzfsbox:global]\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1414
msgid ""
"The output shows that the `root` user created the mirrored pool with disks [."
"filename]#/dev/ada0# and [.filename]#/dev/ada1#.  The hostname `myzfsbox` is "
"also shown in the commands after the pool's creation.  The hostname display "
"becomes important when exporting the pool from one system and importing on "
"another.  It's possible to distinguish the commands issued on the other "
"system by the hostname recorded for each command."
msgstr ""
"Вывод показывает, что пользователь `root` создал зеркальный пул с дисками [."
"filename]#/dev/ada0# и [.filename]#/dev/ada1#. Также в командах после "
"создания пула отображается имя хоста `myzfsbox`. Отображение имени хоста "
"становится важным при экспорте пула с одной системы и импорте на другую. "
"Можно различить команды, выполненные на другой системе, по имени хоста, "
"записанному для каждой команды."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1417
msgid ""
"Combine both options to `zpool history` to give the most detailed "
"information possible for any given pool.  Pool history provides valuable "
"information when tracking down the actions performed or when needing more "
"detailed output for debugging."
msgstr ""
"Объедините оба варианта с `zpool history`, чтобы получить максимально "
"детальную информацию для любого заданного пула. История пула предоставляет "
"ценную информацию при отслеживании выполненных действий или необходимости "
"более детального вывода для отладки."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1419
#, no-wrap
msgid "Performance Monitoring"
msgstr "Мониторинг производительности"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1426
msgid ""
"A built-in monitoring system can display pool I/O statistics in real time.  "
"It shows the amount of free and used space on the pool, read and write "
"operations performed per second, and I/O bandwidth used.  By default, ZFS "
"monitors and displays all pools in the system.  Provide a pool name to limit "
"monitoring to that pool.  A basic example:"
msgstr ""
"Встроенная система мониторинга может отображать статистику операций ввода-"
"вывода пула в реальном времени. Она показывает объем свободного и занятого "
"пространства в пуле, количество операций чтения и записи в секунду, а также "
"используемую пропускную способность ввода-вывода. По умолчанию ZFS "
"отслеживает и отображает все пулы в системе. Укажите имя пула, чтобы "
"ограничить мониторинг только этим пулом. Простой пример:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1434
#, no-wrap
msgid ""
"# zpool iostat\n"
"               capacity     operations    bandwidth\n"
"pool        alloc   free   read  write   read  write\n"
"----------  -----  -----  -----  -----  -----  -----\n"
"data         288G  1.53T      2     11  11.3K  57.1K\n"
msgstr ""
"# zpool iostat\n"
"               capacity     operations    bandwidth\n"
"pool        alloc   free   read  write   read  write\n"
"----------  -----  -----  -----  -----  -----  -----\n"
"data         288G  1.53T      2     11  11.3K  57.1K\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1440
msgid ""
"To continuously see I/O activity, specify a number as the last parameter, "
"indicating an interval in seconds to wait between updates.  The next "
"statistic line prints after each interval.  Press kbd:[Ctrl+C] to stop this "
"continuous monitoring.  Give a second number on the command line after the "
"interval to specify the total number of statistics to display."
msgstr ""
"Чтобы непрерывно отслеживать активность ввода-вывода, укажите число в "
"качестве последнего параметра, задающее интервал в секундах между "
"обновлениями. Следующая строка статистики выводится после каждого интервала. "
"Нажмите kbd:[Ctrl+C], чтобы остановить непрерывный мониторинг. Укажите "
"второе число в командной строке после интервала, чтобы задать общее "
"количество отображаемой статистики."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1445
msgid ""
"Display even more detailed I/O statistics with `-v`.  Each device in the "
"pool appears with a statistics line.  This is useful for seeing read and "
"write operations performed on each device, and can help determine if any "
"individual device is slowing down the pool.  This example shows a mirrored "
"pool with two devices:"
msgstr ""
"Отображать более детальную статистику ввода-вывода с помощью `-v`. Каждое "
"устройство в пуле отображается с отдельной строкой статистики. Это полезно "
"для просмотра операций чтения и записи, выполняемых на каждом устройстве, и "
"может помочь определить, замедляет ли какое-либо отдельное устройство работу "
"пула. В этом примере показан зеркальный пул с двумя устройствами:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1457
#, no-wrap
msgid ""
"# zpool iostat -v\n"
"                            capacity     operations    bandwidth\n"
"pool                     alloc   free   read  write   read  write\n"
"-----------------------  -----  -----  -----  -----  -----  -----\n"
"data                      288G  1.53T      2     12  9.23K  61.5K\n"
"  mirror                  288G  1.53T      2     12  9.23K  61.5K\n"
"    ada1                     -      -      0      4  5.61K  61.7K\n"
"    ada2                     -      -      1      4  5.04K  61.7K\n"
"-----------------------  -----  -----  -----  -----  -----  -----\n"
msgstr ""
"# zpool iostat -v\n"
"                            capacity     operations    bandwidth\n"
"pool                     alloc   free   read  write   read  write\n"
"-----------------------  -----  -----  -----  -----  -----  -----\n"
"data                      288G  1.53T      2     12  9.23K  61.5K\n"
"  mirror                  288G  1.53T      2     12  9.23K  61.5K\n"
"    ada1                     -      -      0      4  5.61K  61.7K\n"
"    ada2                     -      -      1      4  5.04K  61.7K\n"
"-----------------------  -----  -----  -----  -----  -----  -----\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1460
#, no-wrap
msgid "Splitting a Storage Pool"
msgstr "Разделение пула хранения данных"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1467
msgid ""
"ZFS can split a pool consisting of one or more mirror vdevs into two pools.  "
"Unless otherwise specified, ZFS detaches the last member of each mirror and "
"creates a new pool containing the same data.  Be sure to make a dry run of "
"the operation with `-n` first.  This displays the details of the requested "
"operation without actually performing it.  This helps confirm that the "
"operation will do what the user intends."
msgstr ""
"ZFS может разделить пул, состоящий из одного или нескольких зеркальных vdev, "
"на два пула. Если не указано иное, ZFS отсоединяет последний элемент каждого "
"зеркала и создает новый пул с теми же данными. Обязательно выполните пробный "
"запуск операции с параметром `-n` сначала. Это отобразит детали запрошенной "
"операции без её фактического выполнения. Это помогает убедиться, что "
"операция выполнит то, что задумал пользователь."

#. type: Title ==
#: documentation/content/en/books/handbook/zfs/_index.adoc:1469
#, no-wrap
msgid "`zfs` Administration"
msgstr "Управление с помощью утилиты`zfs`"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1473
msgid ""
"The `zfs` utility can create, destroy, and manage all existing ZFS datasets "
"within a pool.  To manage the pool itself, use crossref:zfs[zfs-zpool,"
"`zpool`]."
msgstr ""
"Утилита `zfs` позволяет создавать, удалять и управлять всеми существующими "
"наборами данных ZFS в пределах пула. Для управления самим пулом используйте "
"crossref:zfs[zfs-zpool,`zpool`]."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1475
#, no-wrap
msgid "Creating and Destroying Datasets"
msgstr "Создание и удаление наборов данных"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1486
msgid ""
"Unlike traditional disks and volume managers, space in ZFS is _not_ "
"preallocated.  With traditional file systems, after partitioning and "
"assigning the space, there is no way to add a new file system without adding "
"a new disk.  With ZFS, creating new file systems is possible at any time.  "
"Each crossref:zfs[zfs-term-dataset,_dataset_] has properties including "
"features like compression, deduplication, caching, and quotas, as well as "
"other useful properties like readonly, case sensitivity, network file "
"sharing, and a mount point.  Nesting datasets within each other is possible "
"and child datasets will inherit properties from their ancestors.  crossref:"
"zfs[zfs-zfs-allow,Delegate], crossref:zfs[zfs-zfs-send,replicate], crossref:"
"zfs[zfs-zfs-snapshot,snapshot], crossref:zfs[zfs-zfs-jail,jail] allows "
"administering and destroying each dataset as a unit.  Creating a separate "
"dataset for each different type or set of files has advantages.  The "
"drawbacks to having a large number of datasets are that some commands like "
"`zfs list` will be slower, and that mounting of hundreds or even thousands "
"of datasets will slow the FreeBSD boot process."
msgstr ""
"В отличие от традиционных дисков и менеджеров томов, пространство в ZFS _не_ "
"выделяется заранее. В традиционных файловых системах после разметки и "
"выделения пространства невозможно добавить новую файловую систему без "
"добавления нового диска. В ZFS создание новых файловых систем возможно в "
"любое время. Каждый crossref:zfs[zfs-term-dataset,_набор данных_] обладает "
"свойствами, включая такие функции, как сжатие, дедупликация, кэширование и "
"квоты, а также другие полезные свойства, такие как режим только для чтения, "
"чувствительность к регистру, сетевое общее использование файлов и точка "
"монтирования. Возможно вложение наборов данных друг в друга, при этом "
"дочерние наборы данных наследуют свойства от своих родительских. crossref:"
"zfs[zfs-zfs-allow,Делегирование], crossref:zfs[zfs-zfs-send,репликация], "
"crossref:zfs[zfs-zfs-snapshot,снимки], crossref:zfs[zfs-zfs-jail,клетки] "
"позволяют администрировать и уничтожать каждый набор данных как единое "
"целое. Создание отдельного набора данных для каждого типа или группы файлов "
"имеет свои преимущества. Недостатком наличия большого количества наборов "
"данных является то, что некоторые команды, такие как `zfs list`, будут "
"выполняться медленнее, а монтирование сотен или даже тысяч наборов данных "
"замедлит процесс загрузки FreeBSD."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1488
msgid ""
"Create a new dataset and enable crossref:zfs[zfs-term-compression-lz4,LZ4 "
"compression] on it:"
msgstr ""
"Создайте новый набор данных и включите для него crossref:zfs[zfs-term-"
"compression-lz4,сжатие LZ4]:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1523
#, no-wrap
msgid ""
"# zfs list\n"
"NAME                  USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                781M  93.2G   144K  none\n"
"mypool/ROOT           777M  93.2G   144K  none\n"
"mypool/ROOT/default   777M  93.2G   777M  /\n"
"mypool/tmp            176K  93.2G   176K  /tmp\n"
"mypool/usr            616K  93.2G   144K  /usr\n"
"mypool/usr/home       184K  93.2G   184K  /usr/home\n"
"mypool/usr/ports      144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src        144K  93.2G   144K  /usr/src\n"
"mypool/var           1.20M  93.2G   608K  /var\n"
"mypool/var/crash      148K  93.2G   148K  /var/crash\n"
"mypool/var/log        178K  93.2G   178K  /var/log\n"
"mypool/var/mail       144K  93.2G   144K  /var/mail\n"
"mypool/var/tmp        152K  93.2G   152K  /var/tmp\n"
"# zfs create -o compress=lz4 mypool/usr/mydataset\n"
"# zfs list\n"
"NAME                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                 781M  93.2G   144K  none\n"
"mypool/ROOT            777M  93.2G   144K  none\n"
"mypool/ROOT/default    777M  93.2G   777M  /\n"
"mypool/tmp             176K  93.2G   176K  /tmp\n"
"mypool/usr             704K  93.2G   144K  /usr\n"
"mypool/usr/home        184K  93.2G   184K  /usr/home\n"
"mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset\n"
"mypool/usr/ports       144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src         144K  93.2G   144K  /usr/src\n"
"mypool/var            1.20M  93.2G   610K  /var\n"
"mypool/var/crash       148K  93.2G   148K  /var/crash\n"
"mypool/var/log         178K  93.2G   178K  /var/log\n"
"mypool/var/mail        144K  93.2G   144K  /var/mail\n"
"mypool/var/tmp         152K  93.2G   152K  /var/tmp\n"
msgstr ""
"# zfs list\n"
"NAME                  USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                781M  93.2G   144K  none\n"
"mypool/ROOT           777M  93.2G   144K  none\n"
"mypool/ROOT/default   777M  93.2G   777M  /\n"
"mypool/tmp            176K  93.2G   176K  /tmp\n"
"mypool/usr            616K  93.2G   144K  /usr\n"
"mypool/usr/home       184K  93.2G   184K  /usr/home\n"
"mypool/usr/ports      144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src        144K  93.2G   144K  /usr/src\n"
"mypool/var           1.20M  93.2G   608K  /var\n"
"mypool/var/crash      148K  93.2G   148K  /var/crash\n"
"mypool/var/log        178K  93.2G   178K  /var/log\n"
"mypool/var/mail       144K  93.2G   144K  /var/mail\n"
"mypool/var/tmp        152K  93.2G   152K  /var/tmp\n"
"# zfs create -o compress=lz4 mypool/usr/mydataset\n"
"# zfs list\n"
"NAME                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                 781M  93.2G   144K  none\n"
"mypool/ROOT            777M  93.2G   144K  none\n"
"mypool/ROOT/default    777M  93.2G   777M  /\n"
"mypool/tmp             176K  93.2G   176K  /tmp\n"
"mypool/usr             704K  93.2G   144K  /usr\n"
"mypool/usr/home        184K  93.2G   184K  /usr/home\n"
"mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset\n"
"mypool/usr/ports       144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src         144K  93.2G   144K  /usr/src\n"
"mypool/var            1.20M  93.2G   610K  /var\n"
"mypool/var/crash       148K  93.2G   148K  /var/crash\n"
"mypool/var/log         178K  93.2G   178K  /var/log\n"
"mypool/var/mail        144K  93.2G   144K  /var/mail\n"
"mypool/var/tmp         152K  93.2G   152K  /var/tmp\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1526
msgid ""
"Destroying a dataset is much quicker than deleting the files on the dataset, "
"as it does not involve scanning the files and updating the corresponding "
"metadata."
msgstr ""
"Уничтожение набора данных выполняется гораздо быстрее, чем удаление файлов в "
"наборе данных, так как не требует сканирования файлов и обновления "
"соответствующих метаданных."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1528
msgid "Destroy the created dataset:"
msgstr "Уничтожьте созданный набор данных:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1563
#, no-wrap
msgid ""
"# zfs list\n"
"NAME                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                 880M  93.1G   144K  none\n"
"mypool/ROOT            777M  93.1G   144K  none\n"
"mypool/ROOT/default    777M  93.1G   777M  /\n"
"mypool/tmp             176K  93.1G   176K  /tmp\n"
"mypool/usr             101M  93.1G   144K  /usr\n"
"mypool/usr/home        184K  93.1G   184K  /usr/home\n"
"mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset\n"
"mypool/usr/ports       144K  93.1G   144K  /usr/ports\n"
"mypool/usr/src         144K  93.1G   144K  /usr/src\n"
"mypool/var            1.20M  93.1G   610K  /var\n"
"mypool/var/crash       148K  93.1G   148K  /var/crash\n"
"mypool/var/log         178K  93.1G   178K  /var/log\n"
"mypool/var/mail        144K  93.1G   144K  /var/mail\n"
"mypool/var/tmp         152K  93.1G   152K  /var/tmp\n"
"# zfs destroy mypool/usr/mydataset\n"
"# zfs list\n"
"NAME                  USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                781M  93.2G   144K  none\n"
"mypool/ROOT           777M  93.2G   144K  none\n"
"mypool/ROOT/default   777M  93.2G   777M  /\n"
"mypool/tmp            176K  93.2G   176K  /tmp\n"
"mypool/usr            616K  93.2G   144K  /usr\n"
"mypool/usr/home       184K  93.2G   184K  /usr/home\n"
"mypool/usr/ports      144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src        144K  93.2G   144K  /usr/src\n"
"mypool/var           1.21M  93.2G   612K  /var\n"
"mypool/var/crash      148K  93.2G   148K  /var/crash\n"
"mypool/var/log        178K  93.2G   178K  /var/log\n"
"mypool/var/mail       144K  93.2G   144K  /var/mail\n"
"mypool/var/tmp        152K  93.2G   152K  /var/tmp\n"
msgstr ""
"# zfs list\n"
"NAME                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                 880M  93.1G   144K  none\n"
"mypool/ROOT            777M  93.1G   144K  none\n"
"mypool/ROOT/default    777M  93.1G   777M  /\n"
"mypool/tmp             176K  93.1G   176K  /tmp\n"
"mypool/usr             101M  93.1G   144K  /usr\n"
"mypool/usr/home        184K  93.1G   184K  /usr/home\n"
"mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset\n"
"mypool/usr/ports       144K  93.1G   144K  /usr/ports\n"
"mypool/usr/src         144K  93.1G   144K  /usr/src\n"
"mypool/var            1.20M  93.1G   610K  /var\n"
"mypool/var/crash       148K  93.1G   148K  /var/crash\n"
"mypool/var/log         178K  93.1G   178K  /var/log\n"
"mypool/var/mail        144K  93.1G   144K  /var/mail\n"
"mypool/var/tmp         152K  93.1G   152K  /var/tmp\n"
"# zfs destroy mypool/usr/mydataset\n"
"# zfs list\n"
"NAME                  USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                781M  93.2G   144K  none\n"
"mypool/ROOT           777M  93.2G   144K  none\n"
"mypool/ROOT/default   777M  93.2G   777M  /\n"
"mypool/tmp            176K  93.2G   176K  /tmp\n"
"mypool/usr            616K  93.2G   144K  /usr\n"
"mypool/usr/home       184K  93.2G   184K  /usr/home\n"
"mypool/usr/ports      144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src        144K  93.2G   144K  /usr/src\n"
"mypool/var           1.21M  93.2G   612K  /var\n"
"mypool/var/crash      148K  93.2G   148K  /var/crash\n"
"mypool/var/log        178K  93.2G   178K  /var/log\n"
"mypool/var/mail       144K  93.2G   144K  /var/mail\n"
"mypool/var/tmp        152K  93.2G   152K  /var/tmp\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1571
msgid ""
"In modern versions of ZFS, `zfs destroy` is asynchronous, and the free space "
"might take minutes to appear in the pool.  Use `zpool get freeing "
"_poolname_` to see the `freeing` property, that shows which datasets are "
"having their blocks freed in the background.  If there are child datasets, "
"like crossref:zfs[zfs-term-snapshot,snapshots] or other datasets, destroying "
"the parent is impossible.  To destroy a dataset and its children, use `-r` "
"to recursively destroy the dataset and its children.  Use `-n -v` to list "
"datasets and snapshots destroyed by this operation, without actually destroy "
"anything.  Space reclaimed by destroying snapshots is also shown."
msgstr ""
"В современных версиях ZFS команда `zfs destroy` выполняется асинхронно, и "
"освобождённое пространство может появиться в пуле только через несколько "
"минут. Используйте `zpool get freeing _имяпула_` для просмотра свойства "
"`freeing`, которое показывает, какие наборы данных освобождают свои блоки в "
"фоновом режиме. Если существуют дочерние наборы данных, например crossref:"
"zfs[zfs-term-snapshot,снимки] или другие наборы данных, уничтожение "
"родительского набора невозможно. Для удаления набора данных и его дочерних "
"элементов используйте `-r`, чтобы рекурсивно удалить набор данных и его "
"потомков. Опция `-n -v` позволяет вывести список наборов данных и снимков, "
"которые будут удалены данной операцией, без фактического выполнения "
"удаления. Также отображается пространство, которое будет освобождено после "
"удаления снимков."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1573
#, no-wrap
msgid "Creating and Destroying Volumes"
msgstr "Создание и удаление томов"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1578
msgid ""
"A volume is a special dataset type.  Rather than mounting as a file system, "
"expose it as a block device under [.filename]#/dev/zvol/poolname/dataset#.  "
"This allows using the volume for other file systems, to back the disks of a "
"virtual machine, or to make it available to other network hosts using "
"protocols like iSCSI or HAST."
msgstr ""
"Том — это особый тип набора данных. Вместо монтирования в качестве файловой "
"системы он представляется как блочное устройство в [.filename]#/dev/zvol/"
"имя_пула/набор_данных#. Это позволяет использовать том для других файловых "
"систем, в качестве дисков для виртуальной машины или сделать его доступным "
"для других сетевых узлов с использованием таких протоколов, как iSCSI или "
"HAST."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1583
msgid ""
"Format a volume with any file system or without a file system to store raw "
"data.  To the user, a volume appears to be a regular disk.  Putting ordinary "
"file systems on these _zvols_ provides features that ordinary disks or file "
"systems do not have.  For example, using the compression property on a 250 "
"MB volume allows creation of a compressed FAT file system."
msgstr ""
"Отформатируйте том с любой файловой системой или без файловой системы для "
"хранения сырых данных. Для пользователя том выглядит как обычный диск. "
"Размещение обычных файловых систем на этих _zvols_ предоставляет "
"возможности, которых нет у обычных дисков или файловых систем. Например, "
"использование свойства сжатия на томе объёмом 250 МБ позволяет создать "
"сжатую файловую систему FAT."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1597
#, no-wrap
msgid ""
"# zfs create -V 250m -o compression=on tank/fat32\n"
"# zfs list tank\n"
"NAME USED AVAIL REFER MOUNTPOINT\n"
"tank 258M  670M   31K /tank\n"
"# newfs_msdos -F32 /dev/zvol/tank/fat32\n"
"# mount -t msdosfs /dev/zvol/tank/fat32 /mnt\n"
"# df -h /mnt | grep fat32\n"
"Filesystem           Size Used Avail Capacity Mounted on\n"
"/dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt\n"
"# mount | grep fat32\n"
"/dev/zvol/tank/fat32 on /mnt (msdosfs, local)\n"
msgstr ""
"# zfs create -V 250m -o compression=on tank/fat32\n"
"# zfs list tank\n"
"NAME USED AVAIL REFER MOUNTPOINT\n"
"tank 258M  670M   31K /tank\n"
"# newfs_msdos -F32 /dev/zvol/tank/fat32\n"
"# mount -t msdosfs /dev/zvol/tank/fat32 /mnt\n"
"# df -h /mnt | grep fat32\n"
"Filesystem           Size Used Avail Capacity Mounted on\n"
"/dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt\n"
"# mount | grep fat32\n"
"/dev/zvol/tank/fat32 on /mnt (msdosfs, local)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1601
msgid ""
"Destroying a volume is much the same as destroying a regular file system "
"dataset.  The operation is nearly instantaneous, but it may take minutes to "
"reclaim the free space in the background."
msgstr ""
"Уничтожение тома во многом аналогично уничтожению обычного набора данных "
"файловой системы. Операция выполняется почти мгновенно, но освобождение "
"места может занять несколько минут и происходит в фоновом режиме."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1603
#, no-wrap
msgid "Renaming a Dataset"
msgstr "Переименование набора данных"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1610
msgid ""
"To change the name of a dataset, use `zfs rename`.  To change the parent of "
"a dataset, use this command as well.  Renaming a dataset to have a different "
"parent dataset will change the value of those properties inherited from the "
"parent dataset.  Renaming a dataset unmounts then remounts it in the new "
"location (inherited from the new parent dataset).  To prevent this behavior, "
"use `-u`."
msgstr ""
"Для изменения имени набора данных используйте `zfs rename`. Эту же команду "
"можно использовать для изменения родительского набора данных. Переименование "
"набора данных с изменением родительского набора приведёт к изменению "
"значений свойств, унаследованных от родительского набора данных. "
"Переименование набора данных размонтирует, а затем снова смонтирует его в "
"новом месте (с учётом наследования от нового родительского набора данных). "
"Чтобы предотвратить это поведение, используйте опцию `-u`."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1612
msgid "Rename a dataset and move it to be under a different parent dataset:"
msgstr ""
"Переименовать набор данных и переместить его под другой родительский набор "
"данных:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1648
#, no-wrap
msgid ""
"# zfs list\n"
"NAME                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                 780M  93.2G   144K  none\n"
"mypool/ROOT            777M  93.2G   144K  none\n"
"mypool/ROOT/default    777M  93.2G   777M  /\n"
"mypool/tmp             176K  93.2G   176K  /tmp\n"
"mypool/usr             704K  93.2G   144K  /usr\n"
"mypool/usr/home        184K  93.2G   184K  /usr/home\n"
"mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset\n"
"mypool/usr/ports       144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src         144K  93.2G   144K  /usr/src\n"
"mypool/var            1.21M  93.2G   614K  /var\n"
"mypool/var/crash       148K  93.2G   148K  /var/crash\n"
"mypool/var/log         178K  93.2G   178K  /var/log\n"
"mypool/var/mail        144K  93.2G   144K  /var/mail\n"
"mypool/var/tmp         152K  93.2G   152K  /var/tmp\n"
"# zfs rename mypool/usr/mydataset mypool/var/newname\n"
"# zfs list\n"
"NAME                  USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                780M  93.2G   144K  none\n"
"mypool/ROOT           777M  93.2G   144K  none\n"
"mypool/ROOT/default   777M  93.2G   777M  /\n"
"mypool/tmp            176K  93.2G   176K  /tmp\n"
"mypool/usr            616K  93.2G   144K  /usr\n"
"mypool/usr/home       184K  93.2G   184K  /usr/home\n"
"mypool/usr/ports      144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src        144K  93.2G   144K  /usr/src\n"
"mypool/var           1.29M  93.2G   614K  /var\n"
"mypool/var/crash      148K  93.2G   148K  /var/crash\n"
"mypool/var/log        178K  93.2G   178K  /var/log\n"
"mypool/var/mail       144K  93.2G   144K  /var/mail\n"
"mypool/var/newname   87.5K  93.2G  87.5K  /var/newname\n"
"mypool/var/tmp        152K  93.2G   152K  /var/tmp\n"
msgstr ""
"# zfs list\n"
"NAME                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                 780M  93.2G   144K  none\n"
"mypool/ROOT            777M  93.2G   144K  none\n"
"mypool/ROOT/default    777M  93.2G   777M  /\n"
"mypool/tmp             176K  93.2G   176K  /tmp\n"
"mypool/usr             704K  93.2G   144K  /usr\n"
"mypool/usr/home        184K  93.2G   184K  /usr/home\n"
"mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset\n"
"mypool/usr/ports       144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src         144K  93.2G   144K  /usr/src\n"
"mypool/var            1.21M  93.2G   614K  /var\n"
"mypool/var/crash       148K  93.2G   148K  /var/crash\n"
"mypool/var/log         178K  93.2G   178K  /var/log\n"
"mypool/var/mail        144K  93.2G   144K  /var/mail\n"
"mypool/var/tmp         152K  93.2G   152K  /var/tmp\n"
"# zfs rename mypool/usr/mydataset mypool/var/newname\n"
"# zfs list\n"
"NAME                  USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                780M  93.2G   144K  none\n"
"mypool/ROOT           777M  93.2G   144K  none\n"
"mypool/ROOT/default   777M  93.2G   777M  /\n"
"mypool/tmp            176K  93.2G   176K  /tmp\n"
"mypool/usr            616K  93.2G   144K  /usr\n"
"mypool/usr/home       184K  93.2G   184K  /usr/home\n"
"mypool/usr/ports      144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src        144K  93.2G   144K  /usr/src\n"
"mypool/var           1.29M  93.2G   614K  /var\n"
"mypool/var/crash      148K  93.2G   148K  /var/crash\n"
"mypool/var/log        178K  93.2G   178K  /var/log\n"
"mypool/var/mail       144K  93.2G   144K  /var/mail\n"
"mypool/var/newname   87.5K  93.2G  87.5K  /var/newname\n"
"mypool/var/tmp        152K  93.2G   152K  /var/tmp\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1653
msgid ""
"Renaming snapshots uses the same command.  Due to the nature of snapshots, "
"rename cannot change their parent dataset.  To rename a recursive snapshot, "
"specify `-r`; this will also rename all snapshots with the same name in "
"child datasets."
msgstr ""
"Переименование снимков выполняется той же командой. Из-за особенностей "
"снимков, их переименование не может изменить родительский набор данных. Для "
"рекурсивного переименования снимка укажите `-r`; это также переименует все "
"снимки с таким же именем в дочерних наборах данных."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1663
#, no-wrap
msgid ""
"# zfs list -t snapshot\n"
"NAME                                USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/newname@first_snapshot      0      -  87.5K  -\n"
"# zfs rename mypool/var/newname@first_snapshot new_snapshot_name\n"
"# zfs list -t snapshot\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/newname@new_snapshot_name      0      -  87.5K  -\n"
msgstr ""
"# zfs list -t snapshot\n"
"NAME                                USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/newname@first_snapshot      0      -  87.5K  -\n"
"# zfs rename mypool/var/newname@first_snapshot new_snapshot_name\n"
"# zfs list -t snapshot\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/newname@new_snapshot_name      0      -  87.5K  -\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1666
#, no-wrap
msgid "Setting Dataset Properties"
msgstr "Установка свойств наборов данных"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1676
msgid ""
"Each ZFS dataset has properties that control its behavior.  Most properties "
"are automatically inherited from the parent dataset, but can be overridden "
"locally.  Set a property on a dataset with `zfs set _property=value "
"dataset_`.  Most properties have a limited set of valid values, `zfs get` "
"will display each possible property and valid values.  Using `zfs inherit` "
"reverts most properties to their inherited values.  User-defined properties "
"are also possible.  They become part of the dataset configuration and "
"provide further information about the dataset or its contents.  To "
"distinguish these custom properties from the ones supplied as part of ZFS, "
"use a colon (`:`) to create a custom namespace for the property."
msgstr ""
"Каждый набор данных ZFS имеет свойства, которые определяют его поведение. "
"Большинство свойств автоматически наследуются от родительского набора "
"данных, но могут быть переопределены локально. Установите свойство для "
"набора данных с помощью `zfs set _свойство=значение набор_данных_`. "
"Большинство свойств имеют ограниченный набор допустимых значений, `zfs get` "
"отобразит каждое возможное свойство и допустимые значения. Использование "
"`zfs inherit` возвращает большинство свойств к их унаследованным значениям. "
"Также возможны пользовательские свойства. Они становятся частью конфигурации "
"набора данных и предоставляют дополнительную информацию о наборе данных или "
"его содержимом. Чтобы отличить эти пользовательские свойства от встроенных в "
"ZFS, используйте двоеточие (`:`), чтобы создать пользовательское "
"пространство имён для свойства."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1683
#, no-wrap
msgid ""
"# zfs set custom:costcenter=1234 tank\n"
"# zfs get custom:costcenter tank\n"
"NAME PROPERTY           VALUE SOURCE\n"
"tank custom:costcenter  1234  local\n"
msgstr ""
"# zfs set custom:costcenter=1234 tank\n"
"# zfs get custom:costcenter tank\n"
"NAME PROPERTY           VALUE SOURCE\n"
"tank custom:costcenter  1234  local\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1687
msgid ""
"To remove a custom property, use `zfs inherit` with `-r`.  If the custom "
"property is not defined in any of the parent datasets, this option removes "
"it (but the pool's history still records the change)."
msgstr ""
"Чтобы удалить пользовательское свойство, используйте `zfs inherit` с "
"параметром `-r`. Если пользовательское свойство не определено ни в одном из "
"родительских наборов данных, эта опция удаляет его (но история пула всё "
"равно сохраняет запись об изменении)."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1696
#, no-wrap
msgid ""
"# zfs inherit -r custom:costcenter tank\n"
"# zfs get custom:costcenter tank\n"
"NAME    PROPERTY           VALUE              SOURCE\n"
"tank    custom:costcenter  -                  -\n"
"# zfs get all tank | grep custom:costcenter\n"
"#\n"
msgstr ""
"# zfs inherit -r custom:costcenter tank\n"
"# zfs get custom:costcenter tank\n"
"NAME    PROPERTY           VALUE              SOURCE\n"
"tank    custom:costcenter  -                  -\n"
"# zfs get all tank | grep custom:costcenter\n"
"#\n"

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:1699
#, no-wrap
msgid "Getting and Setting Share Properties"
msgstr "Получение и установка свойств общего доступа"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1705
msgid ""
"Two commonly used and useful dataset properties are the NFS and SMB share "
"options.  Setting these defines if and how ZFS shares datasets on the "
"network.  At present, FreeBSD supports setting NFS sharing alone.  To get "
"the current status of a share, enter:"
msgstr ""
"Два часто используемых и полезных свойства наборов данных — это параметры "
"общих ресурсов NFS и SMB. Установка этих параметров определяет, будет ли ZFS "
"предоставлять наборы данных в сети и как именно. В настоящее время FreeBSD "
"поддерживает настройку только общего доступа NFS. Чтобы проверить текущее "
"состояние общего ресурса, введите:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1714
#, no-wrap
msgid ""
"# zfs get sharenfs mypool/usr/home\n"
"NAME             PROPERTY  VALUE    SOURCE\n"
"mypool/usr/home  sharenfs  on       local\n"
"# zfs get sharesmb mypool/usr/home\n"
"NAME             PROPERTY  VALUE    SOURCE\n"
"mypool/usr/home  sharesmb  off      local\n"
msgstr ""
"# zfs get sharenfs mypool/usr/home\n"
"NAME             PROPERTY  VALUE    SOURCE\n"
"mypool/usr/home  sharenfs  on       local\n"
"# zfs get sharesmb mypool/usr/home\n"
"NAME             PROPERTY  VALUE    SOURCE\n"
"mypool/usr/home  sharesmb  off      local\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1717
msgid "To enable sharing of a dataset, enter:"
msgstr "Чтобы включить общий доступ к набору данных, введите:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1721
#, no-wrap
msgid "#  zfs set sharenfs=on mypool/usr/home\n"
msgstr "#  zfs set sharenfs=on mypool/usr/home\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1725
msgid ""
"Set other options for sharing datasets through NFS, such as `-alldirs`, `-"
"maproot` and `-network`.  To set options on a dataset shared through NFS, "
"enter:"
msgstr ""
"Установите другие параметры для общего доступа к наборам данных через NFS, "
"такие как `-alldirs`, `-maproot` и `-network`. Чтобы задать параметры для "
"набора данных, доступного через NFS, введите:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1729
#, no-wrap
msgid "#  zfs set sharenfs=\"-alldirs,-maproot=root,-network=192.168.1.0/24\" mypool/usr/home\n"
msgstr "#  zfs set sharenfs=\"-alldirs,-maproot=root,-network=192.168.1.0/24\" mypool/usr/home\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:1732
#, no-wrap
msgid "Managing Snapshots"
msgstr "Управление снимками"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1746
msgid ""
"crossref:zfs[zfs-term-snapshot,Snapshots] are one of the most powerful "
"features of ZFS.  A snapshot provides a read-only, point-in-time copy of the "
"dataset.  With Copy-On-Write (COW), ZFS creates snapshots fast by preserving "
"older versions of the data on disk.  If no snapshots exist, ZFS reclaims "
"space for future use when data is rewritten or deleted.  Snapshots preserve "
"disk space by recording just the differences between the current dataset and "
"a previous version.  Allowing snapshots on whole datasets, not on individual "
"files or directories.  A snapshot from a dataset duplicates everything "
"contained in it.  This includes the file system properties, files, "
"directories, permissions, and so on.  Snapshots use no extra space when "
"first created, but consume space as the blocks they reference change.  "
"Recursive snapshots taken with `-r` create snapshots with the same name on "
"the dataset and its children, providing a consistent moment-in-time snapshot "
"of the file systems.  This can be important when an application has files on "
"related datasets or that depend upon each other.  Without snapshots, a "
"backup would have copies of the files from different points in time."
msgstr ""
"crossref:zfs[zfs-term-snapshot,Снимки] — одна из самых мощных функций ZFS. "
"Снимок предоставляет доступную только для чтения копию набора данных на "
"определённый момент времени. Благодаря механизму Copy-On-Write (COW), ZFS "
"быстро создаёт снимки, сохраняя старые версии данных на диске. Если снимков "
"не существует, ZFS освобождает место для последующего использования при "
"перезаписи или удалении данных. Снимки экономят дисковое пространство, "
"записывая только различия между текущим набором данных и предыдущей версией. "
"Создание снимков возможно для целых наборов данных, но не для отдельных "
"файлов или каталогов. Снимок набора данных дублирует всё его содержимое. Это "
"включает свойства файловой системы, файлы, каталоги, права доступа и так "
"далее. Снимки не занимают дополнительного места при создании, но начинают "
"потреблять пространство по мере изменения блоков, на которые они ссылаются. "
"Рекурсивные снимки, созданные с помощью `-r`, формируют снимки с одинаковыми "
"именами для набора данных и его дочерних элементов, обеспечивая "
"согласованный снимок файловых систем на определённый момент времени. Это "
"может быть важно, когда приложение использует файлы в связанных наборах "
"данных или зависящие друг от друга. Без снимков резервная копия содержала бы "
"файлы из разных моментов времени."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1755
msgid ""
"Snapshots in ZFS provide a variety of features that even other file systems "
"with snapshot functionality lack.  A typical example of snapshot use is as a "
"quick way of backing up the current state of the file system when performing "
"a risky action like a software installation or a system upgrade.  If the "
"action fails, rolling back to the snapshot returns the system to the same "
"state when creating the snapshot.  If the upgrade was successful, delete the "
"snapshot to free up space.  Without snapshots, a failed upgrade often "
"requires restoring backups, which is tedious, time consuming, and may "
"require downtime during which the system is unusable.  Rolling back to "
"snapshots is fast, even while the system is running in normal operation, "
"with little or no downtime.  The time savings are enormous with multi-"
"terabyte storage systems considering the time required to copy the data from "
"backup.  Snapshots are not a replacement for a complete backup of a pool, "
"but offer a quick and easy way to store a dataset copy at a specific time."
msgstr ""
"Снимки в ZFS предоставляют множество функций, которых нет даже в других "
"файловых системах с поддержкой снимков. Типичный пример использования "
"снимков — быстрое резервное копирование текущего состояния файловой системы "
"перед выполнением рискованных действий, таких как установка программного "
"обеспечения или обновление системы. Если действие завершится неудачей, откат "
"к снимку вернёт систему в состояние на момент его создания. Если обновление "
"прошло успешно, снимок можно удалить для освобождения места. Без снимков "
"неудачное обновление часто требует восстановления из резервных копий, что "
"утомительно, отнимает много времени и может привести к простою системы, в "
"течение которого она будет недоступна. Откат к снимкам выполняется быстро, "
"даже во время обычной работы системы, с минимальным или нулевым временем "
"простоя. Экономия времени огромна, особенно для многотерабайтных систем "
"хранения, учитывая время, необходимое для копирования данных из резервной "
"копии. Снимки не заменяют полное резервное копирование пула, но предлагают "
"быстрый и простой способ сохранить копию набора данных на определённый "
"момент времени."

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:1757
#, no-wrap
msgid "Creating Snapshots"
msgstr "Создание Снимков"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1761
msgid ""
"To create snapshots, use `zfs snapshot _dataset_@_snapshotname_`.  Adding `-"
"r` creates a snapshot recursively, with the same name on all child datasets."
msgstr ""
"Для создания снимков используйте `zfs snapshot _наборданных_@_имяснимка_`. "
"Добавление опции `-r` создаёт снимок рекурсивно с тем же именем для всех "
"дочерних наборов данных."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1763
msgid "Create a recursive snapshot of the entire pool:"
msgstr "Создать рекурсивный снимок всего пула:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1801
#, no-wrap
msgid ""
"# zfs list -t all\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                                 780M  93.2G   144K  none\n"
"mypool/ROOT                            777M  93.2G   144K  none\n"
"mypool/ROOT/default                    777M  93.2G   777M  /\n"
"mypool/tmp                             176K  93.2G   176K  /tmp\n"
"mypool/usr                             616K  93.2G   144K  /usr\n"
"mypool/usr/home                        184K  93.2G   184K  /usr/home\n"
"mypool/usr/ports                       144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src                         144K  93.2G   144K  /usr/src\n"
"mypool/var                            1.29M  93.2G   616K  /var\n"
"mypool/var/crash                       148K  93.2G   148K  /var/crash\n"
"mypool/var/log                         178K  93.2G   178K  /var/log\n"
"mypool/var/mail                        144K  93.2G   144K  /var/mail\n"
"mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname\n"
"mypool/var/newname@new_snapshot_name      0      -  87.5K  -\n"
"mypool/var/tmp                         152K  93.2G   152K  /var/tmp\n"
"# zfs snapshot -r mypool@my_recursive_snapshot\n"
"# zfs list -t snapshot\n"
"NAME                                        USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool@my_recursive_snapshot                   0      -   144K  -\n"
"mypool/ROOT@my_recursive_snapshot              0      -   144K  -\n"
"mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -\n"
"mypool/tmp@my_recursive_snapshot               0      -   176K  -\n"
"mypool/usr@my_recursive_snapshot               0      -   144K  -\n"
"mypool/usr/home@my_recursive_snapshot          0      -   184K  -\n"
"mypool/usr/ports@my_recursive_snapshot         0      -   144K  -\n"
"mypool/usr/src@my_recursive_snapshot           0      -   144K  -\n"
"mypool/var@my_recursive_snapshot               0      -   616K  -\n"
"mypool/var/crash@my_recursive_snapshot         0      -   148K  -\n"
"mypool/var/log@my_recursive_snapshot           0      -   178K  -\n"
"mypool/var/mail@my_recursive_snapshot          0      -   144K  -\n"
"mypool/var/newname@new_snapshot_name           0      -  87.5K  -\n"
"mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -\n"
"mypool/var/tmp@my_recursive_snapshot           0      -   152K  -\n"
msgstr ""
"# zfs list -t all\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool                                 780M  93.2G   144K  none\n"
"mypool/ROOT                            777M  93.2G   144K  none\n"
"mypool/ROOT/default                    777M  93.2G   777M  /\n"
"mypool/tmp                             176K  93.2G   176K  /tmp\n"
"mypool/usr                             616K  93.2G   144K  /usr\n"
"mypool/usr/home                        184K  93.2G   184K  /usr/home\n"
"mypool/usr/ports                       144K  93.2G   144K  /usr/ports\n"
"mypool/usr/src                         144K  93.2G   144K  /usr/src\n"
"mypool/var                            1.29M  93.2G   616K  /var\n"
"mypool/var/crash                       148K  93.2G   148K  /var/crash\n"
"mypool/var/log                         178K  93.2G   178K  /var/log\n"
"mypool/var/mail                        144K  93.2G   144K  /var/mail\n"
"mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname\n"
"mypool/var/newname@new_snapshot_name      0      -  87.5K  -\n"
"mypool/var/tmp                         152K  93.2G   152K  /var/tmp\n"
"# zfs snapshot -r mypool@my_recursive_snapshot\n"
"# zfs list -t snapshot\n"
"NAME                                        USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool@my_recursive_snapshot                   0      -   144K  -\n"
"mypool/ROOT@my_recursive_snapshot              0      -   144K  -\n"
"mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -\n"
"mypool/tmp@my_recursive_snapshot               0      -   176K  -\n"
"mypool/usr@my_recursive_snapshot               0      -   144K  -\n"
"mypool/usr/home@my_recursive_snapshot          0      -   184K  -\n"
"mypool/usr/ports@my_recursive_snapshot         0      -   144K  -\n"
"mypool/usr/src@my_recursive_snapshot           0      -   144K  -\n"
"mypool/var@my_recursive_snapshot               0      -   616K  -\n"
"mypool/var/crash@my_recursive_snapshot         0      -   148K  -\n"
"mypool/var/log@my_recursive_snapshot           0      -   178K  -\n"
"mypool/var/mail@my_recursive_snapshot          0      -   144K  -\n"
"mypool/var/newname@new_snapshot_name           0      -  87.5K  -\n"
"mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -\n"
"mypool/var/tmp@my_recursive_snapshot           0      -   152K  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1806
msgid ""
"Snapshots are not shown by a normal `zfs list` operation.  To list "
"snapshots, append `-t snapshot` to `zfs list`.  `-t all` displays both file "
"systems and snapshots."
msgstr ""
"Снимки не отображаются при обычной операции `zfs list`. Для вывода списка "
"снимков добавьте `-t snapshot` к команде `zfs list`. Опция `-t all` "
"показывает как файловые системы, так и снимки."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1810
msgid ""
"Snapshots are not mounted directly, showing no path in the `MOUNTPOINT` "
"column.  ZFS does not mention available disk space in the `AVAIL` column, as "
"snapshots are read-only after their creation.  Compare the snapshot to the "
"original dataset:"
msgstr ""
"Снимки не монтируются напрямую, поэтому в столбце `MOUNTPOINT` не "
"отображается путь. ZFS не указывает доступное дисковое пространство в "
"столбце `AVAIL`, так как снимки доступны только для чтения после их "
"создания. Сравните снимок с исходным набором данных:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1817
#, no-wrap
msgid ""
"# zfs list -rt all mypool/usr/home\n"
"NAME                                    USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/usr/home                         184K  93.2G   184K  /usr/home\n"
"mypool/usr/home@my_recursive_snapshot      0      -   184K  -\n"
msgstr ""
"# zfs list -rt all mypool/usr/home\n"
"NAME                                    USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/usr/home                         184K  93.2G   184K  /usr/home\n"
"mypool/usr/home@my_recursive_snapshot      0      -   184K  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1824
msgid ""
"Displaying both the dataset and the snapshot together reveals how snapshots "
"work in crossref:zfs[zfs-term-cow,COW] fashion.  They save the changes "
"(_delta_) made and not the complete file system contents all over again.  "
"This means that snapshots take little space when making changes.  Observe "
"space usage even more by copying a file to the dataset, then creating a "
"second snapshot:"
msgstr ""
"Отображение набора данных и снимка вместе показывает, как снимки работают в "
"стиле crossref:zfs[zfs-term-cow,COW]. Они сохраняют внесённые изменения "
"(_дельту_), а не полное содержимое файловой системы заново. Это означает, "
"что снимки занимают мало места при внесении изменений. Наблюдайте за "
"использованием пространства ещё внимательнее, скопировав файл в набор "
"данных, а затем создав второй снимок:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1834
#, no-wrap
msgid ""
"# cp /etc/passwd /var/tmp\n"
"# zfs snapshot mypool/var/tmp@after_cp\n"
"# zfs list -rt all mypool/var/tmp\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp                         206K  93.2G   118K  /var/tmp\n"
"mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -\n"
"mypool/var/tmp@after_cp                   0      -   118K  -\n"
msgstr ""
"# cp /etc/passwd /var/tmp\n"
"# zfs snapshot mypool/var/tmp@after_cp\n"
"# zfs list -rt all mypool/var/tmp\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp                         206K  93.2G   118K  /var/tmp\n"
"mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -\n"
"mypool/var/tmp@after_cp                   0      -   118K  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1839
msgid ""
"The second snapshot contains the changes to the dataset after the copy "
"operation.  This yields enormous space savings.  Notice that the size of the "
"snapshot `_mypool/var/tmp@my_recursive_snapshot_` also changed in the `USED` "
"column to show the changes between itself and the snapshot taken afterwards."
msgstr ""
"Второй снимок содержит изменения в наборе данных после операции копирования. "
"Это обеспечивает значительную экономию пространства. Обратите внимание, что "
"размер снимка `_mypool/var/tmp@my_recursive_snapshot_` также изменился в "
"столбце `USED`, показывая разницу между ним и последующим снимком."

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:1841
#, no-wrap
msgid "Comparing Snapshots"
msgstr "Сравнение снимков"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1847
msgid ""
"ZFS provides a built-in command to compare the differences in content "
"between two snapshots.  This is helpful with a lot of snapshots taken over "
"time when the user wants to see how the file system has changed over time.  "
"For example, `zfs diff` lets a user find the latest snapshot that still "
"contains a file deleted by accident.  Doing this for the two snapshots "
"created in the previous section yields this output:"
msgstr ""
"ZFS предоставляет встроенную команду для сравнения различий в содержимом "
"между двумя снимками. Это полезно при наличии множества снимков, сделанных "
"за определенный период, когда пользователь хочет увидеть, как файловая "
"система изменялась со временем. Например, `zfs diff` позволяет пользователю "
"найти последний снимок, который ещё содержит случайно удалённый файл. "
"Применение этой команды к двум снимкам, созданным в предыдущем разделе, даёт "
"следующий вывод:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1858
#, no-wrap
msgid ""
"# zfs list -rt all mypool/var/tmp\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp                         206K  93.2G   118K  /var/tmp\n"
"mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -\n"
"mypool/var/tmp@after_cp                   0      -   118K  -\n"
"# zfs diff mypool/var/tmp@my_recursive_snapshot\n"
"M       /var/tmp/\n"
"+       /var/tmp/passwd\n"
msgstr ""
"# zfs list -rt all mypool/var/tmp\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp                         206K  93.2G   118K  /var/tmp\n"
"mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -\n"
"mypool/var/tmp@after_cp                   0      -   118K  -\n"
"# zfs diff mypool/var/tmp@my_recursive_snapshot\n"
"M       /var/tmp/\n"
"+       /var/tmp/passwd\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1862
msgid ""
"The command lists the changes between the specified snapshot (in this case "
"`_mypool/var/tmp@my_recursive_snapshot_`) and the live file system.  The "
"first column shows the change type:"
msgstr ""
"Команда выводит список изменений между указанным снимком (в данном случае "
"`_mypool/var/tmp@my_recursive_snapshot_`) и активной файловой системой. "
"Первый столбец показывает тип изменения:"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:1868
#, no-wrap
msgid "+"
msgstr "+"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:1870
#, no-wrap
msgid "Adding the path or file."
msgstr "Добавление пути или файла."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:1871
#, no-wrap
msgid "-"
msgstr "-"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:1873
#, no-wrap
msgid "Deleting the path or file."
msgstr "Удаление пути или файла."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:1874
#, no-wrap
msgid "M"
msgstr "M"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:1876
#, no-wrap
msgid "Modifying the path or file."
msgstr "Изменение пути или файла."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:1877
#, no-wrap
msgid "R"
msgstr "R"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:1878
#, no-wrap
msgid "Renaming the path or file."
msgstr "Переименование пути или файла."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1883
msgid ""
"Comparing the output with the table, it becomes clear that ZFS added [."
"filename]#passwd# after creating the snapshot `_mypool/var/"
"tmp@my_recursive_snapshot_`.  This also resulted in a modification to the "
"parent directory mounted at `_/var/tmp_`."
msgstr ""
"Сравнивая вывод с таблицей, становится ясно, что ZFS добавил [."
"filename]#passwd# после создания снимка `_mypool/var/"
"tmp@my_recursive_snapshot_`. Это также привело к изменению родительского "
"каталога, смонтированного в `_/var/tmp_`."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1885
msgid ""
"Comparing two snapshots is helpful when using the ZFS replication feature to "
"transfer a dataset to a different host for backup purposes."
msgstr ""
"Сравнение двух снимков полезно при использовании функции репликации ZFS для "
"передачи набора данных на другой хост в целях резервного копирования."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1887
msgid ""
"Compare two snapshots by providing the full dataset name and snapshot name "
"of both datasets:"
msgstr ""
"Сравните два снимка, указав полное имя набора данных и имя снимка для обоих "
"наборов:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1899
#, no-wrap
msgid ""
"# cp /var/tmp/passwd /var/tmp/passwd.copy\n"
"# zfs snapshot mypool/var/tmp@diff_snapshot\n"
"# zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@diff_snapshot\n"
"M       /var/tmp/\n"
"+       /var/tmp/passwd\n"
"+       /var/tmp/passwd.copy\n"
"# zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@after_cp\n"
"M       /var/tmp/\n"
"+       /var/tmp/passwd\n"
msgstr ""
"# cp /var/tmp/passwd /var/tmp/passwd.copy\n"
"# zfs snapshot mypool/var/tmp@diff_snapshot\n"
"# zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@diff_snapshot\n"
"M       /var/tmp/\n"
"+       /var/tmp/passwd\n"
"+       /var/tmp/passwd.copy\n"
"# zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@after_cp\n"
"M       /var/tmp/\n"
"+       /var/tmp/passwd\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1903
msgid ""
"A backup administrator can compare two snapshots received from the sending "
"host and determine the actual changes in the dataset.  See the crossref:"
"zfs[zfs-zfs-send,Replication] section for more information."
msgstr ""
"Администратор резервного копирования может сравнить два снимка, полученных "
"от отправляющего хоста, и определить фактические изменения в наборе данных. "
"Дополнительную информацию см. в разделе crossref:zfs[zfs-zfs-send,"
"Репликация]."

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:1905
#, no-wrap
msgid "Snapshot Rollback"
msgstr "Откат снимка состояния (Snapshot Rollback)"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1918
msgid ""
"When at least one snapshot is available, roll back to it at any time.  Most "
"often this is the case when the current state of the dataset is no longer "
"valid or an older version is preferred.  Scenarios such as local development "
"tests gone wrong, botched system updates hampering the system functionality, "
"or the need to restore deleted files or directories are all too common "
"occurrences.  To roll back a snapshot, use `zfs rollback _snapshotname_`.  "
"If a lot of changes are present, the operation will take a long time.  "
"During that time, the dataset always remains in a consistent state, much "
"like a database that conforms to ACID principles is performing a rollback.  "
"This is happening while the dataset is live and accessible without requiring "
"a downtime.  Once the snapshot rolled back, the dataset has the same state "
"as it had when the snapshot was originally taken.  Rolling back to a "
"snapshot discards all other data in that dataset not part of the snapshot.  "
"Taking a snapshot of the current state of the dataset before rolling back to "
"a previous one is a good idea when requiring some data later.  This way, the "
"user can roll back and forth between snapshots without losing data that is "
"still valuable."
msgstr ""
"Когда доступен хотя бы один снимок, можно в любой момент к нему вернуться. "
"Чаще всего это необходимо, когда текущее состояние набора данных больше не "
"является корректным или требуется более старая версия. Такие ситуации, как "
"неудачные локальные тесты разработки, неудачные обновления системы, "
"нарушающие её функциональность, или необходимость восстановления удалённых "
"файлов или каталогов, встречаются довольно часто. Для возврата к снимку "
"используйте команду `zfs rollback _имя_снимка_`. Если изменений много, "
"операция займёт значительное время. В течение этого времени набор данных "
"всегда остаётся в согласованном состоянии, подобно тому, как база данных, "
"соответствующая принципам ACID, выполняет откат. Это происходит, пока набор "
"данных находится в рабочем состоянии и доступен без необходимости простоя. "
"После отката к снимку набор данных возвращается в то же состояние, в котором "
"он находился на момент создания снимка. Откат к снимку удаляет все другие "
"данные в наборе, не входящие в снимок. Создание снимка текущего состояния "
"набора данных перед откатом к предыдущему — хорошая практика, если некоторые "
"данные могут потребоваться позже. Таким образом, пользователь может "
"переключаться между снимками, не теряя ценные данные."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1920
msgid ""
"In the first example, roll back a snapshot because a careless `rm` operation "
"removed more data than intended."
msgstr ""
"В первом примере выполняется откат к снимку, потому что неосторожная "
"операция `rm` удалила больше данных, чем планировалось."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1934
#, no-wrap
msgid ""
"# zfs list -rt all mypool/var/tmp\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp                         262K  93.2G   120K  /var/tmp\n"
"mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -\n"
"mypool/var/tmp@after_cp               53.5K      -   118K  -\n"
"mypool/var/tmp@diff_snapshot              0      -   120K  -\n"
"# ls /var/tmp\n"
"passwd          passwd.copy     vi.recover\n"
"# rm /var/tmp/passwd*\n"
"# ls /var/tmp\n"
"vi.recover\n"
msgstr ""
"# zfs list -rt all mypool/var/tmp\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp                         262K  93.2G   120K  /var/tmp\n"
"mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -\n"
"mypool/var/tmp@after_cp               53.5K      -   118K  -\n"
"mypool/var/tmp@diff_snapshot              0      -   120K  -\n"
"# ls /var/tmp\n"
"passwd          passwd.copy     vi.recover\n"
"# rm /var/tmp/passwd*\n"
"# ls /var/tmp\n"
"vi.recover\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1939
msgid ""
"At this point, the user notices the removal of extra files and wants them "
"back.  ZFS provides an easy way to get them back using rollbacks, when "
"performing snapshots of important data on a regular basis.  To get the files "
"back and start over from the last snapshot, issue the command:"
msgstr ""
"На этом этапе пользователь замечает удаление лишних файлов и хочет вернуть "
"их обратно. ZFS предоставляет простой способ восстановления с использованием "
"отката, если регулярно создаются снимки важных данных. Чтобы вернуть файлы и "
"начать заново с последнего снимка, выполните команду:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1945
#, no-wrap
msgid ""
"# zfs rollback mypool/var/tmp@diff_snapshot\n"
"# ls /var/tmp\n"
"passwd          passwd.copy     vi.recover\n"
msgstr ""
"# zfs rollback mypool/var/tmp@diff_snapshot\n"
"# ls /var/tmp\n"
"passwd          passwd.copy     vi.recover\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1950
msgid ""
"The rollback operation restored the dataset to the state of the last "
"snapshot.  Rolling back to a snapshot taken much earlier with other "
"snapshots taken afterwards is also possible.  When trying to do this, ZFS "
"will issue this warning:"
msgstr ""
"Операция отката восстановила набор данных до состояния последнего снимка. "
"Также возможен откат к более раннему снимку, если после него были созданы "
"другие снимки. При попытке выполнить это действие ZFS выдаст следующее "
"предупреждение:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1963
#, no-wrap
msgid ""
"# zfs list -rt snapshot mypool/var/tmp\n"
"AME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -\n"
"mypool/var/tmp@after_cp               53.5K      -   118K  -\n"
"mypool/var/tmp@diff_snapshot              0      -   120K  -\n"
"# zfs rollback mypool/var/tmp@my_recursive_snapshot\n"
"cannot rollback to 'mypool/var/tmp@my_recursive_snapshot': more recent snapshots exist\n"
"use '-r' to force deletion of the following snapshots:\n"
"mypool/var/tmp@after_cp\n"
"mypool/var/tmp@diff_snapshot\n"
msgstr ""
"# zfs list -rt snapshot mypool/var/tmp\n"
"AME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -\n"
"mypool/var/tmp@after_cp               53.5K      -   118K  -\n"
"mypool/var/tmp@diff_snapshot              0      -   120K  -\n"
"# zfs rollback mypool/var/tmp@my_recursive_snapshot\n"
"cannot rollback to 'mypool/var/tmp@my_recursive_snapshot': more recent snapshots exist\n"
"use '-r' to force deletion of the following snapshots:\n"
"mypool/var/tmp@after_cp\n"
"mypool/var/tmp@diff_snapshot\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1970
msgid ""
"This warning means that snapshots exist between the current state of the "
"dataset and the snapshot to which the user wants to roll back.  To complete "
"the rollback delete these snapshots.  ZFS cannot track all the changes "
"between different states of the dataset, because snapshots are read-only.  "
"ZFS will not delete the affected snapshots unless the user specifies `-r` to "
"confirm that this is the desired action.  If that is the intention, and "
"understanding the consequences of losing all intermediate snapshots, issue "
"the command:"
msgstr ""
"Это предупреждение означает, что между текущим состоянием набора данных и "
"снимком, к которому пользователь хочет выполнить откат, существуют другие "
"снимки. Для завершения отката удалите эти снимки. ZFS не может отслеживать "
"все изменения между различными состояниями набора данных, поскольку снимки "
"доступны только для чтения. ZFS не удалит затронутые снимки, если "
"пользователь явно не укажет параметр `-r`, подтверждая, что это желаемое "
"действие. Если это действительно требуется, и вы осознаёте последствия "
"потери всех промежуточных снимков, выполните команду:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:1979
#, no-wrap
msgid ""
"# zfs rollback -r mypool/var/tmp@my_recursive_snapshot\n"
"# zfs list -rt snapshot mypool/var/tmp\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -\n"
"# ls /var/tmp\n"
"vi.recover\n"
msgstr ""
"# zfs rollback -r mypool/var/tmp@my_recursive_snapshot\n"
"# zfs list -rt snapshot mypool/var/tmp\n"
"NAME                                   USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -\n"
"# ls /var/tmp\n"
"vi.recover\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1982
msgid ""
"The output from `zfs list -t snapshot` confirms the removal of the "
"intermediate snapshots as a result of `zfs rollback -r`."
msgstr ""
"Вывод команды `zfs list -t snapshot` подтверждает удаление промежуточных "
"снимков в результате выполнения `zfs rollback -r`."

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:1984
#, no-wrap
msgid "Restoring Individual Files from Snapshots"
msgstr "Восстановление отдельных файлов из снимков"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:1991
msgid ""
"Snapshots live in a hidden directory under the parent dataset: [.filename]#."
"zfs/snapshots/snapshotname#.  By default, these directories will not show "
"even when executing a standard `ls -a` .  Although the directory doesn't "
"show, access it like any normal directory.  The property named `snapdir` "
"controls whether these hidden directories show up in a directory listing.  "
"Setting the property to `visible` allows them to appear in the output of "
"`ls` and other commands that deal with directory contents."
msgstr ""
"Снимки хранятся в скрытом каталоге родительского набора данных: [.filename]#."
"zfs/snapshots/имя_снимка#. По умолчанию эти каталоги не отображаются даже "
"при выполнении стандартной команды `ls -a`. Несмотря на то, что каталог не "
"виден, доступ к нему осуществляется как к обычному каталогу. Свойство "
"`snapdir` определяет, будут ли эти скрытые каталоги отображаться в списке "
"содержимого директории. Установка свойства в значение `visible` позволяет им "
"появляться в выводе команды `ls` и других команд, работающих с содержимым "
"каталогов."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2002
#, no-wrap
msgid ""
"# zfs get snapdir mypool/var/tmp\n"
"NAME            PROPERTY  VALUE    SOURCE\n"
"mypool/var/tmp  snapdir   hidden   default\n"
"# ls -a /var/tmp\n"
".               ..              passwd          vi.recover\n"
"# zfs set snapdir=visible mypool/var/tmp\n"
"# ls -a /var/tmp\n"
".               ..              .zfs            passwd          vi.recover\n"
msgstr ""
"# zfs get snapdir mypool/var/tmp\n"
"NAME            PROPERTY  VALUE    SOURCE\n"
"mypool/var/tmp  snapdir   hidden   default\n"
"# ls -a /var/tmp\n"
".               ..              passwd          vi.recover\n"
"# zfs set snapdir=visible mypool/var/tmp\n"
"# ls -a /var/tmp\n"
".               ..              .zfs            passwd          vi.recover\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2007
msgid ""
"Restore individual files to a previous state by copying them from the "
"snapshot back to the parent dataset.  The directory structure below [."
"filename]#.zfs/snapshot# has a directory named like the snapshots taken "
"earlier to make it easier to identify them.  The next example shows how to "
"restore a file from the hidden [.filename]#.zfs# directory by copying it "
"from the snapshot containing the latest version of the file:"
msgstr ""
"Восстановите отдельные файлы в предыдущее состояние, скопировав их из снимка "
"обратно в родительский набор данных. Структура каталогов в [.filename]#.zfs/"
"snapshot# содержит каталоги с именами, соответствующими ранее созданным "
"снимкам, что упрощает их идентификацию. В следующем примере показано, как "
"восстановить файл из скрытого каталога [.filename]#.zfs#, скопировав его из "
"снимка, содержащего последнюю версию файла:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2018
#, no-wrap
msgid ""
"# rm /var/tmp/passwd\n"
"# ls -a /var/tmp\n"
".               ..              .zfs            vi.recover\n"
"# ls /var/tmp/.zfs/snapshot\n"
"after_cp                my_recursive_snapshot\n"
"# ls /var/tmp/.zfs/snapshot/after_cp\n"
"passwd          vi.recover\n"
"# cp /var/tmp/.zfs/snapshot/after_cp/passwd /var/tmp\n"
msgstr ""
"# rm /var/tmp/passwd\n"
"# ls -a /var/tmp\n"
".               ..              .zfs            vi.recover\n"
"# ls /var/tmp/.zfs/snapshot\n"
"after_cp                my_recursive_snapshot\n"
"# ls /var/tmp/.zfs/snapshot/after_cp\n"
"passwd          vi.recover\n"
"# cp /var/tmp/.zfs/snapshot/after_cp/passwd /var/tmp\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2025
msgid ""
"Even if the `snapdir` property is set to hidden, running `ls .zfs/snapshot` "
"will still list the contents of that directory.  The administrator decides "
"whether to display these directories.  This is a per-dataset setting.  "
"Copying files or directories from this hidden [.filename]#.zfs/snapshot# is "
"simple enough.  Trying it the other way around results in this error:"
msgstr ""
"Даже если свойство `snapdir` установлено в hidden, выполнение команды `ls ."
"zfs/snapshot` всё равно покажет содержимое этого каталога. Администратор "
"решает, отображать ли эти каталоги. Это настройка для каждого набора данных. "
"Копирование файлов или каталогов из скрытого [.filename]#.zfs/snapshot# "
"достаточно просто. Попытка сделать наоборот приведёт к такой ошибке:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2030
#, no-wrap
msgid ""
"# cp /etc/rc.conf /var/tmp/.zfs/snapshot/after_cp/\n"
"cp: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system\n"
msgstr ""
"# cp /etc/rc.conf /var/tmp/.zfs/snapshot/after_cp/\n"
"cp: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2034
msgid ""
"The error reminds the user that snapshots are read-only and cannot change "
"after creation.  Copying files into and removing them from snapshot "
"directories are both disallowed because that would change the state of the "
"dataset they represent."
msgstr ""
"Ошибка напоминает пользователю, что снимки доступны только для чтения и не "
"могут изменяться после создания. Копирование файлов в каталоги снимков и их "
"удаление оттуда запрещены, так как это изменило бы состояние набора данных, "
"который они представляют."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2037
msgid ""
"Snapshots consume space based on how much the parent file system has changed "
"since the time of the snapshot.  The `written` property of a snapshot tracks "
"the space the snapshot uses."
msgstr ""
"Снимки занимают место в зависимости от того, насколько родительская файловая "
"система изменилась с момента создания снимка. Свойство `written` снимка "
"отслеживает используемое им пространство."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2041
msgid ""
"To destroy snapshots and reclaim the space, use `zfs destroy "
"_dataset_@_snapshot_`.  Adding `-r` recursively removes all snapshots with "
"the same name under the parent dataset.  Adding `-n -v` to the command "
"displays a list of the snapshots to be deleted and an estimate of the space "
"it would reclaim without performing the actual destroy operation."
msgstr ""
"Для удаления снимков и освобождения пространства используйте `zfs destroy "
"_набор_данных_@_снимок_`. Добавление `-r` рекурсивно удаляет все снимки с "
"таким же именем в родительском наборе данных. Добавление `-n -v` к команде "
"выводит список снимков, которые будут удалены, и оценку освобождаемого "
"пространства без фактического выполнения операции удаления."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2043
#, no-wrap
msgid "Managing Clones"
msgstr "Управление клонами"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2052
msgid ""
"A clone is a copy of a snapshot treated more like a regular dataset.  Unlike "
"a snapshot, a clone is writeable and mountable, and has its own properties.  "
"After creating a clone using `zfs clone`, destroying the originating "
"snapshot is impossible.  To reverse the child/parent relationship between "
"the clone and the snapshot use `zfs promote`.  Promoting a clone makes the "
"snapshot become a child of the clone, rather than of the original parent "
"dataset.  This will change how ZFS accounts for the space, but not actually "
"change the amount of space consumed.  Mounting the clone anywhere within the "
"ZFS file system hierarchy is possible, not only below the original location "
"of the snapshot."
msgstr ""
"Клон — это копия снимка, которая рассматривается как обычный набор данных. В "
"отличие от снимка, клон доступен для записи, может быть смонтирован и имеет "
"свои собственные свойства. После создания клона с помощью команды `zfs "
"clone` уничтожение исходного снимка становится невозможным. Чтобы изменить "
"отношение «родитель-потомок» между клоном и снимком, используйте команду "
"`zfs promote`. Продвижение клона делает снимок потомком клона, а не "
"исходного родительского набора данных. Это изменит способ учёта пространства "
"в ZFS, но не повлияет на фактически используемый объём. Клон можно "
"смонтировать в любом месте иерархии файловой системы ZFS, а не только ниже "
"исходного расположения снимка."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2054
msgid "To show the clone feature use this example dataset:"
msgstr ""
"Чтобы продемонстрировать функцию клонирования, используйте следующий набора "
"данных в качестве примера:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2062
#, no-wrap
msgid ""
"# zfs list -rt all camino/home/joe\n"
"NAME                    USED  AVAIL  REFER  MOUNTPOINT\n"
"camino/home/joe         108K   1.3G    87K  /usr/home/joe\n"
"camino/home/joe@plans    21K      -  85.5K  -\n"
"camino/home/joe@backup    0K      -    87K  -\n"
msgstr ""
"# zfs list -rt all camino/home/joe\n"
"NAME                    USED  AVAIL  REFER  MOUNTPOINT\n"
"camino/home/joe         108K   1.3G    87K  /usr/home/joe\n"
"camino/home/joe@plans    21K      -  85.5K  -\n"
"camino/home/joe@backup    0K      -    87K  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2068
msgid ""
"A typical use for clones is to experiment with a specific dataset while "
"keeping the snapshot around to fall back to in case something goes wrong.  "
"Since snapshots cannot change, create a read/write clone of a snapshot.  "
"After achieving the desired result in the clone, promote the clone to a "
"dataset and remove the old file system.  Removing the parent dataset is not "
"strictly necessary, as the clone and dataset can coexist without problems."
msgstr ""
"Типичное применение клонов — эксперименты с определённым набором данных, при "
"этом снимок остаётся в качестве резервной копии на случай возникновения "
"проблем. Поскольку снимки нельзя изменить, создаётся доступный для чтения и "
"записи клон снимка. После достижения нужного результата в клоне, клон "
"повышается до набора данных, а старая файловая система удаляется. Удаление "
"родительского набора данных не является обязательным, так как клон и набор "
"данных могут без проблем сосуществовать."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2075
#, no-wrap
msgid ""
"# zfs clone camino/home/joe@backup camino/home/joenew\n"
"# ls /usr/home/joe*\n"
"/usr/home/joe:\n"
"backup.txz     plans.txt\n"
msgstr ""
"# zfs clone camino/home/joe@backup camino/home/joenew\n"
"# ls /usr/home/joe*\n"
"/usr/home/joe:\n"
"backup.txz     plans.txt\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2082
#, no-wrap
msgid ""
"/usr/home/joenew:\n"
"backup.txz     plans.txt\n"
"# df -h /usr/home\n"
"Filesystem          Size    Used   Avail Capacity  Mounted on\n"
"usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe\n"
"usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew\n"
msgstr ""
"/usr/home/joenew:\n"
"backup.txz     plans.txt\n"
"# df -h /usr/home\n"
"Filesystem          Size    Used   Avail Capacity  Mounted on\n"
"usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe\n"
"usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2091
msgid ""
"Creating a clone makes it an exact copy of the state the dataset was in when "
"taking the snapshot.  Changing the clone independently from its originating "
"dataset is possible now.  The connection between the two is the snapshot.  "
"ZFS records this connection in the property `origin`.  Promoting the clone "
"with `zfs promote` makes the clone an independent dataset.  This removes the "
"value of the `origin` property and disconnects the newly independent dataset "
"from the snapshot.  This example shows it:"
msgstr ""
"Создание клона делает его точной копией состояния набора данных на момент "
"создания снимка. Теперь можно изменять клон независимо от исходного набора "
"данных. Связь между ними осуществляется через снимок. ZFS записывает эту "
"связь в свойстве `origin`. Повышение клона с помощью `zfs promote` делает "
"клон независимым набором данных. Это удаляет значение свойства `origin` и "
"отключает новый независимый набор данных от снимка. Вот пример:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2101
#, no-wrap
msgid ""
"# zfs get origin camino/home/joenew\n"
"NAME                  PROPERTY  VALUE                     SOURCE\n"
"camino/home/joenew    origin    camino/home/joe@backup    -\n"
"# zfs promote camino/home/joenew\n"
"# zfs get origin camino/home/joenew\n"
"NAME                  PROPERTY  VALUE   SOURCE\n"
"camino/home/joenew    origin    -       -\n"
msgstr ""
"# zfs get origin camino/home/joenew\n"
"NAME                  PROPERTY  VALUE                     SOURCE\n"
"camino/home/joenew    origin    camino/home/joe@backup    -\n"
"# zfs promote camino/home/joenew\n"
"# zfs get origin camino/home/joenew\n"
"NAME                  PROPERTY  VALUE   SOURCE\n"
"camino/home/joenew    origin    -       -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2106
msgid ""
"After making some changes like copying [.filename]#loader.conf# to the "
"promoted clone, for example, the old directory becomes obsolete in this "
"case.  Instead, the promoted clone can replace it.  To do this, `zfs "
"destroy` the old dataset first and then `zfs rename` the clone to the old "
"dataset name (or to an entirely different name)."
msgstr ""
"После внесения изменений, таких как копирование [.filename]#loader.conf# в "
"продвинутую клон-копию, например, старая директория в этом случае становится "
"устаревшей. Вместо неё продвинутая клон-копия может её заменить. Для этого "
"сначала выполните `zfs destroy` для старого набора данных, а затем `zfs "
"rename` для клона, указав имя старого набора данных (или совершенно другое "
"имя)."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2117
#, no-wrap
msgid ""
"# cp /boot/defaults/loader.conf /usr/home/joenew\n"
"# zfs destroy -f camino/home/joe\n"
"# zfs rename camino/home/joenew camino/home/joe\n"
"# ls /usr/home/joe\n"
"backup.txz     loader.conf     plans.txt\n"
"# df -h /usr/home\n"
"Filesystem          Size    Used   Avail Capacity  Mounted on\n"
"usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe\n"
msgstr ""
"# cp /boot/defaults/loader.conf /usr/home/joenew\n"
"# zfs destroy -f camino/home/joe\n"
"# zfs rename camino/home/joenew camino/home/joe\n"
"# ls /usr/home/joe\n"
"backup.txz     loader.conf     plans.txt\n"
"# df -h /usr/home\n"
"Filesystem          Size    Used   Avail Capacity  Mounted on\n"
"usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2126
msgid ""
"The cloned snapshot is now an ordinary dataset.  It contains all the data "
"from the original snapshot plus the files added to it like [."
"filename]#loader.conf#.  Clones provide useful features to ZFS users in "
"different scenarios.  For example, provide jails as snapshots containing "
"different sets of installed applications.  Users can clone these snapshots "
"and add their own applications as they see fit.  Once satisfied with the "
"changes, promote the clones to full datasets and provide them to end users "
"to work with like they would with a real dataset.  This saves time and "
"administrative overhead when providing these jails."
msgstr ""
"Клонированный снимок теперь является обычным набором данных. Он содержит все "
"данные из исходного снимка, а также добавленные файлы, такие как [."
"filename]#loader.conf#. Клоны предоставляют полезные возможности "
"пользователям ZFS в различных сценариях. Например, можно предоставлять "
"клетки в виде снимков с различными наборами установленных приложений. "
"Пользователи могут клонировать эти снимки и добавлять свои собственные "
"приложения по своему усмотрению. После внесения необходимых изменений клоны "
"можно повысить до полноценных наборов данных и предоставить их конечным "
"пользователям для работы, как с обычными наборами данных. Это экономит время "
"и снижает административные затраты при предоставлении таких клеток."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2128
#, no-wrap
msgid "Replication"
msgstr "Репликация"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2137
msgid ""
"Keeping data on a single pool in one location exposes it to risks like theft "
"and natural or human disasters.  Making regular backups of the entire pool "
"is vital.  ZFS provides a built-in serialization feature that can send a "
"stream representation of the data to standard output.  Using this feature, "
"storing this data on another pool connected to the local system is possible, "
"as is sending it over a network to another system.  Snapshots are the basis "
"for this replication (see the section on crossref:zfs[zfs-zfs-snapshot,ZFS "
"snapshots]).  The commands used for replicating data are `zfs send` and `zfs "
"receive`."
msgstr ""
"Хранение данных в единственном пуле в одном месте подвергает их рискам, "
"таким как кража, стихийные бедствия или действия людей. Регулярное резервное "
"копирование всего пула крайне важно. ZFS предоставляет встроенную функцию "
"сериализации, которая может отправлять потоковое представление данных на "
"стандартный вывод. Используя эту функцию, можно сохранять эти данные в "
"другом пуле, подключенном к локальной системе, или отправлять их по сети на "
"другую систему. Снимки являются основой для этой репликации (см. раздел о "
"crossref:zfs[zfs-zfs-snapshot,снимках ZFS]). Команды, используемые для "
"репликации данных, — это `zfs send` и `zfs receive`."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2139
msgid "These examples show ZFS replication with these two pools:"
msgstr ""
"Эти примеры демонстрируют репликацию ZFS с использованием следующих двух "
"пулов:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2146
#, no-wrap
msgid ""
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -\n"
"mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -\n"
msgstr ""
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -\n"
"mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2154
msgid ""
"The pool named _mypool_ is the primary pool where writing and reading data "
"happens on a regular basis.  Using a second standby pool _backup_ in case "
"the primary pool becomes unavailable.  Note that this fail-over is not done "
"automatically by ZFS, but must be manually done by a system administrator "
"when needed.  Use a snapshot to provide a consistent file system version to "
"replicate.  After creating a snapshot of _mypool_, copy it to the _backup_ "
"pool by replicating snapshots.  This does not include changes made since the "
"most recent snapshot."
msgstr ""
"Имя пула _mypool_ — это основной пул, в который данные регулярно "
"записываются и откуда они читаются. Используйте второй резервный пул "
"_backup_ на случай, если основной пул станет недоступен. Обратите внимание, "
"что этот переход на резервный пул не выполняется автоматически в ZFS, а "
"должен быть осуществлён вручную системным администратором при необходимости. "
"Используйте снимок (snapshot), чтобы обеспечить согласованную версию "
"файловой системы для репликации. После создания снимка _mypool_ скопируйте "
"его в пул _backup_ путём репликации снимков. Это не включает изменения, "
"сделанные после последнего снимка."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2161
#, no-wrap
msgid ""
"# zfs snapshot mypool@backup1\n"
"# zfs list -t snapshot\n"
"NAME                    USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool@backup1             0      -  43.6M  -\n"
msgstr ""
"# zfs snapshot mypool@backup1\n"
"# zfs list -t snapshot\n"
"NAME                    USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool@backup1             0      -  43.6M  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2166
msgid ""
"Now that a snapshot exists, use `zfs send` to create a stream representing "
"the contents of the snapshot.  Store this stream as a file or receive it on "
"another pool.  Write the stream to standard output, but redirect to a file "
"or pipe or an error appears:"
msgstr ""
"Теперь, когда снимок существует, используйте `zfs send` для создания потока, "
"представляющего содержимое снимка. Сохраните этот поток в файл или примите "
"его в другом пуле. Поток записывается в стандартный вывод, но перенаправьте "
"его в файл или канал, иначе появится ошибка:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2172
#, no-wrap
msgid ""
"# zfs send mypool@backup1\n"
"Error: Stream can not be written to a terminal.\n"
"You must redirect standard output.\n"
msgstr ""
"# zfs send mypool@backup1\n"
"Error: Stream can not be written to a terminal.\n"
"You must redirect standard output.\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2176
msgid ""
"To back up a dataset with `zfs send`, redirect to a file located on the "
"mounted backup pool.  Ensure that the pool has enough free space to "
"accommodate the size of the sent snapshot, which means the data contained in "
"the snapshot, not the changes from the previous snapshot."
msgstr ""
"Для резервного копирования набора данных с помощью `zfs send` перенаправьте "
"вывод в файл, расположенный в подключенном пуле резервных копий. Убедитесь, "
"что в пуле достаточно свободного места для размещения отправленного снимка, "
"то есть для данных, содержащихся в снимке, а не для изменений по сравнению с "
"предыдущим снимком."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2184
#, no-wrap
msgid ""
"# zfs send mypool@backup1 > /backup/backup1\n"
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -\n"
"mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -\n"
msgstr ""
"# zfs send mypool@backup1 > /backup/backup1\n"
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -\n"
"mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2188
msgid ""
"The `zfs send` transferred all the data in the snapshot called _backup1_ to "
"the pool named _backup_.  To create and send these snapshots automatically, "
"use a man:cron[8] job."
msgstr ""
"Команда `zfs send` передала все данные из снимка _backup1_ в пул _backup_. "
"Для автоматического создания и отправки таких снимков используйте задание "
"man:cron[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2194
msgid ""
"Instead of storing the backups as archive files, ZFS can receive them as a "
"live file system, allowing direct access to the backed up data.  To get to "
"the actual data contained in those streams, use `zfs receive` to transform "
"the streams back into files and directories.  The example below combines "
"`zfs send` and `zfs receive` using a pipe to copy the data from one pool to "
"another.  Use the data directly on the receiving pool after the transfer is "
"complete.  It is only possible to replicate a dataset to an empty dataset."
msgstr ""
"Вместо хранения резервных копий в виде архивных файлов ZFS может получать их "
"как активную файловую систему, обеспечивая прямой доступ к резервным данным. "
"Для доступа к фактическим данным, содержащимся в этих потоках, используйте "
"`zfs receive`, чтобы преобразовать потоки обратно в файлы и каталоги. В "
"приведённом ниже примере объединяются `zfs send` и `zfs receive` с "
"использованием конвейера для копирования данных из одного пула в другой. "
"После завершения передачи данные можно использовать напрямую в целевом пуле. "
"Реплицировать набор данных можно только в пустой набор данных."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2202
#, no-wrap
msgid ""
"# zfs snapshot mypool@replica1\n"
"# zfs send -v mypool@replica1 | zfs receive backup/mypool\n"
"send from @ to mypool@replica1 estimated size is 50.1M\n"
"total estimated size is 50.1M\n"
"TIME        SENT   SNAPSHOT\n"
msgstr ""
"# zfs snapshot mypool@replica1\n"
"# zfs send -v mypool@replica1 | zfs receive backup/mypool\n"
"send from @ to mypool@replica1 estimated size is 50.1M\n"
"total estimated size is 50.1M\n"
"TIME        SENT   SNAPSHOT\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2207
#, no-wrap
msgid ""
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -\n"
"mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -\n"
msgstr ""
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -\n"
"mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -\n"

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:2210
#, no-wrap
msgid "Incremental Backups"
msgstr "Инкрементные резервные копии"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2215
msgid ""
"`zfs send` can also determine the difference between two snapshots and send "
"individual differences between the two.  This saves disk space and transfer "
"time.  For example:"
msgstr ""
"`zfs send` также может определить разницу между двумя снимками и отправить "
"отдельные различия между ними. Это экономит место на диске и время передачи. "
"Например:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2227
#, no-wrap
msgid ""
"# zfs snapshot mypool@replica2\n"
"# zfs list -t snapshot\n"
"NAME                    USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool@replica1         5.72M      -  43.6M  -\n"
"mypool@replica2             0      -  44.1M  -\n"
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -\n"
"mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -\n"
msgstr ""
"# zfs snapshot mypool@replica2\n"
"# zfs list -t snapshot\n"
"NAME                    USED  AVAIL  REFER  MOUNTPOINT\n"
"mypool@replica1         5.72M      -  43.6M  -\n"
"mypool@replica2             0      -  44.1M  -\n"
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -\n"
"mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2233
msgid ""
"Create a second snapshot called _replica2_.  This second snapshot contains "
"changes made to the file system between now and the previous snapshot, "
"_replica1_.  Using `zfs send -i` and indicating the pair of snapshots "
"generates an incremental replica stream containing the changed data.  This "
"succeeds if the initial snapshot already exists on the receiving side."
msgstr ""
"Создайте второй снимок с именем _replica2_. Этот второй снимок содержит "
"изменения, внесенные в файловую систему в период между текущим моментом и "
"предыдущим снимком _replica1_. Использование `zfs send -i` с указанием пары "
"снимков создает инкрементальный поток репликации, содержащий измененные "
"данные. Это выполняется успешно, если исходный снимок уже существует на "
"принимающей стороне."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2240
#, no-wrap
msgid ""
"# zfs send -v -i mypool@replica1 mypool@replica2 | zfs receive /backup/mypool\n"
"send from @replica1 to mypool@replica2 estimated size is 5.02M\n"
"total estimated size is 5.02M\n"
"TIME        SENT   SNAPSHOT\n"
msgstr ""
"# zfs send -v -i mypool@replica1 mypool@replica2 | zfs receive /backup/mypool\n"
"send from @replica1 to mypool@replica2 estimated size is 5.02M\n"
"total estimated size is 5.02M\n"
"TIME        SENT   SNAPSHOT\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2245
#, no-wrap
msgid ""
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG  CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M  80.8M   879M         -         -     0%   8%  1.00x  ONLINE  -\n"
"mypool  960M  50.2M   910M         -         -     0%   5%  1.00x  ONLINE  -\n"
msgstr ""
"# zpool list\n"
"NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG  CAP  DEDUP  HEALTH  ALTROOT\n"
"backup  960M  80.8M   879M         -         -     0%   8%  1.00x  ONLINE  -\n"
"mypool  960M  50.2M   910M         -         -     0%   5%  1.00x  ONLINE  -\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2251
#, no-wrap
msgid ""
"# zfs list\n"
"NAME                         USED  AVAIL  REFER  MOUNTPOINT\n"
"backup                      55.4M   240G   152K  /backup\n"
"backup/mypool               55.3M   240G  55.2M  /backup/mypool\n"
"mypool                      55.6M  11.6G  55.0M  /mypool\n"
msgstr ""
"# zfs list\n"
"NAME                         USED  AVAIL  REFER  MOUNTPOINT\n"
"backup                      55.4M   240G   152K  /backup\n"
"backup/mypool               55.3M   240G  55.2M  /backup/mypool\n"
"mypool                      55.6M  11.6G  55.0M  /mypool\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2258
#, no-wrap
msgid ""
"# zfs list -t snapshot\n"
"NAME                                         USED  AVAIL  REFER  MOUNTPOINT\n"
"backup/mypool@replica1                       104K      -  50.2M  -\n"
"backup/mypool@replica2                          0      -  55.2M  -\n"
"mypool@replica1                             29.9K      -  50.0M  -\n"
"mypool@replica2                                 0      -  55.0M  -\n"
msgstr ""
"# zfs list -t snapshot\n"
"NAME                                         USED  AVAIL  REFER  MOUNTPOINT\n"
"backup/mypool@replica1                       104K      -  50.2M  -\n"
"backup/mypool@replica2                          0      -  55.2M  -\n"
"mypool@replica1                             29.9K      -  50.0M  -\n"
"mypool@replica2                                 0      -  55.0M  -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2263
msgid ""
"The incremental stream replicated the changed data rather than the entirety "
"of _replica1_.  Sending the differences alone took much less time to "
"transfer and saved disk space by not copying the whole pool each time.  This "
"is useful when replicating over a slow network or one charging per "
"transferred byte."
msgstr ""
"Инкрементный поток реплицировал измененные данные вместо полной копии "
"_replica1_. Передача только различий заняла гораздо меньше времени и "
"сэкономила место на диске, избегая копирования всего пула каждый раз. Это "
"особенно полезно при репликации по медленной сети или при тарификации за "
"каждый переданный байт."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2268
msgid ""
"A new file system, _backup/mypool_, is available with the files and data "
"from the pool _mypool_.  Specifying `-p` copies the dataset properties "
"including compression settings, quotas, and mount points.  Specifying `-R` "
"copies all child datasets of the dataset along with their properties.  "
"Automate sending and receiving to create regular backups on the second pool."
msgstr ""
"Доступна новая файловая система _backup/mypool_ с файлами и данными из пула "
"_mypool_. Указание `-p` копирует свойства наборов данных, включая настройки "
"сжатия, квоты и точки монтирования. Указание `-R` копирует все дочерние "
"наборы данных вместе с их свойствами. Автоматизируйте отправку и получение "
"для создания регулярных резервных копий во втором пуле."

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:2270
#, no-wrap
msgid "Sending Encrypted Backups over SSH"
msgstr "Отправка зашифрованных резервных копий через SSH"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2278
msgid ""
"Sending streams over the network is a good way to keep a remote backup, but "
"it does come with a drawback.  Data sent over the network link is not "
"encrypted, allowing anyone to intercept and transform the streams back into "
"data without the knowledge of the sending user.  This is undesirable when "
"sending the streams over the internet to a remote host.  Use SSH to securely "
"encrypt data sent over a network connection.  Since ZFS requires redirecting "
"the stream from standard output, piping it through SSH is easy.  To keep the "
"contents of the file system encrypted in transit and on the remote system, "
"consider using https://wiki.freebsd.org/PEFS[PEFS]."
msgstr ""
"Отправка потоков данных по сети — это хороший способ создания удаленной "
"резервной копии, но у этого метода есть недостаток. Данные, передаваемые по "
"сетевому соединению, не шифруются, что позволяет любому перехватить их и "
"преобразовать обратно в данные без ведома отправителя. Это нежелательно при "
"отправке потоков через интернет на удаленный хост. Используйте SSH для "
"безопасного шифрования данных, передаваемых по сетевому соединению. "
"Поскольку ZFS требует перенаправления потока из стандартного вывода, его "
"легко передать через SSH с помощью конвейера. Чтобы содержимое файловой "
"системы оставалось зашифрованным при передаче и на удаленной системе, "
"рассмотрите возможность использования https://wiki.freebsd.org/PEFS[PEFS]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2281
msgid ""
"Change some settings and take security precautions first.  This describes "
"the necessary steps required for the `zfs send` operation; for more "
"information on SSH, see crossref:security[openssh,\"OpenSSH\"]."
msgstr ""
"Измените некоторые настройки и сначала примите меры безопасности. Здесь "
"описаны необходимые шаги для операции `zfs send`; дополнительную информацию "
"о SSH см. в crossref:security[openssh,\"OpenSSH\"]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2283
msgid "Change the configuration as follows:"
msgstr "Измените конфигурацию следующим образом:"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2285
msgid ""
"Passwordless SSH access between sending and receiving host using SSH keys"
msgstr ""
"Беспарольный доступ SSH между отправляющим и принимающим хостами с "
"использованием SSH-ключей"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2286
msgid ""
"ZFS requires the privileges of the `root` user to send and receive streams. "
"This requires logging in to the receiving system as `root`."
msgstr ""
"Для отправки и получения потоков ZFS требуются привилегии пользователя "
"`root`. Это подразумевает вход в принимающую систему под учетной записью "
"`root`."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2287
msgid "Security reasons prevent `root` from logging in by default."
msgstr ""
"По соображениям безопасности вход пользователя `root` по умолчанию запрещён."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2289
msgid ""
"Use the crossref:zfs[zfs-zfs-allow,ZFS Delegation] system to allow a non-"
"`root` user on each system to perform the respective send and receive "
"operations.  On the sending system:"
msgstr ""
"Используйте систему crossref:zfs[zfs-zfs-allow,Делегирование ZFS], чтобы "
"разрешить пользователю без прав `root` на каждой системе выполнять "
"соответствующие операции отправки и получения. На передающей системе:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2293
#, no-wrap
msgid "# zfs allow -u someuser send,snapshot mypool\n"
msgstr "# zfs allow -u someuser send,snapshot mypool\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2296
msgid ""
"To mount the pool, the unprivileged user must own the directory, and regular "
"users need permission to mount file systems."
msgstr ""
"Чтобы подключить пул, непривилегированный пользователь должен быть "
"владельцем каталога, а обычные пользователи должны иметь разрешение на "
"подключение файловых систем."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2298
msgid "On the receiving system:"
msgstr "На принимающей системе:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2307
#, no-wrap
msgid ""
"# sysctl vfs.usermount=1\n"
"vfs.usermount: 0 -> 1\n"
"# echo vfs.usermount=1 >> /etc/sysctl.conf\n"
"# zfs create recvpool/backup\n"
"# zfs allow -u someuser create,mount,receive recvpool/backup\n"
"# chown someuser /recvpool/backup\n"
msgstr ""
"# sysctl vfs.usermount=1\n"
"vfs.usermount: 0 -> 1\n"
"# echo vfs.usermount=1 >> /etc/sysctl.conf\n"
"# zfs create recvpool/backup\n"
"# zfs allow -u someuser create,mount,receive recvpool/backup\n"
"# chown someuser /recvpool/backup\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2310
msgid ""
"The unprivileged user can receive and mount datasets now, and replicates the "
"_home_ dataset to the remote system:"
msgstr ""
"Непривилегированный пользователь теперь может получать и монтировать наборы "
"данных, а также реплицирует набор данных _home_ на удалённую систему:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2315
#, no-wrap
msgid ""
"% zfs snapshot -r mypool/home@monday\n"
"% zfs send -R mypool/home@monday | ssh someuser@backuphost zfs recv -dvu recvpool/backup\n"
msgstr ""
"% zfs snapshot -r mypool/home@monday\n"
"% zfs send -R mypool/home@monday | ssh someuser@backuphost zfs recv -dvu recvpool/backup\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2325
msgid ""
"Create a recursive snapshot called _monday_ of the file system dataset "
"_home_ on the pool _mypool_.  Then `zfs send -R` includes the dataset, all "
"child datasets, snapshots, clones, and settings in the stream.  Pipe the "
"output through SSH to the waiting `zfs receive` on the remote host "
"_backuphost_.  Using an IP address or fully qualified domain name is good "
"practice.  The receiving machine writes the data to the _backup_ dataset on "
"the _recvpool_ pool.  Adding `-d` to `zfs recv` overwrites the name of the "
"pool on the receiving side with the name of the snapshot.  `-u` causes the "
"file systems to not mount on the receiving side.  Using `-v` shows more "
"details about the transfer, including the elapsed time and the amount of "
"data transferred."
msgstr ""
"Создайте рекурсивный снимок с именем _monday_ для набора данных файловой "
"системы _home_ в пуле _mypool_. Затем `zfs send -R` включает в поток набор "
"данных, все дочерние наборы данных, снимки, клоны и настройки. Передайте "
"вывод через SSH на ожидающий `zfs receive` на удалённом хосте _backuphost_. "
"Рекомендуется использовать IP-адрес или полное доменное имя. Принимающая "
"машина записывает данные в набор данных _backup_ в пуле _recvpool_. "
"Добавление `-d` к `zfs recv` перезаписывает имя пула на принимающей стороне "
"именем снимка. `-u` отключает монтирование файловых систем на принимающей "
"стороне. Использование `-v` показывает подробности о передаче, включая "
"затраченное время и объём переданных данных."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2327
#, no-wrap
msgid "Dataset, User, and Group Quotas"
msgstr "Квоты наборов данных, пользователей и групп"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2333
msgid ""
"Use crossref:zfs[zfs-term-quota,Dataset quotas] to restrict the amount of "
"space consumed by a particular dataset.  crossref:zfs[zfs-term-refquota,"
"Reference Quotas] work in much the same way, but count the space used by the "
"dataset itself, excluding snapshots and child datasets.  Similarly, use "
"crossref:zfs[zfs-term-userquota,user] and crossref:zfs[zfs-term-groupquota,"
"group] quotas to prevent users or groups from using up all the space in the "
"pool or dataset."
msgstr ""
"Используйте crossref:zfs[zfs-term-quota,Квоты наборов данных], чтобы "
"ограничить объём пространства, используемого определённым набором данных.  "
"crossref:zfs[zfs-term-refquota,Референтные квоты] работают схожим образом, "
"но учитывают пространство, используемое самим набором данных, исключая "
"снимки и дочерние наборы данных.  Аналогично, используйте crossref:zfs[zfs-"
"term-userquota,пользовательские] и crossref:zfs[zfs-term-groupquota,"
"групповые] квоты, чтобы предотвратить исчерпание всего пространства в пуле "
"или наборе данных пользователями или группами."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2338
msgid ""
"The following examples assume that the users already exist in the system.  "
"Before adding a user to the system, make sure to create their home dataset "
"first and set the `mountpoint` to `/home/_bob_`.  Then, create the user and "
"make the home directory point to the dataset's `mountpoint` location.  This "
"will properly set owner and group permissions without shadowing any pre-"
"existing home directory paths that might exist."
msgstr ""
"Следующие примеры предполагают, что пользователи уже существуют в системе. "
"Перед добавлением пользователя в систему убедитесь, что вы сначала создали "
"его домашний набор данных и установили `mountpoint` в `/home/_bob_`. Затем "
"создайте пользователя и укажите домашний каталог на расположение "
"`mountpoint` набора данных. Это правильно установит права владельца и группы "
"без перекрытия уже существующих путей домашних каталогов."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2340
msgid "To enforce a dataset quota of 10 GB for [.filename]#storage/home/bob#:"
msgstr ""
"Чтобы установить квоту набора данных в 10 ГБ для [.filename]#storage/home/"
"bob#:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2344
#, no-wrap
msgid "# zfs set quota=10G storage/home/bob\n"
msgstr "# zfs set quota=10G storage/home/bob\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2347
msgid ""
"To enforce a reference quota of 10 GB for [.filename]#storage/home/bob#:"
msgstr ""
"Чтобы установить контрольную квоту в 10 ГБ для [.filename]#storage/home/bob#:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2351
#, no-wrap
msgid "# zfs set refquota=10G storage/home/bob\n"
msgstr "# zfs set refquota=10G storage/home/bob\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2354
msgid "To remove a quota of 10 GB for [.filename]#storage/home/bob#:"
msgstr "Удалить квоту в 10 ГБ для [.filename]#storage/home/bob#:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2358
#, no-wrap
msgid "# zfs set quota=none storage/home/bob\n"
msgstr "# zfs set quota=none storage/home/bob\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2361
msgid ""
"The general format is `userquota@_user_=_size_`, and the user's name must be "
"in one of these formats:"
msgstr ""
"Общий формат `userquota@_пользователь_=_размер_`, и имя пользователя должно "
"быть в одном из следующих форматов:"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2363
msgid "POSIX compatible name such as _joe_."
msgstr "POSIX-совместимое имя, например _joe_."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2364
msgid "POSIX numeric ID such as _789_."
msgstr "Числовой идентификатор POSIX, например, _789_."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2365
msgid "SID name such as _joe.bloggs@example.com_."
msgstr "Имя SID, например, _joe.bloggs@example.com_."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2366
msgid "SID numeric ID such as _S-1-123-456-789_."
msgstr "Числовой идентификатор SID, например, _S-1-123-456-789_."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2368
msgid "For example, to enforce a user quota of 50 GB for the user named _joe_:"
msgstr ""
"Например, чтобы установить пользовательскую квоту в 50 ГБ для пользователя с "
"именем _joe_:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2372
#, no-wrap
msgid "# zfs set userquota@joe=50G\n"
msgstr "# zfs set userquota@joe=50G\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2375
msgid "To remove any quota:"
msgstr "Чтобы удалить любую квоту:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2379
#, no-wrap
msgid "# zfs set userquota@joe=none\n"
msgstr "# zfs set userquota@joe=none\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2386
msgid ""
"User quota properties are not displayed by `zfs get all`.  Non-`root` users "
"can't see other's quotas unless granted the `userquota` privilege.  Users "
"with this privilege are able to view and set everyone's quota."
msgstr ""
"Свойства квот пользователей не отображаются командой `zfs get all`. "
"Пользователи без прав `root` не могут видеть квоты других, если им не "
"предоставлена привилегия `userquota`. Пользователи с этой привилегией могут "
"просматривать и устанавливать квоты для всех."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2389
msgid ""
"The general format for setting a group quota is: `groupquota@_group_=_size_`."
msgstr ""
"Общий формат для установки квоты группы: `groupquota@_группа_=_размер_`."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2391
msgid "To set the quota for the group _firstgroup_ to 50 GB, use:"
msgstr "Чтобы установить квоту для группы _firstgroup_ в 50 ГБ, используйте:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2395
#, no-wrap
msgid "# zfs set groupquota@firstgroup=50G\n"
msgstr "# zfs set groupquota@firstgroup=50G\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2398
msgid ""
"To remove the quota for the group _firstgroup_, or to make sure that one is "
"not set, instead use:"
msgstr ""
"Чтобы удалить квоту для группы _firstgroup_ или убедиться, что она не "
"установлена, используйте вместо этого:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2402
#, no-wrap
msgid "# zfs set groupquota@firstgroup=none\n"
msgstr "# zfs set groupquota@firstgroup=none\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2406
msgid ""
"As with the user quota property, non-`root` users can see the quotas "
"associated with the groups to which they belong.  A user with the "
"`groupquota` privilege or `root` can view and set all quotas for all groups."
msgstr ""
"Как и в случае с пользовательскими квотами, пользователи без прав `root` "
"могут видеть квоты, связанные с группами, к которым они принадлежат. "
"Пользователь с привилегией `groupquota` или `root` может просматривать и "
"устанавливать квоты для всех групп."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2410
msgid ""
"To display the amount of space used by each user on a file system or "
"snapshot along with any quotas, use `zfs userspace`.  For group information, "
"use `zfs groupspace`.  For more information about supported options or how "
"to display specific options alone, refer to man:zfs[1]."
msgstr ""
"Для отображения объема пространства, используемого каждым пользователем в "
"файловой системе или снимке, вместе с квотами, используйте `zfs userspace`. "
"Для информации о группах используйте `zfs groupspace`. Подробнее о "
"поддерживаемых опциях или о том, как отобразить только определенные опции, "
"см. в man:zfs[1]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2412
msgid ""
"Privileged users and `root` can list the quota for [.filename]#storage/home/"
"bob# using:"
msgstr ""
"Привилегированные пользователи и `root` могут просмотреть квоту для [."
"filename]#storage/home/bob#, используя:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2416
#, no-wrap
msgid "# zfs get quota storage/home/bob\n"
msgstr "# zfs get quota storage/home/bob\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2419
#, no-wrap
msgid "Reservations"
msgstr "Резервирования"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2424
msgid ""
"crossref:zfs[zfs-term-reservation,Reservations] guarantee an always-"
"available amount of space on a dataset.  The reserved space will not be "
"available to any other dataset.  This useful feature ensures that free space "
"is available for an important dataset or log files."
msgstr ""
"crossref:zfs[zfs-term-reservation,Резервирования] гарантируют всегда "
"доступный объём пространства в наборе данных. Зарезервированное пространство "
"не будет доступно для других наборов данных. Эта полезная функция "
"обеспечивает наличие свободного места для важных наборов данных или файлов "
"журналов."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2426
msgid ""
"The general format of the `reservation` property is `reservation=_size_`, so "
"to set a reservation of 10 GB on [.filename]#storage/home/bob#, use:"
msgstr ""
"Общий формат свойства `reservation` — `reservation=_размер_`, поэтому, чтобы "
"установить резервирование в 10 ГБ для [.filename]#storage/home/bob#, "
"используйте:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2430
#, no-wrap
msgid "# zfs set reservation=10G storage/home/bob\n"
msgstr "# zfs set reservation=10G storage/home/bob\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2433
msgid "To clear any reservation:"
msgstr "Чтобы очистить любое резервирование:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2437
#, no-wrap
msgid "# zfs set reservation=none storage/home/bob\n"
msgstr "# zfs set reservation=none storage/home/bob\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2441
msgid ""
"The same principle applies to the `refreservation` property for setting a "
"crossref:zfs[zfs-term-refreservation,Reference Reservation], with the "
"general format `refreservation=_size_`."
msgstr ""
"Тот же принцип применяется к свойству `refreservation` для установки "
"crossref:zfs[zfs-term-refreservation,Референсного резервирования], с общим "
"форматом `refreservation=_размер_`."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2443
msgid ""
"This command shows any reservations or refreservations that exist on [."
"filename]#storage/home/bob#:"
msgstr ""
"Эта команда показывает все и резервирования (`reservation`), и референсные "
"резервирования (`refreservation`), существующие в [.filename]#storage/home/"
"bob#:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2448
#, no-wrap
msgid ""
"# zfs get reservation storage/home/bob\n"
"# zfs get refreservation storage/home/bob\n"
msgstr ""
"# zfs get reservation storage/home/bob\n"
"# zfs get refreservation storage/home/bob\n"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2451
#, no-wrap
msgid "Compression"
msgstr "Сжатие"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2458
msgid ""
"ZFS provides transparent compression.  Compressing data written at the block "
"level saves space and also increases disk throughput.  If data compresses by "
"25% the compressed data writes to the disk at the same rate as the "
"uncompressed version, resulting in an effective write speed of 125%.  "
"Compression can also be a great alternative to crossref:zfs[zfs-zfs-"
"deduplication,Deduplication] because it does not require extra memory."
msgstr ""
"ZFS предоставляет прозрачное сжатие. Сжатие данных на уровне блоков экономит "
"место и увеличивает пропускную способность диска. Если данные сжимаются на "
"25%, то сжатые данные записываются на диск с той же скоростью, что и "
"несжатые, что приводит к эффективной скорости записи в 125%. Сжатие также "
"может быть отличной альтернативой crossref:zfs[zfs-zfs-deduplication,"
"Дедупликации], так как не требует дополнительной памяти."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2465
msgid ""
"ZFS offers different compression algorithms, each with different trade-"
"offs.  The introduction of LZ4 compression in ZFS v5000 enables compressing "
"the entire pool without the large performance trade-off of other "
"algorithms.  The biggest advantage to LZ4 is the _early abort_ feature.  If "
"LZ4 does not achieve at least 12.5% compression in the header part of the "
"data, ZFS writes the block uncompressed to avoid wasting CPU cycles trying "
"to compress data that is either already compressed or uncompressible.  For "
"details about the different compression algorithms available in ZFS, see the "
"crossref:zfs[zfs-term-compression,Compression] entry in the terminology "
"section."
msgstr ""
"ZFS предлагает различные алгоритмы сжатия, каждый со своими компромиссами. "
"Введение сжатия LZ4 в ZFS v5000 позволяет сжимать весь пул без значительного "
"снижения производительности, характерного для других алгоритмов. Главное "
"преимущество LZ4 — функция _раннего прерывания_. Если LZ4 не достигает как "
"минимум 12,5% сжатия в заголовочной части данных, ZFS записывает блок без "
"сжатия, чтобы избежать потерь процессорного времени на попытки сжать уже "
"сжатые или несжимаемые данные. Подробнее о различных алгоритмах сжатия, "
"доступных в ZFS, см. в разделе crossref:zfs[zfs-term-compression,Сжатие] "
"терминологии."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2467
msgid ""
"The administrator can see the effectiveness of compression using dataset "
"properties."
msgstr ""
"Администратор может оценить эффективность сжатия, используя свойства набора "
"данных."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2476
#, no-wrap
msgid ""
"# zfs get used,compressratio,compression,logicalused mypool/compressed_dataset\n"
"NAME        PROPERTY          VALUE     SOURCE\n"
"mypool/compressed_dataset  used              449G      -\n"
"mypool/compressed_dataset  compressratio     1.11x     -\n"
"mypool/compressed_dataset  compression       lz4       local\n"
"mypool/compressed_dataset  logicalused       496G      -\n"
msgstr ""
"# zfs get used,compressratio,compression,logicalused mypool/compressed_dataset\n"
"NAME        PROPERTY          VALUE     SOURCE\n"
"mypool/compressed_dataset  used              449G      -\n"
"mypool/compressed_dataset  compressratio     1.11x     -\n"
"mypool/compressed_dataset  compression       lz4       local\n"
"mypool/compressed_dataset  logicalused       496G      -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2481
msgid ""
"The dataset is using 449 GB of space (the used property).  Without "
"compression, it would have taken 496 GB of space (the `logicalused` "
"property).  This results in a 1.11:1 compression ratio."
msgstr ""
"Набор данных использует 449 ГБ пространства (свойство `used`). Без сжатия он "
"занял бы 496 ГБ пространства (свойство `logicalused`). Это даёт коэффициент "
"сжатия 1.11:1."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2488
msgid ""
"Compression can have an unexpected side effect when combined with crossref:"
"zfs[zfs-term-userquota,User Quotas].  User quotas restrict how much actual "
"space a user consumes on a dataset _after compression_.  If a user has a "
"quota of 10 GB, and writes 10 GB of compressible data, they will still be "
"able to store more data.  If they later update a file, say a database, with "
"more or less compressible data, the amount of space available to them will "
"change.  This can result in the odd situation where a user did not increase "
"the actual amount of data (the `logicalused` property), but the change in "
"compression caused them to reach their quota limit."
msgstr ""
"Сжатие может иметь неожиданный побочный эффект при использовании вместе с "
"crossref:zfs[zfs-term-userquota,Квотами пользователей]. Квоты пользователей "
"ограничивают фактическое пространство, которое пользователь занимает на "
"наборе данных _после сжатия_. Если у пользователя есть квота в 10 ГБ, и он "
"записывает 10 ГБ сжимаемых данных, он всё равно сможет сохранить больше "
"данных. Если позже пользователь обновит файл, например базу данных, более "
"или менее сжимаемыми данными, количество доступного ему пространства "
"изменится. Это может привести к необычной ситуации, когда пользователь не "
"увеличил фактический объём данных (свойство `logicalused`), но изменение "
"степени сжатия привело к достижению предела его квоты."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2492
msgid ""
"Compression can have a similar unexpected interaction with backups.  Quotas "
"are often used to limit data storage to ensure there is enough backup space "
"available.  Since quotas do not consider compression ZFS may write more data "
"than would fit with uncompressed backups."
msgstr ""
"Сжатие может иметь схожий непредвиденный эффект при взаимодействии с "
"резервными копиями. Квоты часто используются для ограничения хранимых "
"данных, чтобы гарантировать наличие достаточного места для резервного "
"копирования. Поскольку квоты не учитывают сжатие, ZFS может записать больше "
"данных, чем поместилось бы при резервном копировании без сжатия."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2494
#, no-wrap
msgid "Zstandard Compression"
msgstr "Сжатие алгоритмом Zstandard"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2498
msgid ""
"OpenZFS 2.0 added a new compression algorithm.  Zstandard (Zstd) offers "
"higher compression ratios than the default LZ4 while offering much greater "
"speeds than the alternative, gzip. OpenZFS 2.0 is available starting with "
"FreeBSD 12.1-RELEASE via package:sysutils/openzfs[] and has been the default "
"in since FreeBSD 13.0-RELEASE."
msgstr ""
"В OpenZFS 2.0 был добавлен новый алгоритм сжатия. Zstandard (Zstd) "
"обеспечивает более высокие коэффициенты сжатия по сравнению с используемым "
"по умолчанию LZ4, при этом работая значительно быстрее альтернативного gzip. "
"OpenZFS 2.0 доступен начиная с FreeBSD 12.1-RELEASE в пакете package:"
"sysutils/openzfs[] и является стандартным начиная с FreeBSD 13.0-RELEASE."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2502
msgid ""
"Zstd provides a large selection of compression levels, providing fine-"
"grained control over performance versus compression ratio.  One of the main "
"advantages of Zstd is that the decompression speed is independent of the "
"compression level.  For data written once but read often, Zstd allows the "
"use of the highest compression levels without a read performance penalty."
msgstr ""
"Zstd предоставляет широкий выбор уровней сжатия, обеспечивая детальный "
"контроль над производительностью и степенью сжатия. Одним из основных "
"преимуществ Zstd является то, что скорость распаковки не зависит от уровня "
"сжатия. Для данных, которые записываются один раз, но часто читаются, Zstd "
"позволяет использовать максимальные уровни сжатия без потери "
"производительности при чтении."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2507
msgid ""
"Even with frequent data updates, enabling compression often provides higher "
"performance.  One of the biggest advantages comes from the compressed ARC "
"feature.  ZFS's Adaptive Replacement Cache (ARC) caches the compressed "
"version of the data in RAM, decompressing it each time.  This allows the "
"same amount of RAM to store more data and metadata, increasing the cache hit "
"ratio."
msgstr ""
"Даже при частом обновлении данных включение сжатия часто обеспечивает более "
"высокую производительность. Одно из главных преимуществ связано с функцией "
"сжатого ARC. Адаптивный кэш замещения (ARC Adaptive Replacement Cache) в ZFS "
"хранит сжатую версию данных в оперативной памяти, распаковывая их при каждом "
"обращении. Это позволяет хранить больше данных и метаданных в том же объеме "
"памяти, повышая коэффициент попадания в кэш."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2513
msgid ""
"ZFS offers 19 levels of Zstd compression, each offering incrementally more "
"space savings in exchange for slower compression.  The default level is "
"`zstd-3` and offers greater compression than LZ4 without being much slower.  "
"Levels above 10 require large amounts of memory to compress each block and "
"systems with less than 16 GB of RAM should not use them.  ZFS uses a "
"selection of the Zstd_fast_ levels also, which get correspondingly faster "
"but supports lower compression ratios.  ZFS supports `zstd-fast-1` through "
"`zstd-fast-10`, `zstd-fast-20` through `zstd-fast-100` in increments of 10, "
"and `zstd-fast-500` and `zstd-fast-1000` which provide minimal compression, "
"but offer high performance."
msgstr ""
"ZFS предлагает 19 уровней сжатия Zstd, каждый из которых обеспечивает "
"постепенное увеличение экономии места в обмен на более медленное сжатие. "
"Уровень по умолчанию — `zstd-3`, который обеспечивает лучшее сжатие, чем "
"LZ4, без значительного снижения скорости. Уровни выше 10 требуют большого "
"объема памяти для сжатия каждого блока, и системы с менее чем 16 ГБ ОЗУ не "
"должны их использовать. ZFS также использует подмножество уровней "
"Zstd_fast_, которые работают быстрее, но обеспечивают меньшую степень "
"сжатия. ZFS поддерживает уровни от `zstd-fast-1` до `zstd-fast-10`, от `zstd-"
"fast-20` до `zstd-fast-100` с шагом 10, а также `zstd-fast-500` и `zstd-"
"fast-1000`, которые обеспечивают минимальное сжатие, но обладают высокой "
"производительностью."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2517
msgid ""
"If ZFS is not able to get the required memory to compress a block with Zstd, "
"it will fall back to storing the block uncompressed.  This is unlikely to "
"happen except at the highest levels of Zstd on memory constrained systems.  "
"ZFS counts how often this has occurred since loading the ZFS module with "
"`kstat.zfs.misc.zstd.compress_alloc_fail`."
msgstr ""
"Если ZFS не может получить необходимую память для сжатия блока с помощью "
"Zstd, он переходит к сохранению блока в несжатом виде. Это маловероятно, за "
"исключением случаев использования максимальных уровней Zstd на системах с "
"ограниченной памятью. ZFS подсчитывает, сколько раз это произошло с момента "
"загрузки модуля ZFS, с помощью `kstat.zfs.misc.zstd.compress_alloc_fail`."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2519
#, no-wrap
msgid "Deduplication"
msgstr "Дедупликация"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2525
msgid ""
"When enabled, crossref:zfs[zfs-term-deduplication,deduplication] uses the "
"checksum of each block to detect duplicate blocks.  When a new block is a "
"duplicate of an existing block, ZFS writes a new reference to the existing "
"data instead of the whole duplicate block.  Tremendous space savings are "
"possible if the data contains a lot of duplicated files or repeated "
"information.  Warning: deduplication requires a large amount of memory, and "
"enabling compression instead provides most of the space savings without the "
"extra cost."
msgstr ""
"Когда включена перекрёстная crossref:zfs[zfs-term-deduplication,"
"дедупликация], она использует контрольную сумму каждого блока для "
"обнаружения дублирующихся блоков. Когда новый блок является дубликатом "
"существующего блока, ZFS записывает новую ссылку на существующие данные "
"вместо всего дублирующегося блока. Возможна значительная экономия места, "
"если данные содержат много дублирующихся файлов или повторяющейся "
"информации. Предупреждение: дедупликация требует большого объёма памяти, а "
"включение сжатия обеспечивает большую часть экономии места без "
"дополнительных затрат."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2527
msgid "To activate deduplication, set the `dedup` property on the target pool:"
msgstr "Для активации дедупликации установите свойство `dedup` в целевой пул:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2531
#, no-wrap
msgid "# zfs set dedup=on pool\n"
msgstr "# zfs set dedup=on pool\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2536
msgid ""
"Deduplicating only affects new data written to the pool.  Merely activating "
"this option will not deduplicate data already written to the pool.  A pool "
"with a freshly activated deduplication property will look like this example:"
msgstr ""
"Дедупликация затрагивает только новые данные, записываемые в пул. Простое "
"включение этой опции не приведёт к дедупликации уже записанных в пул данных. "
"Пул с только что активированным свойством дедупликации будет выглядеть "
"следующим образом:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2542
#, no-wrap
msgid ""
"# zpool list\n"
"NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP   DEDUP   HEALTH   ALTROOT\n"
"pool 2.84G 2.19M 2.83G         -         -     0%    0%   1.00x   ONLINE   -\n"
msgstr ""
"# zpool list\n"
"NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP   DEDUP   HEALTH   ALTROOT\n"
"pool 2.84G 2.19M 2.83G         -         -     0%    0%   1.00x   ONLINE   -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2547
msgid ""
"The `DEDUP` column shows the actual rate of deduplication for the pool.  A "
"value of `1.00x` shows that data has not deduplicated yet.  The next example "
"copies some system binaries three times into different directories on the "
"deduplicated pool created above."
msgstr ""
"Столбец `DEDUP` показывает фактический уровень дедупликации для пула. "
"Значение `1.00x` означает, что данные пока не дедуплицированы. В следующем "
"примере некоторые системные двоичные файлы копируются три раза в разные "
"каталоги в пуле с дедупликацией, созданном выше."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2553
#, no-wrap
msgid ""
"# for d in dir1 dir2 dir3; do\n"
"> mkdir $d && cp -R /usr/bin $d &\n"
"> done\n"
msgstr ""
"# for d in dir1 dir2 dir3; do\n"
"> mkdir $d && cp -R /usr/bin $d &\n"
"> done\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2556
msgid "To observe deduplicating of redundant data, use:"
msgstr "Для наблюдения за дедупликацией избыточных данных используйте:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2562
#, no-wrap
msgid ""
"# zpool list\n"
"NAME SIZE  ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG  CAP   DEDUP   HEALTH   ALTROOT\n"
"pool 2.84G 20.9M 2.82G         -         -     0%   0%   3.00x   ONLINE   -\n"
msgstr ""
"# zpool list\n"
"NAME SIZE  ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG  CAP   DEDUP   HEALTH   ALTROOT\n"
"pool 2.84G 20.9M 2.82G         -         -     0%   0%   3.00x   ONLINE   -\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2567
msgid ""
"The `DEDUP` column shows a factor of `3.00x`.  Detecting and deduplicating "
"copies of the data uses a third of the space.  The potential for space "
"savings can be enormous, but comes at the cost of having enough memory to "
"keep track of the deduplicated blocks."
msgstr ""
"Столбец `DEDUP` показывает коэффициент `3.00x`. Обнаружение и дедупликация "
"копий данных используют треть пространства. Потенциальная экономия "
"пространства может быть огромной, но достигается за счет наличия "
"достаточного объема памяти для отслеживания дедуплицированных блоков."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2570
msgid ""
"Deduplication is not always beneficial when the data in a pool is not "
"redundant.  ZFS can show potential space savings by simulating deduplication "
"on an existing pool:"
msgstr ""
"Дедупликация не всегда полезна, если данные в пуле не содержат избыточности. "
"ZFS может показать потенциальную экономию пространства, имитируя "
"дедупликацию на существующем пуле:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2575
#, no-wrap
msgid ""
"# zdb -S pool\n"
"Simulated DDT histogram:\n"
msgstr ""
"# zdb -S pool\n"
"Simulated DDT histogram:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2591
#, no-wrap
msgid ""
"bucket              allocated                       referenced\n"
"______   ______________________________   ______________________________\n"
"refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE\n"
"------   ------   -----   -----   -----   ------   -----   -----   -----\n"
"     1    2.58M    289G    264G    264G    2.58M    289G    264G    264G\n"
"     2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G\n"
"     4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G\n"
"     8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M\n"
"    16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M\n"
"    32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M\n"
"    64        9     56K   10.5K   10.5K      865   4.96M    948K    948K\n"
"   128        2   9.50K      2K      2K      419   2.11M    438K    438K\n"
"   256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M\n"
"    1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M\n"
" Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G\n"
msgstr ""
"bucket              allocated                       referenced\n"
"______   ______________________________   ______________________________\n"
"refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE\n"
"------   ------   -----   -----   -----   ------   -----   -----   -----\n"
"     1    2.58M    289G    264G    264G    2.58M    289G    264G    264G\n"
"     2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G\n"
"     4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G\n"
"     8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M\n"
"    16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M\n"
"    32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M\n"
"    64        9     56K   10.5K   10.5K      865   4.96M    948K    948K\n"
"   128        2   9.50K      2K      2K      419   2.11M    438K    438K\n"
"   256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M\n"
"    1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M\n"
" Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2593
#, no-wrap
msgid "dedup = 1.05, compress = 1.11, copies = 1.00, dedup * compress / copies = 1.16\n"
msgstr "dedup = 1.05, compress = 1.11, copies = 1.00, dedup * compress / copies = 1.16\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2603
msgid ""
"After `zdb -S` finishes analyzing the pool, it shows the space reduction "
"ratio that activating deduplication would achieve.  In this case, `1.16` is "
"a poor space saving ratio mainly provided by compression.  Activating "
"deduplication on this pool would not save any amount of space, and is not "
"worth the amount of memory required to enable deduplication.  Using the "
"formula _ratio = dedup * compress / copies_, system administrators can plan "
"the storage allocation, deciding whether the workload will contain enough "
"duplicate blocks to justify the memory requirements.  If the data is "
"reasonably compressible, the space savings may be good.  Good practice is to "
"enable compression first as compression also provides greatly increased "
"performance.  Enable deduplication in cases where savings are considerable "
"and with enough available memory for the crossref:zfs[zfs-term-deduplication,"
"DDT]."
msgstr ""
"После завершения анализа пула командой `zdb -S` отображается коэффициент "
"сокращения пространства, который был бы достигнут при активации "
"дедупликации. В данном случае значение `1.16` указывает на низкий уровень "
"экономии пространства, в основном обеспечиваемый сжатием. Активация "
"дедупликации для этого пула не сэкономит значительного объема пространства и "
"не оправдает объем памяти, необходимый для её включения. Используя формулу "
"_ratio = dedup * compress / copies_, системные администраторы могут "
"планировать распределение хранилища, определяя, будет ли рабочая нагрузка "
"содержать достаточное количество дублирующихся блоков, чтобы оправдать "
"требования к памяти. Если данные достаточно хорошо сжимаемы, экономия "
"пространства может быть значительной. Рекомендуется сначала включить сжатие, "
"так как оно также значительно повышает производительность. Активируйте "
"дедупликацию только в случаях, когда экономия пространства существенна и "
"имеется достаточный объем доступной памяти для crossref:zfs[zfs-term-"
"deduplication,DDT]."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2605
#, no-wrap
msgid "ZFS and Jails"
msgstr "ZFS и клетки"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2611
msgid ""
"Use `zfs jail` and the corresponding `jailed` property to delegate a ZFS "
"dataset to a crossref:jails[jails,Jail].  `zfs jail _jailid_` attaches a "
"dataset to the specified jail, and `zfs unjail` detaches it.  To control the "
"dataset from within a jail, set the `jailed` property.  ZFS forbids mounting "
"a jailed dataset on the host because it may have mount points that would "
"compromise the security of the host."
msgstr ""
"Используйте `zfs jail` и соответствующее свойство `jailed`, чтобы "
"делегировать набор данных ZFS в crossref:jails[jails,Клетку].  `zfs jail "
"_идентификатор_клетки_` присоединяет набор данных к указанной клетке, а `zfs "
"unjail` отсоединяет его.  Для управления набором данных изнутри клетки "
"установите свойство `jail`.  ZFS запрещает монтирование на хосте набора "
"данных со свойством jail, так как его точки монтирования могут нарушить "
"безопасность хоста."

#. type: Title ==
#: documentation/content/en/books/handbook/zfs/_index.adoc:2613
#, no-wrap
msgid "Delegated Administration"
msgstr "Делегированное администрирование"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2621
msgid ""
"A comprehensive permission delegation system allows unprivileged users to "
"perform ZFS administration functions.  For example, if each user's home "
"directory is a dataset, users need permission to create and destroy "
"snapshots of their home directories.  A user performing backups can get "
"permission to use replication features.  ZFS allows a usage statistics "
"script to run with access to only the space usage data for all users.  "
"Delegating the ability to delegate permissions is also possible.  Permission "
"delegation is possible for each subcommand and most properties."
msgstr ""
"Комплексная система делегирования прав позволяет непривилегированным "
"пользователям выполнять функции администрирования ZFS. Например, если "
"домашний каталог каждого пользователя является набором данных, пользователям "
"нужно разрешение на создание и удаление снимков своих домашних каталогов. "
"Пользователь, выполняющий резервное копирование, может получить разрешение "
"на использование функций репликации. ZFS позволяет скрипту статистики "
"использования работать с доступом только к данным о занятом пространстве для "
"всех пользователей. Также возможно делегирование права на делегирование "
"разрешений. Делегирование прав доступно для каждой подкоманды и большинства "
"свойств."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2623
#, no-wrap
msgid "Delegating Dataset Creation"
msgstr "Делегирование создания наборов данных"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2629
msgid ""
"`zfs allow _someuser_ create _mydataset_` gives the specified user "
"permission to create child datasets under the selected parent dataset.  A "
"caveat: creating a new dataset involves mounting it.  That requires setting "
"the FreeBSD `vfs.usermount` man:sysctl[8] to `1` to allow non-root users to "
"mount a file system.  Another restriction aimed at preventing abuse: non-"
"`root` users must own the mountpoint where mounting the file system."
msgstr ""
"`zfs allow _someuser_ create _mydataset_` предоставляет указанному "
"пользователю разрешение на создание дочерних наборов данных в выбранном "
"родительском наборе данных. Важное замечание: создание нового набора данных "
"включает его монтирование. Для этого необходимо установить параметр `vfs."
"usermount` в man:sysctl[8] FreeBSD в значение `1`, чтобы разрешить "
"непривилегированным пользователям монтировать файловую систему. Ещё одно "
"ограничение, направленное на предотвращение злоупотреблений: "
"непривилегированные пользователи должны быть владельцами точки монтирования, "
"куда монтируется файловая система."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2631
#, no-wrap
msgid "Delegating Permission Delegation"
msgstr "Делегирование права делегировать разрешения"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2635
msgid ""
"`zfs allow _someuser_ allow _mydataset_` gives the specified user the "
"ability to assign any permission they have on the target dataset, or its "
"children, to other users.  If a user has the `snapshot` permission and the "
"`allow` permission, that user can then grant the `snapshot` permission to "
"other users."
msgstr ""
"`zfs allow _someuser_ allow _mydataset_` предоставляет указанному "
"пользователю возможность назначать любые разрешения, которые у него есть для "
"целевого набора данных или его дочерних элементов, другим пользователям. "
"Если пользователь имеет разрешение `snapshot` и разрешение `allow`, он может "
"предоставить разрешение `snapshot` другим пользователям."

#. type: Title ==
#: documentation/content/en/books/handbook/zfs/_index.adoc:2637
#, no-wrap
msgid "Advanced Topics"
msgstr "Сложные темы"

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2640
#, no-wrap
msgid "Tuning"
msgstr "Настройка"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2643
msgid "Adjust tunables to make ZFS perform best for different workloads."
msgstr ""
"Настройте параметры для оптимальной производительности ZFS в различных "
"рабочих нагрузках."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2647
msgid ""
"[[zfs-advanced-tuning-arc_max]] `_vfs.zfs.arc.max_` starting with 13.x (`vfs."
"zfs.arc_max` for 12.x) - Upper size of the crossref:zfs[zfs-term-arc,ARC]. "
"The default is all RAM but 1 GB, or 5/8 of all RAM, whichever is more. Use a "
"lower value if the system runs any other daemons or processes that may "
"require memory. Adjust this value at runtime with man:sysctl[8] and set it "
"in [.filename]#/boot/loader.conf# or [.filename]#/etc/sysctl.conf#."
msgstr ""
"[[zfs-advanced-tuning-arc_max]] `_vfs.zfs.arc.max_` начиная с 13.x (`vfs.zfs."
"arc_max` для 12.x) - Верхний размер crossref:zfs[zfs-term-arc,ARC]. По "
"умолчанию используется весь объем ОЗУ за исключением 1 ГБ или 5/8 от всего "
"объема ОЗУ, в зависимости от того, что больше. Используйте меньшее значение, "
"если в системе работают другие демоны или процессы, которым может "
"потребоваться память. Изменяйте это значение во время работы с помощью man:"
"sysctl[8] и задавайте его в [.filename]#/boot/loader.conf# или [.filename]#/"
"etc/sysctl.conf#."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2654
msgid ""
"[[zfs-advanced-tuning-arc_meta_limit]] `_vfs.zfs.arc.meta_limit_` starting "
"with 13.x (`vfs.zfs.arc_meta_limit` for 12.x) - Limit the amount of the "
"crossref:zfs[zfs-term-arc,ARC] used to store metadata. The default is one "
"fourth of `vfs.zfs.arc.max`. Increasing this value will improve performance "
"if the workload involves operations on a large number of files and "
"directories, or frequent metadata operations, at the cost of less file data "
"fitting in the crossref:zfs[zfs-term-arc,ARC]. Adjust this value at runtime "
"with man:sysctl[8] in [.filename]#/boot/loader.conf# or [.filename]#/etc/"
"sysctl.conf#."
msgstr ""
"[[zfs-advanced-tuning-arc_meta_limit]] `_vfs.zfs.arc.meta_limit_` начиная с "
"13.x (`vfs.zfs.arc_meta_limit` для 12.x) — ограничивает объем crossref:"
"zfs[zfs-term-arc,ARC], используемого для хранения метаданных. По умолчанию "
"составляет одну четвертую от `vfs.zfs.arc.max`. Увеличение этого значения "
"может повысить производительность при работе с большим количеством файлов и "
"каталогов или частых операциях с метаданными, за счет уменьшения объема "
"данных файлов, помещающихся в crossref:zfs[zfs-term-arc,ARC]. Это значение "
"можно изменить во время работы с помощью man:sysctl[8] в [.filename]#/boot/"
"loader.conf# или [.filename]#/etc/sysctl.conf#."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2659
msgid ""
"[[zfs-advanced-tuning-arc_min]] `_vfs.zfs.arc.min_` starting with 13.x (`vfs."
"zfs.arc_min` for 12.x) - Lower size of the crossref:zfs[zfs-term-arc,ARC]. "
"The default is one half of `vfs.zfs.arc.meta_limit`. Adjust this value to "
"prevent other applications from pressuring out the entire crossref:zfs[zfs-"
"term-arc,ARC]. Adjust this value at runtime with man:sysctl[8] and in [."
"filename]#/boot/loader.conf# or [.filename]#/etc/sysctl.conf#."
msgstr ""
"[[zfs-advanced-tuning-arc_min]] `_vfs.zfs.arc.min_` начиная с 13.x (`vfs.zfs."
"arc_min` для 12.x) - Нижний размер crossref:zfs[zfs-term-arc,ARC]. По "
"умолчанию составляет половину от `vfs.zfs.arc.meta_limit`. Измените это "
"значение, чтобы предотвратить вытеснение всего crossref:zfs[zfs-term-arc,"
"ARC] другими приложениями. Настройка этого значения возможна во время "
"выполнения с помощью man:sysctl[8], а также в [.filename]#/boot/loader.conf# "
"или [.filename]#/etc/sysctl.conf#."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2660
msgid ""
"[[zfs-advanced-tuning-vdev-cache-size]] `_vfs.zfs.vdev.cache.size_` - A "
"preallocated amount of memory reserved as a cache for each device in the "
"pool. The total amount of memory used will be this value multiplied by the "
"number of devices. Set this value at boot time and in [.filename]#/boot/"
"loader.conf#."
msgstr ""
"[[zfs-advanced-tuning-vdev-cache-size]] `_vfs.zfs.vdev.cache.size_` - "
"Предварительно выделенный объем памяти, зарезервированный в качестве кэша "
"для каждого устройства в пуле. Общий объем используемой памяти будет равен "
"этому значению, умноженному на количество устройств. Установите это значение "
"при загрузке и в [.filename]#/boot/loader.conf#."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2661
msgid ""
"[[zfs-advanced-tuning-min-auto-ashift]] `_vfs.zfs.min_auto_ashift_` - Lower "
"`ashift` (sector size) used automatically at pool creation time. The value "
"is a power of two. The default value of `9` represents `2^9 = 512`, a sector "
"size of 512 bytes. To avoid _write amplification_ and get the best "
"performance, set this value to the largest sector size used by a device in "
"the pool."
msgstr ""
"[[zfs-advanced-tuning-min-auto-ashift]] `_vfs.zfs.min_auto_ashift_` - "
"Минимальное значение `ashift` (размер сектора), автоматически используемое "
"при создании пула. Значение является степенью двойки. Значение по умолчанию "
"`9` соответствует `2^9 = 512`, то есть размеру сектора 512 байт. Чтобы "
"избежать _усиления записи_ (write amplification) и получить наилучшую "
"производительность, установите это значение равным наибольшему размеру "
"сектора среди устройств в пуле."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2667
msgid ""
"Common drives have 4 KB sectors.  Using the default `ashift` of `9` with "
"these drives results in write amplification on these devices.  Data "
"contained in a single 4 KB write is instead written in eight 512-byte "
"writes.  ZFS tries to read the native sector size from all devices when "
"creating a pool, but drives with 4 KB sectors report that their sectors are "
"512 bytes for compatibility.  Setting `vfs.zfs.min_auto_ashift` to `12` "
"(`2^12 = 4096`) before creating a pool forces ZFS to use 4 KB blocks for "
"best performance on these drives."
msgstr ""
"Обычные диски имеют секторы размером 4 КБ. Использование значения `ashift` "
"по умолчанию (`9`) для таких дисков приводит к усилению записи на этих "
"устройствах. Данные, которые должны быть записаны одним блоком 4 КБ, вместо "
"этого записываются восемью блоками по 512 байт. ZFS пытается определить "
"родной размер сектора всех устройств при создании пула, но диски с секторами "
"4 КБ сообщают, что их секторы имеют размер 512 байт для совместимости. "
"Установка `vfs.zfs.min_auto_ashift` в значение `12` (`2^12 = 4096`) перед "
"созданием пула заставляет ZFS использовать блоки 4 КБ для наилучшей "
"производительности на таких дисках."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2670
msgid ""
"Forcing 4 KB blocks is also useful on pools with planned disk upgrades.  "
"Future disks use 4 KB sectors, and `ashift` values cannot change after "
"creating a pool."
msgstr ""
"Принудительное использование блоков размером 4 КБ также полезно для пулов с "
"запланированным обновлением дисков. Будущие диски используют секторы "
"размером 4 КБ, а значения `ashift` нельзя изменить после создания пула."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2674
msgid ""
"In some specific cases, the smaller 512-byte block size might be "
"preferable.  When used with 512-byte disks for databases or as storage for "
"virtual machines, less data transfers during small random reads.  This can "
"provide better performance when using a smaller ZFS record size."
msgstr ""
"В некоторых конкретных случаях меньший размер блока 512 байт может быть "
"предпочтительнее. При использовании с дисками 512 байт для баз данных или в "
"качестве хранилища для виртуальных машин уменьшается объем передаваемых "
"данных при небольших случайных чтениях. Это может обеспечить лучшую "
"производительность при использовании меньшего размера записи ZFS."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2678
msgid ""
"[[zfs-advanced-tuning-prefetch_disable]] `_vfs.zfs.prefetch_disable_` - "
"Disable prefetch. A value of `0` enables and `1` disables it. The default is "
"`0`, unless the system has less than 4 GB of RAM. Prefetch works by reading "
"larger blocks than requested into the crossref:zfs[zfs-term-arc,ARC] in "
"hopes to soon need the data. If the workload has a large number of random "
"reads, disabling prefetch may actually improve performance by reducing "
"unnecessary reads. Adjust this value at any time with man:sysctl[8]."
msgstr ""
"[[zfs-advanced-tuning-prefetch_disable]] `_vfs.zfs.prefetch_disable_` — "
"Отключает предварительную выборку. Значение `0` включает её, а `1` "
"отключает. По умолчанию используется `0`, если в системе не менее 4 ГБ "
"оперативной памяти. Предварительная выборка работает, считывая блоки "
"большего размера, чем запрошено, в раздел crossref:zfs[zfs-term-arc,ARC], в "
"надежде, что данные скоро понадобятся. Если рабочая нагрузка включает "
"большое количество случайных чтений, отключение предварительной выборки "
"может улучшить производительность, сократив ненужные чтения. Это значение "
"можно изменить в любое время с помощью man:sysctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2679
msgid ""
"[[zfs-advanced-tuning-vdev-trim_on_init]] `_vfs.zfs.vdev.trim_on_init_` - "
"Control whether new devices added to the pool have the `TRIM` command run on "
"them. This ensures the best performance and longevity for SSDs, but takes "
"extra time. If the device has already been secure erased, disabling this "
"setting will make the addition of the new device faster. Adjust this value "
"at any time with man:sysctl[8]."
msgstr ""
"[[zfs-advanced-tuning-vdev-trim_on_init]] `_vfs.zfs.vdev.trim_on_init_` — "
"Управляет тем, будет ли для новых устройств, добавленных в пул, выполняться "
"команда `TRIM`. Это обеспечивает наилучшую производительность и "
"долговечность для SSD, но занимает дополнительное время. Если устройство уже "
"было безопасно очищено, отключение этой настройки ускорит добавление нового "
"устройства. Значение можно изменить в любой момент с помощью man:sysctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2680
msgid ""
"[[zfs-advanced-tuning-vdev-max_pending]] `_vfs.zfs.vdev.max_pending_` - "
"Limit the number of pending I/O requests per device. A higher value will "
"keep the device command queue full and may give higher throughput. A lower "
"value will reduce latency. Adjust this value at any time with man:sysctl[8]."
msgstr ""
"[[zfs-advanced-tuning-vdev-max_pending]] `_vfs.zfs.vdev.max_pending_` — "
"Ограничивает количество ожидающих запросов ввода-вывода для каждого "
"устройства. Более высокое значение поддерживает очередь команд устройства "
"заполненной и может увеличить пропускную способность. Более низкое значение "
"уменьшает задержки. Это значение можно изменить в любое время с помощью man:"
"sysctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2686
msgid ""
"[[zfs-advanced-tuning-top_maxinflight]] `_vfs.zfs.top_maxinflight_` - Upper "
"number of outstanding I/Os per top-level crossref:zfs[zfs-term-vdev,vdev].  "
"Limits the depth of the command queue to prevent high latency. The limit is "
"per top-level vdev, meaning the limit applies to each crossref:zfs[zfs-term-"
"vdev-mirror,mirror], crossref:zfs[zfs-term-vdev-raidz,RAID-Z], or other vdev "
"independently. Adjust this value at any time with man:sysctl[8]."
msgstr ""
"[[zfs-advanced-tuning-top_maxinflight]] `_vfs.zfs.top_maxinflight_` — "
"Верхний предел количества необработанных операций ввода-вывода для каждого "
"корневого crossref:zfs[zfs-term-vdev,vdev]. Ограничивает глубину очереди "
"команд для предотвращения высокой задержки. Лимит применяется к каждому "
"корневому vdev, то есть ограничение действует независимо для каждого "
"crossref:zfs[zfs-term-vdev-mirror,зеркала], crossref:zfs[zfs-term-vdev-raidz,"
"RAID-Z] или другого vdev. Значение можно изменить в любое время с помощью "
"man:sysctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2688
msgid ""
"[[zfs-advanced-tuning-l2arc_write_max]] `_vfs.zfs.l2arc_write_max_` - Limit "
"the amount of data written to the crossref:zfs[zfs-term-l2arc,L2ARC] per "
"second. This tunable extends the longevity of SSDs by limiting the amount of "
"data written to the device. Adjust this value at any time with man:sysctl[8]."
msgstr ""
"[[zfs-advanced-tuning-l2arc_write_max]] `_vfs.zfs.l2arc_write_max_` — "
"Ограничивает объем данных, записываемых в crossref:zfs[zfs-term-l2arc,L2ARC] "
"в секунду. Этот параметр увеличивает срок службы SSD, ограничивая объем "
"данных, записываемых на устройство. Значение можно изменить в любой момент с "
"помощью man:sysctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2694
msgid ""
"[[zfs-advanced-tuning-l2arc_write_boost]] `_vfs.zfs.l2arc_write_boost_` - "
"Adds the value of this tunable to crossref:zfs[zfs-advanced-tuning-"
"l2arc_write_max,`vfs.zfs.l2arc_write_max`] and increases the write speed to "
"the SSD until evicting the first block from the crossref:zfs[zfs-term-l2arc,"
"L2ARC]. This \"Turbo Warmup Phase\" reduces the performance loss from an "
"empty crossref:zfs[zfs-term-l2arc,L2ARC] after a reboot. Adjust this value "
"at any time with man:sysctl[8]."
msgstr ""
"[[zfs-advanced-tuning-l2arc_write_boost]] `_vfs.zfs.l2arc_write_boost_` — "
"Добавляет значение этого параметра к crossref:zfs[zfs-advanced-tuning-"
"l2arc_write_max,`vfs.zfs.l2arc_write_max`] и увеличивает скорость записи на "
"SSD до вытеснения первого блока из crossref:zfs[zfs-term-l2arc,L2ARC]. Эта "
"\"Фаза турборазогрева\" снижает потерю производительности из-за пустого "
"crossref:zfs[zfs-term-l2arc,L2ARC] после перезагрузки. Значение можно "
"изменить в любое время с помощью man:sysctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2699
msgid ""
"[[zfs-advanced-tuning-scrub_delay]]`_vfs.zfs.scrub_delay_` - Number of ticks "
"to delay between each I/O during a crossref:zfs[zfs-term-scrub,`scrub`]. To "
"ensure that a `scrub` does not interfere with the normal operation of the "
"pool, if any other I/O is happening the `scrub` will delay between each "
"command. This value controls the limit on the total IOPS (I/Os Per Second)"
msgstr ""
"[[zfs-advanced-tuning-scrub_delay]]`_vfs.zfs.scrub_delay_` — Количество "
"тактов задержки между каждой операцией ввода-вывода во время перекрестного "
"crossref:zfs[zfs-term-scrub,`scrub`]. Чтобы гарантировать, что `scrub` не "
"мешает нормальной работе пула, если происходят другие операции ввода-вывода, "
"`scrub` будет задерживаться между каждой командой. Это значение контролирует "
"ограничение на общее количество IOPS (операций ввода-вывода в секунду)"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2707
msgid ""
"generated by the `scrub`. The granularity of the setting is determined by "
"the value of `kern.hz` which defaults to 1000 ticks per second.  Changing "
"this setting results in a different effective IOPS limit.  The default value "
"is `4`, resulting in a limit of: 1000 ticks/sec / 4 = 250 IOPS. Using a "
"value of _20_ would give a limit of: 1000 ticks/sec / 20 = 50 IOPS. Recent "
"activity on the pool limits the speed of `scrub`, as determined by crossref:"
"zfs[zfs-advanced-tuning-scan_idle,`vfs.zfs.scan_idle`]. Adjust this value at "
"any time with man:sysctl[8]."
msgstr ""
", сгенерированных командой `scrub`. Гранулярность настройки определяется "
"значением `kern.hz`, которое по умолчанию равно 1000 тикам в секунду. "
"Изменение этого параметра приводит к изменению эффективного лимита IOPS. "
"Значение по умолчанию — `4`, что дает лимит: 1000 тиков/сек / 4 = 250 IOPS. "
"Использование значения _20_ установит лимит: 1000 тиков/сек / 20 = 50 IOPS. "
"Недавняя активность в пуле ограничивает скорость `scrub`, как определено в "
"crossref:zfs[zfs-advanced-tuning-scan_idle,`vfs.zfs.scan_idle`]. Это "
"значение можно изменить в любое время с помощью man:sysctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2723
msgid ""
"[[zfs-advanced-tuning-resilver_delay]] `_vfs.zfs.resilver_delay_` - Number "
"of milliseconds of delay inserted between each I/O during a crossref:zfs[zfs-"
"term-resilver,resilver]. To ensure that a resilver does not interfere with "
"the normal operation of the pool, if any other I/O is happening the resilver "
"will delay between each command. This value controls the limit of total IOPS "
"(I/Os Per Second) generated by the resilver. ZFS determins the granularity "
"of the setting by the value of `kern.hz` which defaults to 1000 ticks per "
"second. Changing this setting results in a different effective IOPS limit. "
"The default value is 2, resulting in a limit of: 1000 ticks/sec / 2 = 500 "
"IOPS. Returning the pool to an crossref:zfs[zfs-term-online,Online] state "
"may be more important if another device failing could crossref:zfs[zfs-term-"
"faulted,Fault] the pool, causing data loss. A value of 0 will give the "
"resilver operation the same priority as other operations, speeding the "
"healing process. Other recent activity on the pool limits the speed of "
"resilver, as determined by crossref:zfs[zfs-advanced-tuning-scan_idle,`vfs."
"zfs.scan_idle`]. Adjust this value at any time with man:sysctl[8]."
msgstr ""
"[[zfs-advanced-tuning-resilver_delay]] `_vfs.zfs.resilver_delay_` — "
"количество миллисекунд задержки, вставляемой между каждым операцией ввода-"
"вывода во время crossref:zfs[zfs-term-resilver,ресилверинга]. Чтобы "
"гарантировать, что ресилверинг не мешает нормальной работе пула, при наличии "
"других операций ввода-вывода ресилверинг будет добавлять задержку между "
"каждой командой. Данный параметр ограничивает общее количество IOPS "
"(операций ввода-вывода в секунду), генерируемых ресилверингом. ZFS "
"определяет гранулярность настройки через значение `kern.hz`, которое по "
"умолчанию равно 1000 тикам в секунду. Изменение этого параметра приводит к "
"изменению эффективного лимита IOPS. Значение по умолчанию — 2, что даёт "
"лимит: 1000 тиков/сек / 2 = 500 IOPS. Возвращение пула в состояние crossref:"
"zfs[zfs-term-online,Online] может быть более важным, если выход из строя "
"другого устройства может перевести пул в состояние crossref:zfs[zfs-term-"
"faulted,Fault], что приведёт к потере данных. Значение 0 даст операции "
"ресилверинга такой же приоритет, как и другим операциям, ускоряя процесс "
"восстановления. Недавняя активность в пуле ограничивает скорость "
"ресилверинга, как определено в crossref:zfs[zfs-advanced-tuning-scan_idle,"
"`vfs.zfs.scan_idle`]. Этот параметр можно изменить в любое время с помощью "
"man:sysctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2727
msgid ""
"[[zfs-advanced-tuning-scan_idle]] `_vfs.zfs.scan_idle_` - Number of "
"milliseconds since the last operation before considering the pool is idle. "
"ZFS disables the rate limiting for crossref:zfs[zfs-term-scrub,`scrub`] and "
"crossref:zfs[zfs-term-resilver,resilver] when the pool is idle. Adjust this "
"value at any time with man:sysctl[8]."
msgstr ""
"[[zfs-advanced-tuning-scan_idle]] `_vfs.zfs.scan_idle_` - Количество "
"миллисекунд с момента последней операции, после которого пул считается "
"бездействующим. ZFS отключает ограничение скорости для crossref:zfs[zfs-term-"
"scrub,`scrub`] и crossref:zfs[zfs-term-resilver,ресильверинга], когда пул "
"бездействует. Это значение можно изменить в любое время с помощью man:"
"sysctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2729
msgid ""
"[[zfs-advanced-tuning-txg-timeout]] `_vfs.zfs.txg.timeout_` - Upper number "
"of seconds between crossref:zfs[zfs-term-txg,transaction group]s. The "
"current transaction group writes to the pool and a fresh transaction group "
"starts if this amount of time elapsed since the previous transaction group. "
"A transaction group may trigger earlier if writing enough data. The default "
"value is 5 seconds. A larger value may improve read performance by delaying "
"asynchronous writes, but this may cause uneven performance when writing the "
"transaction group. Adjust this value at any time with man:sysctl[8]."
msgstr ""
"[[zfs-advanced-tuning-txg-timeout]] `_vfs.zfs.txg.timeout_` — Максимальное "
"количество секунд между группами crossref:zfs[zfs-term-txg,транзакций]. "
"Текущая группа транзакций записывается в пул, и начинается новая группа "
"транзакций, если с момента предыдущей группы транзакций прошло указанное "
"время. Группа транзакций может запуститься раньше при записи достаточного "
"объема данных. Значение по умолчанию составляет 5 секунд. Увеличение этого "
"значения может улучшить производительность чтения за счет задержки "
"асинхронных записей, но это может привести к неравномерной "
"производительности при записи группы транзакций. Это значение можно изменить "
"в любое время с помощью man:sysctl[8]."

#. type: Title ===
#: documentation/content/en/books/handbook/zfs/_index.adoc:2731
#, no-wrap
msgid "ZFS on i386"
msgstr "ZFS на i386"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2734
msgid ""
"Some of the features provided by ZFS are memory intensive, and may require "
"tuning for upper efficiency on systems with limited RAM."
msgstr ""
"Некоторые функции ZFS требуют значительных ресурсов памяти и могут "
"потребовать настройки для повышения эффективности на системах с ограниченным "
"объемом ОЗУ."

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:2735
#, no-wrap
msgid "Memory"
msgstr "Память"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2743
msgid ""
"As a lower value, the total system memory should be at least one gigabyte.  "
"The amount of recommended RAM depends upon the size of the pool and which "
"features ZFS uses.  A general rule of thumb is 1 GB of RAM for every 1 TB of "
"storage.  If using the deduplication feature, a general rule of thumb is 5 "
"GB of RAM per TB of storage to deduplicate.  While some users use ZFS with "
"less RAM, systems under heavy load may panic due to memory exhaustion.  ZFS "
"may require further tuning for systems with less than the recommended RAM "
"requirements."
msgstr ""
"В качестве минимального значения общий объем оперативной памяти системы "
"должен составлять не менее одного гигабайта. Рекомендуемый объем оперативной "
"памяти зависит от размера пула и используемых возможностей ZFS. Общее "
"правило — 1 ГБ оперативной памяти на каждый 1 ТБ дискового пространства. При "
"использовании функции дедупликации рекомендуется выделять 5 ГБ оперативной "
"памяти на каждый 1 ТБ хранилища. Хотя некоторые пользователи используют ZFS "
"с меньшим объемом оперативной памяти, системы под высокой нагрузкой могут "
"завершаться аварийно из-за нехватки памяти. Для систем с объемом оперативной "
"памяти меньше рекомендуемого может потребоваться дополнительная настройка "
"ZFS."

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:2744
#, no-wrap
msgid "Kernel Configuration"
msgstr "Настройка ядра"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2747
msgid ""
"Due to the address space limitations of the i386(TM) platform, ZFS users on "
"the i386(TM) architecture must add this option to a custom kernel "
"configuration file, rebuild the kernel, and reboot:"
msgstr ""
"Из-за ограничений адресного пространства платформы i386(TM), пользователям "
"ZFS на архитектуре i386(TM) необходимо добавить следующую опцию в файл "
"конфигурации собственного ядра, пересобрать ядро и перезагрузить систему:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2751
#, no-wrap
msgid "options        KVA_PAGES=512\n"
msgstr "options        KVA_PAGES=512\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2756
msgid ""
"This expands the kernel address space, allowing the `vm.kvm_size` tunable to "
"push beyond the imposed limit of 1 GB, or the limit of 2 GB for PAE.  To "
"find the most suitable value for this option, divide the desired address "
"space in megabytes by four.  In this example `512` for 2 GB."
msgstr ""
"Это расширяет адресное пространство ядра, позволяя настройке `vm.kvm_size` "
"выйти за установленный предел в 1 ГБ или предел в 2 ГБ для PAE. Чтобы найти "
"наиболее подходящее значение для этой опции, разделите желаемое адресное "
"пространство в мегабайтах на четыре. В данном примере `512` для 2 ГБ."

#. type: Title ====
#: documentation/content/en/books/handbook/zfs/_index.adoc:2757
#, no-wrap
msgid "Loader Tunables"
msgstr "Настройки загрузчика"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2761
msgid ""
"Increases the [.filename]#kmem# address space on all FreeBSD architectures.  "
"A test system with 1 GB of physical memory benefitted from adding these "
"options to [.filename]#/boot/loader.conf# and then restarting:"
msgstr ""
"Увеличивает адресное пространство `kmem` на всех архитектурах FreeBSD. "
"Тестовая система с 1 ГБ физической памяти показала улучшение после "
"добавления этих параметров в `/boot/loader.conf` и последующей перезагрузки:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/zfs/_index.adoc:2768
#, no-wrap
msgid ""
"vm.kmem_size=\"330M\"\n"
"vm.kmem_size_max=\"330M\"\n"
"vfs.zfs.arc.max=\"40M\"\n"
"vfs.zfs.vdev.cache.size=\"5M\"\n"
msgstr ""
"vm.kmem_size=\"330M\"\n"
"vm.kmem_size_max=\"330M\"\n"
"vfs.zfs.arc.max=\"40M\"\n"
"vfs.zfs.vdev.cache.size=\"5M\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2771
msgid ""
"For a more detailed list of recommendations for ZFS-related tuning, see "
"https://wiki.freebsd.org/ZFSTuningGuide[]."
msgstr ""
"Для более подробного списка рекомендаций по настройке ZFS см. https://wiki."
"freebsd.org/ZFSTuningGuide[]."

#. type: Title ==
#: documentation/content/en/books/handbook/zfs/_index.adoc:2773
#, no-wrap
msgid "Further Resources"
msgstr "Дополнительные ресурсы"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2776
msgid "https://openzfs.org/[OpenZFS]"
msgstr "https://openzfs.org/[OpenZFS]"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2777
msgid "https://wiki.freebsd.org/ZFSTuningGuide[FreeBSD Wiki - ZFS Tuning]"
msgstr "https://wiki.freebsd.org/ZFSTuningGuide[FreeBSD Wiki - Настройка ZFS]"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2778
msgid ""
"https://calomel.org/zfs_raid_speed_capacity.html[Calomel Blog - ZFS Raidz "
"Performance, Capacity and Integrity]"
msgstr ""
"https://calomel.org/zfs_raid_speed_capacity.html[Calomel Blog - ZFS Raidz "
"Performance, Capacity and Integrity]"

#. type: Title ==
#: documentation/content/en/books/handbook/zfs/_index.adoc:2780
#, no-wrap
msgid "ZFS Features and Terminology"
msgstr "Особенности и терминология ZFS"

#. type: Plain text
#: documentation/content/en/books/handbook/zfs/_index.adoc:2789
msgid ""
"More than a file system, ZFS is fundamentally different.  ZFS combines the "
"roles of file system and volume manager, enabling new storage devices to add "
"to a live system and having the new space available on the existing file "
"systems in that pool at once.  By combining the traditionally separate "
"roles, ZFS is able to overcome previous limitations that prevented RAID "
"groups being able to grow.  A _vdev_ is a top level device in a pool and can "
"be a simple disk or a RAID transformation such as a mirror or RAID-Z array.  "
"ZFS file systems (called _datasets_) each have access to the combined free "
"space of the entire pool.  Used blocks from the pool decrease the space "
"available to each file system.  This approach avoids the common pitfall with "
"extensive partitioning where free space becomes fragmented across the "
"partitions."
msgstr ""
"ZFS — это не просто файловая система, а принципиально иной подход. ZFS "
"объединяет функции файловой системы и менеджера томов, позволяя добавлять "
"новые устройства хранения в работающую систему и сразу же использовать новое "
"пространство в существующих файловых системах пула. Благодаря объединению "
"традиционно разделённых ролей, ZFS преодолевает прежние ограничения, которые "
"мешали расширению RAID-групп. Устройство _vdev_ — это устройство верхнего "
"уровня в пуле, которое может быть простым диском или RAID-преобразованием, "
"таким как зеркало или массив RAID-Z. Файловые системы ZFS (называемые "
"_наборами данных_) имеют доступ к объединённому свободному пространству "
"всего пула. Используемые блоки из пула уменьшают доступное пространство для "
"каждой файловой системы. Такой подход позволяет избежать распространённой "
"проблемы с разбиением на разделы, когда свободное пространство "
"фрагментируется между разделами."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2795
#, no-wrap
msgid "[[zfs-term-pool]]pool"
msgstr "[[zfs-term-pool]]pool"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2798
#, no-wrap
msgid ""
"A storage _pool_ is the most basic building block of ZFS. A pool consists of one or more vdevs, the underlying devices that store the data. A pool is then used to create one or more file systems (datasets) or block devices (volumes).\n"
"These datasets and volumes share the pool of remaining free space. Each pool is uniquely identified by a name and a GUID. The ZFS version number on the pool determines the features available."
msgstr ""
"Пул (_pool_) — это базовая строительная единица ZFS. Оно состоит из одного или нескольких vdev — устройств хранения данных. На основе хранилища создаются файловые системы (наборы данных, datasets) или блочные устройства (тома, volumes).\n"
"Эти наборы данных и тома используют общий пул свободного пространства. Каждый пул имеет уникальное имя и GUID. Доступные функции определяются версией ZFS, используемой в пуле."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2799
#, no-wrap
msgid "[[zfs-term-vdev]]vdev Types"
msgstr "[[zfs-term-vdev]]vdev Types"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2832
#, no-wrap
msgid ""
"A pool consists of one or more vdevs, which themselves are a single disk or a group of disks, transformed to a RAID. When using a lot of vdevs, ZFS spreads data across the vdevs to increase performance and maximize usable space. All vdevs must be at least 128 MB in size.\n"
"\n"
"* [[zfs-term-vdev-disk]] _Disk_ - The most basic vdev type is a standard block device. This can be an entire disk (such as [.filename]#/dev/ada0# or [.filename]#/dev/da0#) or a partition ([.filename]#/dev/ada0p3#). On FreeBSD, there is no performance penalty for using a partition rather than the entire disk. This differs from recommendations made by the Solaris documentation.\n"
"+\n"
"[CAUTION]\n"
"====\n"
"Using an entire disk as part of a bootable pool is strongly discouraged, as this may render the pool unbootable.\n"
"Likewise, you should not use an entire disk as part of a mirror or RAID-Z vdev.\n"
"Reliably determining the size of an unpartitioned disk at boot time is impossible and there's no place to put in boot code.\n"
"====\n"
"\n"
"* [[zfs-term-vdev-file]] _File_ - Regular files may make up ZFS pools, which is useful for testing and experimentation. Use the full path to the file as the device path in `zpool create`.\n"
"* [[zfs-term-vdev-mirror]] _Mirror_ - When creating a mirror, specify the `mirror` keyword followed by the list of member devices for the mirror. A mirror consists of two or more devices, writing all data to all member devices. A mirror vdev will hold as much data as its smallest member. A mirror vdev can withstand the failure of all but one of its members without losing any data.\n"
"+\n"
"[NOTE]\n"
"====\n"
"To upgrade a regular single disk vdev to a mirror vdev at any time, use `zpool\n"
"crossref:zfs[zfs-zpool-attach,attach]`.\n"
"====\n"
"\n"
"* [[zfs-term-vdev-raidz]] _RAID-Z_ - ZFS uses RAID-Z, a variation on standard RAID-5 that offers better distribution of parity and eliminates the \"RAID-5 write hole\" in which the data and parity information become inconsistent after an unexpected restart. ZFS supports three levels of RAID-Z which provide varying levels of redundancy in exchange for decreasing levels of usable storage. ZFS uses RAID-Z1 through RAID-Z3 based on the number of parity devices in the array and the number of disks which can fail before the pool stops  being operational.\n"
"+\n"
"In a RAID-Z1 configuration with four disks, each 1 TB, usable storage is 3 TB and the pool will still be able to operate in degraded mode with one faulted disk. If another disk goes offline before replacing and resilvering the faulted disk would result in losing all pool data.\n"
"+\n"
"In a RAID-Z3 configuration with eight disks of 1 TB, the volume will provide 5 TB of usable space and still be able to operate with three faulted disks. Sun(TM) recommends no more than nine disks in a single vdev. If more disks make up the configuration, the recommendation is to divide them into separate vdevs and stripe the pool data across them.\n"
"+\n"
"A configuration of two RAID-Z2 vdevs consisting of 8 disks each would create something like a RAID-60 array. A RAID-Z group's storage capacity is about the size of the smallest disk multiplied by the number of non-parity disks. Four 1 TB disks in RAID-Z1 has an effective size of about 3 TB, and an array of eight 1 TB disks in RAID-Z3 will yield 5 TB of usable space.\n"
"* [[zfs-term-vdev-spare]] _Spare_ - ZFS has a special pseudo-vdev type for keeping track of available hot spares. Note that installed hot spares are not deployed automatically; manually configure them to replace the failed device using `zfs replace`.\n"
"* [[zfs-term-vdev-log]] _Log_ - ZFS Log Devices, also known as ZFS Intent Log\n"
"  (crossref:zfs[zfs-term-zil,ZIL]) move the intent log from the regular pool devices to a dedicated device, typically an SSD. Having a dedicated log device improves the performance of applications with a high volume of synchronous writes like databases. Mirroring of log devices is possible, but RAID-Z is not supported. If using a lot of log devices, writes will be load-balanced across them.\n"
"* [[zfs-term-vdev-cache]] _Cache_ - Adding a cache vdev to a pool will add the\n"
"  storage of the cache to the crossref:zfs[zfs-term-l2arc,L2ARC]. Mirroring cache devices is impossible. Since a cache device stores only new copies of existing data, there is no risk of data loss."
msgstr ""
"Пул состоит из одного или нескольких vdev, которые, в свою очередь, представляют собой отдельный диск или группу дисков, преобразованных в RAID. При использовании множества vdev ZFS распределяет данные между ними для повышения производительности и максимизации доступного пространства. Все vdev должны быть размером не менее 128 МБ.\n"
"\n"
"* [[zfs-term-vdev-disk]] _Диск_ — Самый базовый тип vdev — это стандартное блочное устройство. Это может быть целый диск (например, [.filename]#/dev/ada0# или [.filename]#/dev/da0#) или раздел ([.filename]#/dev/ada0p3#). В FreeBSD нет потери производительности при использовании раздела вместо целого диска. Это отличается от рекомендаций документации Solaris.\n"
"+\n"
"[CAUTION]\n"
"====\n"
"Настоятельно не рекомендуется использовать целый диск в составе загружаемого пула, так как это может сделать пул незагружаемым.\n"
"Аналогично, не следует использовать целый диск в составе зеркала (mirror) или RAID-Z vdev.\n"
"Надежное определение размера неразмеченного диска во время загрузки невозможно, и нет места для размещения загрузочного кода.\n"
"====\n"
"\n"
"* [[zfs-term-vdev-file]] _Файл_ — Обычные файлы могут составлять пулы ZFS, что полезно для тестирования и экспериментов. Используйте полный путь к файлу в качестве пути к устройству в команде `zpool create`.\n"
"* [[zfs-term-vdev-mirror]] _Зеркало (Mirror)_ - При создании зеркала укажите ключевое слово `mirror`, за которым следует список устройств-участников зеркала. Зеркало состоит из двух или более устройств, и все данные записываются на все устройства-участники. Зеркальный vdev будет хранить столько данных, сколько может поместиться на его самом маленьком устройстве. Зеркальный vdev может пережить отказ всех устройств, кроме одного, без потери данных.\n"
"+\n"
"[NOTE]\n"
"====\n"
"Чтобы в любой момент обновить обычный vdev с одним диском до зеркального vdev, используйте команду `zpool\n"
"crossref:zfs[zfs-zpool-attach,attach]`.\n"
"====\n"
"\n"
"* [[zfs-term-vdev-raidz]] _RAID-Z_ - ZFS использует RAID-Z — вариацию стандартного RAID-5, которая обеспечивает лучшее распределение четности и устраняет проблему \"записи дырки RAID-5\", когда данные и информация о четности становятся несогласованными после неожиданного перезапуска. ZFS поддерживает три уровня RAID-Z, которые обеспечивают разную степень избыточности в обмен на уменьшение доступного пространства. ZFS использует RAID-Z1, RAID-Z2 и RAID-Z3 в зависимости от количества устройств четности в массиве и количества дисков, которые могут отказать до того, как пул перестанет работать.\n"
"+\n"
"В конфигурации RAID-Z1 с четырьмя дисками по 1 ТБ доступное пространство составляет 3 ТБ, и пул сможет продолжать работу в деградированном режиме при отказе одного диска. Если другой диск выйдет из строя до замены и восстановления отказавшего диска, это приведет к потере всех данных пула.\n"
"+\n"
"В конфигурации RAID-Z3 с восемью дисками по 1 ТБ том предоставит 5 ТБ доступного пространства и сможет работать при отказе трех дисков. Sun(TM) рекомендует использовать не более девяти дисков в одном vdev. Если конфигурация состоит из большего количества дисков, рекомендуется разделить их на отдельные vdev и распределить данные пула между ними.\n"
"+\n"
"Конфигурация из двух RAID-Z2 vdev, каждый из которых состоит из 8 дисков, создаст аналог массива RAID-60. Емкость RAID-Z группы примерно равна размеру самого маленького диска, умноженному на количество дисков без четности. Четыре диска по 1 ТБ в RAID-Z1 дают эффективный размер около 3 ТБ, а массив из восьми дисков по 1 ТБ в RAID-Z3 обеспечит 5 ТБ доступного пространства.\n"
"* [[zfs-term-vdev-spare]] _Резервный (Spare)_ - ZFS имеет специальный псевдо-vdev для отслеживания доступных горячих резервов. Обратите внимание, что установленные горячие резервы не развертываются автоматически; их необходимо вручную настроить для замены отказавшего устройства с помощью команды `zfs replace`.\n"
"* [[zfs-term-vdev-log]] _Журнал (Log)_ - Устройства журнала ZFS, также известные как журнал намерений ZFS (Intent Log)\n"
"  (crossref:zfs[zfs-term-zil,ZIL]), перемещают журнал намерений с обычных устройств пула на выделенное устройство, обычно SSD. Наличие выделенного устройства журнала улучшает производительность приложений с большим объемом синхронных записей, таких как базы данных. Возможно зеркалирование устройств журнала, но RAID-Z не поддерживается. При записи на несколько устройств журнала нагрузка будут балансироваться между ними.\n"
"* [[zfs-term-vdev-cache]] _Кэш (Cache)_ - Добавление кэширующих vdev к пулу увеличит\n"
"  хранилище кэша в crossref:zfs[zfs-term-l2arc,L2ARC]. Зеркалирование устройств кэша невозможно. Поскольку устройство кэша хранит только новые копии существующих данных, риск потери данных отсутствует."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2833
#, no-wrap
msgid "[[zfs-term-txg]] Transaction Group (TXG)"
msgstr "[[zfs-term-txg]] Группы транзакций (TXG)"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2854
#, no-wrap
msgid ""
"Transaction Groups are the way ZFS groups blocks changes together and writes them to the pool. Transaction groups are the atomic unit that ZFS uses to ensure consistency. ZFS assigns each transaction group a unique 64-bit consecutive identifier. There can be up to three active transaction groups at a time, one in each of these three states:\n"
"\n"
"* _Open_ - A new transaction group begins in the open state and accepts new\n"
"  writes. There is always a transaction group in the open state, but the\n"
"  transaction group may refuse new writes if it has reached a limit. Once the\n"
"  open transaction group has reached a limit, or reaching the\n"
"  crossref:zfs[zfs-advanced-tuning-txg-timeout,`vfs.zfs.txg.timeout`], the transaction group advances to the next state.\n"
"* _Quiescing_ - A short state that allows any pending operations to finish without blocking the creation of a new open transaction group. Once all the transactions in the group have completed, the transaction group advances to the final state.\n"
"* _Syncing_ - Write all the data in the transaction group to stable storage.\n"
"  This process will in turn change other data, such as metadata and space maps,\n"
"  that ZFS will also write to stable storage. The process of syncing involves\n"
"  several passes. On the first and biggest, all the changed data blocks; next\n"
"  come the metadata, which may take several passes to complete. Since allocating\n"
"  space for the data blocks generates new metadata, the syncing state cannot\n"
"  finish until a pass completes that does not use any new space. The syncing\n"
"  state is also where _synctasks_ complete. Synctasks are administrative\n"
"  operations such as creating or destroying snapshots and datasets that complete\n"
"  the uberblock change. Once the sync state completes the transaction group in\n"
"  the quiescing state advances to the syncing state. All administrative\n"
"  functions, such as crossref:zfs[zfs-term-snapshot,`snapshot`] write as part of the transaction group. ZFS adds a created synctask to the open transaction group, and that group advances as fast as possible to the syncing state to reduce the latency of administrative commands."
msgstr ""
"Группы транзакций — это способ, которым ZFS объединяет изменения блоков и записывает их в пул. Группы транзакций являются атомарной единицей, используемой ZFS для обеспечения согласованности. ZFS назначает каждой группе транзакций уникальный 64-битный последовательный идентификатор. Одновременно может быть до трёх активных групп транзакций, каждая в одном из следующих состояний:\n"
"\n"
"* _Открытое (Open)_ — Новая группа транзакций начинается в открытом состоянии и\n"
"принимает новые операции записи. Всегда существует группа транзакций\n"
"в открытом состоянии, но она может отказать в приёме новых записей,\n"
"если достигнут лимит. Как только открытая группа транзакций достигает\n"
"лимита или срабатывает crossref:zfs[zfs-advanced-tuning-txg-timeout,`vfs.zfs.txg.timeout`], группа переходит в следующее состояние.\n"
"* _Завершающееся (Quiescing)_ — Краткое состояние, позволяющее завершить все ожидающие операции без блокировки создания новой открытой группы транзакций. Как только все транзакции в группе завершены, группа переходит в финальное состояние.\n"
"* _Синхронизируемое (Syncing)_ — Запись всех данных группы транзакций в устойчивое хранилище. Этот процесс, в свою очередь,\n"
"изменяет другие данные, такие как метаданные и карты пространства, которые ZFS также записывает в устойчивое хранилище.\n"
"Процесс синхронизации включает несколько проходов. На первом и самом большом записываются все изменённые блоки данных;\n"
"затем идут метаданные, которые могут потребовать нескольких проходов. Поскольку выделение пространства для блоков данных\n"
"генерирует новые метаданные, состояние синхронизации не может завершиться, пока не будет выполнен проход,\n"
"не использующий новое пространство. В состоянии синхронизации также завершаются _синхронизационные задачи_.\n"
"Синхронизационные задачи — это административные операции, такие как создание или удаление снимков и наборов данных,\n"
"завершающие изменение uberblock. Как только состояние синхронизации завершается, группа транзакций\n"
"в Завершающемся состоянии переходит в Синхронизируемое. Все административные функции, такие как crossref:zfs[zfs-term-snapshot,`снимок`],\n"
"записываются как часть группы транзакций. ZFS добавляет созданную синхронизационную задачу в открытую группу транзакций,\n"
"и эта группа как можно быстрее переходит в синхронизируемое состояние,\n"
"чтобы уменьшить задержку административных команд."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2855
#, no-wrap
msgid "[[zfs-term-arc]]Adaptive Replacement Cache (ARC)"
msgstr "[[zfs-term-arc]]Adaptive Replacement Cache (ARC)"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2857
#, no-wrap
msgid "ZFS uses an Adaptive Replacement Cache (ARC), rather than a more traditional Least Recently Used (LRU) cache. An LRU cache is a simple list of items in the cache, sorted by how recently object was used, adding new items to the head of the list. When the cache is full, evicting items from the tail of the list makes room for more active objects. An ARC consists of four lists; the Most Recently Used (MRU) and Most Frequently Used (MFU) objects, plus a ghost list for each. These ghost lists track evicted objects to prevent adding them back to the cache. This increases the cache hit ratio by avoiding objects that have a history of occasional use. Another advantage of using both an MRU and MFU is that scanning an entire file system would evict all data from an MRU or LRU cache in favor of this freshly accessed content. With ZFS, there is also an MFU that tracks the most frequently used objects, and the cache of the most commonly accessed blocks remains."
msgstr "ZFS использует Adaptive Replacement Cache (ARC), а не более традиционный кэш Least Recently Used (LRU). LRU-кэш — это простой список элементов в кэше, отсортированный по времени последнего использования объекта, при этом новые элементы добавляются в начало списка. Когда кэш заполнен, освобождение места для более активных объектов происходит за счёт удаления элементов из конца списка. ARC состоит из четырёх списков: Most Recently Used (MRU) и Most Frequently Used (MFU), а также дополнительных \"теневых\" списков для каждого из них. Эти теневые списки отслеживают удалённые объекты, чтобы предотвратить их повторное добавление в кэш. Это увеличивает процент попаданий в кэш, исключая объекты, которые использовались лишь изредка. Ещё одно преимущество использования как MRU, так и MFU заключается в том, что сканирование всей файловой системы вытеснило бы все данные из MRU- или LRU-кэша в пользу только что прочитанного содержимого. В ZFS также присутствует MFU, который отслеживает наиболее часто используемые объекты, и кэш наиболее часто запрашиваемых блоков остаётся неизменным."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2858
#, no-wrap
msgid "[[zfs-term-l2arc]]L2ARC"
msgstr "[[zfs-term-l2arc]]L2ARC"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2876
#, no-wrap
msgid ""
"L2ARC is the second level of the ZFS caching system. RAM stores the primary\n"
"ARC. Since the amount of available RAM is often limited, ZFS can also use\n"
"crossref:zfs[zfs-term-vdev-cache,cache vdevs]. Solid State Disks (SSDs) are\n"
"often used as these cache devices due to their higher speed and lower latency\n"
"compared to traditional spinning disks. L2ARC is entirely optional, but having\n"
"one will increase read speeds for cached files on the SSD instead of having to\n"
"read from the regular disks. L2ARC can also speed up\n"
"crossref:zfs[zfs-term-deduplication,deduplication] because a deduplication table\n"
"(DDT) that does not fit in RAM but does fit in the L2ARC will be much faster\n"
"than a DDT that must read from disk. Limits on the data rate added to the cache\n"
"devices prevents prematurely wearing out SSDs with extra writes. Until the cache\n"
"is full (the first block evicted to make room), writes to the L2ARC limit to the\n"
"sum of the write limit and the boost limit, and afterwards limit to the write\n"
"limit. A pair of man:sysctl[8] values control these rate limits.\n"
"crossref:zfs[zfs-advanced-tuning-l2arc_write_max,`vfs.zfs.l2arc_write_max`]\n"
"controls the number of bytes written to the cache per second, while\n"
"crossref:zfs[zfs-advanced-tuning-l2arc_write_boost,`vfs.zfs.l2arc_write_boost`] adds to this limit during the \"Turbo Warmup Phase\" (Write Boost)."
msgstr ""
"L2ARC — это второй уровень системы кэширования ZFS. Основной кэш (ARC) хранится в оперативной памяти.\n"
"Поскольку объем доступной оперативной памяти часто ограничен, ZFS также может использовать\n"
"crossref:zfs[zfs-term-vdev-cache,кэширующие vdev].\n"
"Твердотельные накопители (SSD) часто используются в качестве\n"
"таких кэширующих устройств благодаря их более высокой скорости и меньшей задержке по сравнению\n"
"с традиционными жесткими дисками. L2ARC полностью опционален, но его наличие увеличит скорость чтения\n"
"для кэшированных файлов на SSD, избавляя от необходимости читать с обычных дисков.\n"
"L2ARC также может ускорить crossref:zfs[zfs-term-deduplication,дедупликацию], поскольку таблица дедупликации (DDT),\n"
"которая не помещается в оперативную память, но помещается в L2ARC, будет работать значительно быстрее,\n"
"чем DDT, которую должны считать с диска. Ограничения на скорость записи данных\n"
"на кэширующие устройства предотвращают преждевременный износ SSD\n"
"из-за дополнительных операций записи. Пока кэш не заполнен (первый блок вытеснен для освобождения места),\n"
"записи в L2ARC ограничиваются суммой лимита записи и лимита ускорения,\n"
"а после - только лимитом записи. Пара значений man:sysctl[8] управляет этими ограничениями скорости.\n"
"crossref:zfs[zfs-advanced-tuning-l2arc_write_max,`vfs.zfs.l2arc_write_max`] контролирует количество байт,\n"
"записываемых в кэш в секунду, а crossref:zfs[zfs-advanced-tuning-l2arc_write_boost,`vfs.zfs.l2arc_write_boost`]\n"
"добавляется к этому лимиту во время \"Фазы турбо-разогрева\" (Write Boost)."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2877
#, no-wrap
msgid "[[zfs-term-zil]]ZIL"
msgstr "[[zfs-term-zil]]ZIL"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2879
#, no-wrap
msgid "ZIL accelerates synchronous transactions by using storage devices like SSDs that are faster than those used in the main storage pool. When an application requests a synchronous write (a guarantee that the data is stored to disk rather than merely cached for later writes), writing the data to the faster ZIL storage then later flushing it out to the regular disks greatly reduces latency and improves performance. Synchronous workloads like databases will profit from a ZIL alone. Regular asynchronous writes such as copying files will not use the ZIL at all."
msgstr "ZIL ускоряет синхронные транзакции, используя устройства хранения, такие как SSD, которые быстрее, чем устройства в основном пуле хранения. Когда приложение запрашивает синхронную запись (гарантию того, что данные записаны на диск, а не просто кэшированы для последующей записи), запись данных в более быстрый ZIL с последующей выгрузкой на обычные диски значительно снижает задержки и повышает производительность. Синхронные нагрузки, такие как базы данных, выиграют от использования одного только ZIL. Обычные асинхронные операции записи, например, копирование файлов, вообще не используют ZIL."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2880
#, no-wrap
msgid "[[zfs-term-cow]]Copy-On-Write"
msgstr "[[zfs-term-cow]]Копирование при Записи (Copy-On-Write)"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2882
#, no-wrap
msgid "Unlike a traditional file system, ZFS writes a different block rather than overwriting the old data in place. When completing this write the metadata updates to point to the new location. When a shorn write (a system crash or power loss in the middle of writing a file) occurs, the entire original contents of the file are still available and ZFS discards the incomplete write. This also means that ZFS does not require a man:fsck[8] after an unexpected shutdown."
msgstr "В отличие от традиционной файловой системы, ZFS записывает новый блок вместо перезаписи старых данных на том же месте. После завершения записи метаданные обновляются, указывая на новое местоположение. Если происходит обрыв записи (сбой системы или отключение питания во время записи файла), исходное содержимое файла остаётся доступным, а ZFS отменяет незавершённую запись. Это также означает, что ZFS не требует выполнения man:fsck[8] после неожиданного выключения."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2883
#, no-wrap
msgid "[[zfs-term-dataset]]Dataset"
msgstr "[[zfs-term-dataset]]Набор данных (Dataset)"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2893
#, no-wrap
msgid ""
"_Dataset_ is the generic term for a ZFS file system, volume, snapshot or clone.\n"
"Each dataset has a unique name in the format _poolname/path@snapshot_. The root\n"
"of the pool is a dataset as well. Child datasets have hierarchical names like\n"
"directories. For example, _mypool/home_, the home dataset, is a child of\n"
"_mypool_ and inherits properties from it. Expand this further by creating\n"
"_mypool/home/user_. This grandchild dataset will inherit properties from the\n"
"parent and grandparent. Set properties on a child to override the defaults\n"
"inherited from the parent and grandparent. Administration of datasets and their\n"
"children can be crossref:zfs[zfs-zfs-allow,delegated]."
msgstr ""
"_Набор данных_ — это общий термин для файловой системы ZFS, тома, снимка или клона.\n"
"Каждый набор данных имеет уникальное имя в формате _имяпула/путь@снимок_.\n"
"Корень пула также является набором данных. Дочерние наборы данных имеют иерархические имена, подобные каталогам.\n"
"Например, _mypool/home_, набор данных home, является дочерним для _mypool_ и наследует его свойства.\n"
"Это можно расширить, создав _mypool/home/user_. Этот внучатый набор данных будет\n"
"наследовать свойства от родительского и вышестоящего наборов данных.\n"
"Установка свойств для дочернего набора данных позволяет переопределить значения\n"
"по умолчанию, унаследованные от родительских наборов.\n"
"Управление наборами данных и их дочерними элементами может быть crossref:zfs[zfs-zfs-allow,делегировано]."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2894
#, no-wrap
msgid "[[zfs-term-filesystem]]File system"
msgstr "[[zfs-term-filesystem]]Файловая система"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2896
#, no-wrap
msgid "A ZFS dataset is most often used as a file system. Like most other file systems, a ZFS file system mounts somewhere in the systems directory hierarchy and contains files and directories of its own with permissions, flags, and other metadata."
msgstr "Набор данных ZFS чаще всего используется как файловая система. Как и большинство других файловых систем, файловая система ZFS монтируется в определённое место иерархии каталогов системы и содержит собственные файлы и каталоги с правами доступа, флагами и другими метаданными."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2897
#, no-wrap
msgid "[[zfs-term-volume]]Volume"
msgstr "[[zfs-term-volume]]Том"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2899
#, no-wrap
msgid "ZFS can also create volumes, which appear as disk devices. Volumes have a lot of the same features as datasets, including copy-on-write, snapshots, clones, and checksumming. Volumes can be useful for running other file system formats on top of ZFS, such as UFS virtualization, or exporting iSCSI extents."
msgstr "ZFS также может создавать тома, которые отображаются как дисковые устройства. Тома обладают многими функциями, аналогичными наборам данных, включая копирование при записи, снимки, клоны и контрольные суммы. Тома могут быть полезны для работы других файловых систем поверх ZFS, таких как виртуализация UFS или экспорт областей iSCSI."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2900
#, no-wrap
msgid "[[zfs-term-snapshot]]Snapshot"
msgstr "[[zfs-term-snapshot]]Снимок (Snapshot)"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2920
#, no-wrap
msgid ""
"The crossref:zfs[zfs-term-cow,copy-on-write] (COW) design of ZFS allows for\n"
"nearly instantaneous, consistent snapshots with arbitrary names. After taking a\n"
"snapshot of a dataset, or a recursive snapshot of a parent dataset that will\n"
"include all child datasets, new data goes to new blocks, but without reclaiming\n"
"the old blocks as free space. The snapshot contains the original file system\n"
"version and the live file system contains any changes made since taking the\n"
"snapshot using no other space. New data written to the live file system uses new\n"
"blocks to store this data. The snapshot will grow as the blocks are no longer\n"
"used in the live file system, but in the snapshot alone. Mount these snapshots\n"
"read-only allows recovering of previous file versions. A\n"
"crossref:zfs[zfs-zfs-snapshot,rollback] of a live file system to a specific\n"
"snapshot is possible, undoing any changes that took place after taking the\n"
"snapshot. Each block in the pool has a reference counter which keeps track of\n"
"the snapshots, clones, datasets, or volumes use that block. As files and\n"
"snapshots get deleted, the reference count  decreases, reclaiming the free space\n"
"when no longer referencing a block. Marking snapshots with a\n"
"crossref:zfs[zfs-zfs-snapshot,hold] results in any attempt to destroy it will\n"
"returns an `EBUSY` error. Each snapshot can have holds with a unique name each.\n"
"The crossref:zfs[zfs-zfs-snapshot,release] command removes the hold so the snapshot can deleted. Snapshots, cloning, and rolling back works on volumes, but independently mounting does not."
msgstr ""
"Дизайн crossref:zfs[zfs-term-cow,copy-on-write] (COW) в ZFS позволяет создавать\n"
"почти мгновенные, согласованные снимки с произвольными именами. После создания\n"
"снимка набора данных или рекурсивного снимка родительского набора, который\n"
"включит все дочерние наборы, новые данные записываются в новые блоки, но без\n"
"освобождения старых блоков как свободного пространства. Снимок содержит исходную\n"
"версию файловой системы, а активная файловая система — все изменения, сделанные\n"
"после создания снимка, не используя дополнительного пространства. Новые данные,\n"
"записанные в активную файловую систему, сохраняются в новых блоках. Снимок будет\n"
"расти по мере того, как блоки перестают использоваться в активной файловой системе\n"
"и остаются только в снимке. Монтирование этих снимков в режиме только для чтения\n"
"позволяет восстановить предыдущие версии файлов. \n"
"crossref:zfs[zfs-zfs-snapshot,Откат] активной файловой системы к определенному\n"
"снимку возможен, отменяя все изменения, произошедшие после создания снимка.\n"
"\n"
"Каждый блок в пуле имеет счетчик ссылок, который отслеживает использование этого\n"
"блока снимками, клонами, наборами данных или томами. По мере удаления файлов и\n"
"снимков счетчик ссылок уменьшается, освобождая пространство, когда блок больше\n"
"не используется. Если пометить снимки с помощью \n"
"crossref:zfs[zfs-zfs-snapshot,удержания (hold)], то это приведет к тому, что любая попытка удалить его вернет ошибку `EBUSY`. Каждый снимок может иметь удержания с уникальными именами. Команда crossref:zfs[zfs-zfs-snapshot,release] удаляет удержание, позволяя удалить снимок. Снимки, клонирование и откат работают с томами, но независимое монтирование — нет."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2921
#, no-wrap
msgid "[[zfs-term-clone]]Clone"
msgstr "[[zfs-term-clone]]Клон (Clone)"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2923
#, no-wrap
msgid "Cloning a snapshot is also possible. A clone is a writable version of a snapshot, allowing the file system to fork as a new dataset. As with a snapshot, a clone initially consumes no new space. As new data written to a clone uses new blocks, the size of the clone grows. When blocks are overwritten in the cloned file system or volume, the reference count on the previous block decreases. Removing the snapshot upon which a clone bases is impossible because the clone depends on it. The snapshot is the parent, and the clone is the child. Clones can be _promoted_, reversing this dependency and making the clone the parent and the previous parent the child. This operation requires no new space. Since the amount of space used by the parent and child reverses, it may affect existing quotas and reservations."
msgstr "Также возможно клонирование снимка. Клон — это доступная для записи версия снимка, позволяющая файловой системе разветвляться как новый набор данных. Как и снимок, клон изначально не занимает дополнительного пространства. По мере записи новых данных в клон используются новые блоки, и размер клона увеличивается. При перезаписи блоков в клонированной файловой системе или томе счетчик ссылок на предыдущий блок уменьшается. Удалить снимок, на котором основан клон, невозможно, потому что клон зависит от него. Снимок является родителем, а клон — потомком. Клоны можно _повышать_, меняя эту зависимость местами, делая клон родителем, а предыдущего родителя — потомком. Эта операция не требует дополнительного пространства. Поскольку объем пространства, используемого родителем и потомком, меняется местами, это может повлиять на существующие квоты и резервирования."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2924
#, no-wrap
msgid "[[zfs-term-checksum]]Checksum"
msgstr "[[zfs-term-checksum]]Контрольная сумма"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2936
#, no-wrap
msgid ""
"Every block is also checksummed. The checksum algorithm used is a per-dataset\n"
"property, see crossref:zfs[zfs-zfs-set,`set`]. The checksum of each block is\n"
"transparently validated when read, allowing ZFS to detect silent corruption. If\n"
"the data read does not match the expected checksum, ZFS will attempt to recover\n"
"the data from any available redundancy, like mirrors or RAID-Z. Triggering a\n"
"validation of all checksums with crossref:zfs[zfs-term-scrub,`scrub`]. Checksum algorithms include:\n"
"\n"
"* `fletcher2`\n"
"* `fletcher4`\n"
"* `sha256`\n"
" The `fletcher` algorithms are faster, but `sha256` is a strong cryptographic hash and has a much lower chance of collisions at the  cost of some performance. Deactivating checksums is possible, but  strongly discouraged."
msgstr ""
"Каждый блок также имеет контрольную сумму. Используемый алгоритм контрольной суммы\n"
"является свойством для каждого набора данных, см. crossref:zfs[zfs-zfs-set,`set`].\n"
"Контрольная сумма каждого блока прозрачно проверяется при чтении,\n"
"что позволяет ZFS обнаруживать скрытые повреждения. Если прочитанные данные не соответствуют ожидаемой контрольной сумме, ZFS попытается восстановить данные из любого доступного резервирования, например,\n"
"зеркал или RAID-Z. Запуск проверки всех контрольных сумм выполняется с помощью crossref:zfs[zfs-term-scrub,`scrub`]. Доступные алгоритмы контрольных сумм включают:\n"
"\n"
"* `fletcher2`\n"
"* `fletcher4`\n"
"* `sha256`\n"
"\n"
"Алгоритмы `fletcher` работают быстрее, но `sha256` является криптографически стойким хешем и имеет гораздо меньшую вероятность коллизий ценой некоторого снижения производительности. Возможно отключение контрольных сумм, но это крайне не рекомендуется."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2937
#, no-wrap
msgid "[[zfs-term-compression]]Compression"
msgstr "[[zfs-term-compression]]Сжатие"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2951
#, no-wrap
msgid ""
"Each dataset has a compression property, which defaults to off. Set this property to an available compression algorithm. This causes compression of all new data written to the dataset. Beyond a reduction in space used, read and write throughput often increases because fewer blocks need reading or writing.\n"
"\n"
"[[zfs-term-compression-lz4]]\n"
"* _LZ4_ - Added in ZFS pool version 5000 (feature flags), LZ4 is now the recommended compression algorithm. LZ4 works about 50% faster than LZJB when operating on compressible data, and is over three times faster when operating on uncompressible data. LZ4 also decompresses about 80% faster than LZJB. On modern CPUs, LZ4 can often compress at over 500 MB/s, and decompress at over 1.5 GB/s (per single CPU core).\n"
"\n"
"[[zfs-term-compression-lzjb]]\n"
"* _LZJB_ - The default compression algorithm. Created by Jeff Bonwick (one of the original creators of ZFS). LZJB offers good compression with less CPU overhead compared to GZIP. In the future, the default compression algorithm will change to LZ4.\n"
"\n"
"[[zfs-term-compression-gzip]]\n"
"* _GZIP_ - A popular stream compression algorithm available in ZFS. One of the main advantages of using GZIP is its configurable level of compression. When setting the `compress` property, the administrator can choose the level of compression, ranging from `gzip1`, the lowest level of compression, to `gzip9`, the highest level of compression. This gives the administrator control over how much CPU time to trade for saved disk space.\n"
"\n"
"[[zfs-term-compression-zle]]\n"
"* _ZLE_ - Zero Length Encoding is a special compression algorithm that compresses continuous runs of zeros alone. This compression algorithm is useful when the dataset contains large blocks of zeros."
msgstr ""
"Каждый набор данных имеет свойство сжатия, которое по умолчанию отключено. Установите это свойство в один из доступных алгоритмов сжатия. Это приведёт к сжатию всех новых данных, записываемых в набор данных. Помимо уменьшения используемого пространства, пропускная способность при чтении и записи часто увеличивается, поскольку требуется читать или записывать меньше блоков.\n"
"\n"
"[[zfs-term-compression-lz4]]\n"
"* _LZ4_ — добавлен в версии 5000 (флаги функций) пула ZFS и теперь является рекомендуемым алгоритмом сжатия. LZ4 работает примерно на 50% быстрее, чем LZJB, при работе с сжимаемыми данными и более чем в три раза быстрее при работе с несжимаемыми данными. LZ4 также распаковывает данные примерно на 80% быстрее, чем LZJB. На современных процессорах LZ4 часто может сжимать данные со скоростью более 500 МБ/с и распаковывать со скоростью более 1,5 ГБ/с (на одно ядро CPU).\n"
"\n"
"[[zfs-term-compression-lzjb]]\n"
"* _LZJB_ — алгоритм сжатия по умолчанию. Создан Джеффом Бонвиком (одним из оригинальных создателей ZFS). LZJB обеспечивает хорошее сжатие с меньшей нагрузкой на CPU по сравнению с GZIP. В будущем алгоритм сжатия по умолчанию изменится на LZ4.\n"
"\n"
"[[zfs-term-compression-gzip]]\n"
"* _GZIP_ — популярный алгоритм потокового сжатия, доступный в ZFS. Одним из основных преимуществ использования GZIP является настраиваемый уровень сжатия. При установке свойства `compress` администратор может выбрать уровень сжатия от `gzip1` (минимальный уровень сжатия) до `gzip9` (максимальный уровень сжатия). Это позволяет администратору контролировать баланс между использованием CPU и экономией дискового пространства.\n"
"\n"
"[[zfs-term-compression-zle]]\n"
"* _ZLE_ — Zero Length Encoding (кодирование нулевой длины) — это специальный алгоритм сжатия, который сжимает только непрерывные последовательности нулей. Этот алгоритм полезен, когда набор данных содержит большие блоки нулей."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2952
#, no-wrap
msgid "[[zfs-term-copies]]Copies"
msgstr "[[zfs-term-copies]]Копии"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2955
#, no-wrap
msgid ""
"When set to a value greater than 1, the `copies` property instructs ZFS to\n"
"maintain copies of each block in the crossref:zfs[zfs-term-filesystem,file\n"
"system] or crossref:zfs[zfs-term-volume,volume]. Setting this property on important datasets provides added redundancy from which to recover a block that does not match its checksum. In pools without redundancy, the copies feature is the single form of redundancy. The copies feature can recover from a single bad sector or other forms of minor corruption, but it does not protect the pool from the loss of an entire disk."
msgstr ""
"Когда свойству `Копии` присваивается значение больше 1, ZFS сохраняет копии каждого блока в crossref:zfs[zfs-term-filesystem,файловой системе] или crossref:zfs[zfs-term-volume,томе].\n"
"Установка этого свойства для важных наборов данных обеспечивает дополнительную избыточность, позволяющую восстановить блок, контрольная сумма которого не совпадает.\n"
"В пулах без избыточности функция копирования является единственной формой избыточности. Функция копирования позволяет восстановиться после повреждения отдельного сектора или других незначительных повреждений, но не защищает пул от потери всего диска."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2956
#, no-wrap
msgid "[[zfs-term-deduplication]]Deduplication"
msgstr "[[zfs-term-deduplication]]Дедубликация (Deduplication)"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2958
#, no-wrap
msgid "Checksums make it possible to detect duplicate blocks when writing data. With deduplication, the reference count of an existing, identical block increases, saving storage space. ZFS keeps a deduplication table (DDT) in memory to detect duplicate blocks. The table contains a list of unique checksums, the location of those blocks, and a reference count. When writing new data, ZFS calculates checksums and compares them to the list. When finding a match it uses the existing block. Using the SHA256 checksum algorithm with deduplication provides a secure cryptographic hash. Deduplication is tunable. If `dedup` is `on`, then a matching checksum means that the data is identical. Setting `dedup` to `verify`, ZFS performs a byte-for-byte check on the data ensuring they are actually identical. If the data is not identical, ZFS will note the hash collision and store the two blocks separately. As the DDT must store the hash of each unique block, it consumes a large amount of memory. A general rule of thumb is 5-6 GB of ram per 1 TB of deduplicated data). In situations not practical to have enough RAM to keep the entire DDT in memory, performance will suffer greatly as the DDT must read from disk before writing each new block. Deduplication can use L2ARC to store the DDT, providing a middle ground between fast system memory and slower disks. Consider using compression instead, which often provides nearly as much space savings without the increased memory."
msgstr "Контрольные суммы позволяют обнаруживать дублирующиеся блоки при записи данных. При дедупликации счетчик ссылок существующего идентичного блока увеличивается, что экономит место на диске. ZFS хранит таблицу дедупликации (DDT) в памяти для обнаружения дублирующихся блоков. Таблица содержит список уникальных контрольных сумм, расположение этих блоков и счетчик ссылок. При записи новых данных ZFS вычисляет контрольные суммы и сравнивает их со списком. При обнаружении совпадения используется существующий блок. Использование алгоритма контрольной суммы SHA256 с дедупликацией обеспечивает безопасное криптографическое хеширование. Дедупликация настраивается. Если `dedup` установлен в `on`, то совпадение контрольных сумм означает, что данные идентичны. Если `dedup` установлен в `verify`, ZFS выполняет побайтовую проверку данных, гарантируя их полное совпадение. Если данные не идентичны, ZFS зафиксирует коллизию хешей и сохранит два блока отдельно. Поскольку DDT должна хранить хеш каждого уникального блока, она потребляет значительный объем памяти. Общее правило — 5–6 ГБ оперативной памяти на 1 ТБ дедуплицированных данных. В ситуациях, когда невозможно иметь достаточно памяти для хранения всей DDT в оперативной памяти, производительность сильно снизится, так как DDT будет считываться с диска перед записью каждого нового блока. Дедупликация может использовать L2ARC для хранения DDT, что представляет собой компромисс между быстрой системной памятью и медленными дисками. Рекомендуется также рассмотреть использование сжатия, которое часто обеспечивает почти такую же экономию места без увеличения потребления памяти."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2959
#, no-wrap
msgid "[[zfs-term-scrub]]Scrub"
msgstr "[[zfs-term-scrub]]Scrub"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2970
#, no-wrap
msgid ""
"Instead of a consistency check like man:fsck[8], ZFS has `scrub`. `scrub` reads\n"
"all data blocks stored on the pool and verifies their checksums against the\n"
"known good checksums stored in the metadata. A periodic check of all the data\n"
"stored on the pool ensures the recovery of any corrupted blocks before needing\n"
"them. A scrub is not required after an unclean shutdown, but good practice is at\n"
"least once every three months. ZFS verifies the checksum of each block during\n"
"normal use, but a scrub makes certain to check even infrequently used blocks for\n"
"silent corruption. ZFS improves data security in archival storage situations.\n"
"Adjust the relative priority of `scrub` with\n"
"crossref:zfs[zfs-advanced-tuning-scrub_delay,`vfs.zfs.scrub_delay`] to prevent the scrub from degrading the performance of other workloads on the pool."
msgstr ""
"Вместо проверки согласованности, такой как man:fsck[8], в ZFS используется `scrub`.\n"
"`scrub` читает все блоки данных в пуле и проверяет их контрольные суммы по сравнению\n"
"с известными корректными контрольными суммами, хранящимися в метаданных.\n"
"Периодическая проверка всех данных в пуле гарантирует восстановление повреждённых блоков до того,\n"
"как они понадобятся. Проведение `scrub` не требуется после некорректного завершения работы,\n"
"но рекомендуется выполнять её хотя бы раз в три месяца. ZFS проверяет контрольные суммы каждого блока\n"
"при обычном использовании, но `scrub` обеспечивает проверку даже редко используемых блоков\n"
"на тихую порчу данных. ZFS повышает безопасность данных в архивных системах хранения.\n"
"Настройте относительный приоритет `scrub` с помощью crossref:zfs[zfs-advanced-tuning-scrub_delay,`vfs.zfs.scrub_delay`],\n"
"чтобы предотвратить снижение производительности других задач в пуле из-за проверки."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2971
#, no-wrap
msgid "[[zfs-term-quota]]Dataset Quota"
msgstr "[[zfs-term-quota]]Квота набора данных"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2985
#, no-wrap
msgid ""
"ZFS provides fast and accurate dataset, user, and group space accounting as well as quotas and space reservations. This gives the administrator fine grained control over space allocation and allows reserving space for critical file systems.\n"
"\n"
"ZFS supports different types of quotas: the dataset quota, the\n"
"crossref:zfs[zfs-term-refquota,reference quota (refquota)], the\n"
"crossref:zfs[zfs-term-userquota,user quota], and the\n"
"crossref:zfs[zfs-term-groupquota,group quota].\n"
"\n"
"Quotas limit the total size of a dataset and its descendants, including snapshots of the dataset, child datasets, and the snapshots of those datasets.\n"
"\n"
"[NOTE]\n"
"====\n"
"Volumes do not support quotas, as the `volsize` property acts as an implicit quota.\n"
"===="
msgstr ""
"ZFS обеспечивает быстрый и точный учет пространства для наборов данных, пользователей и групп, а также квоты и резервирование пространства. Это дает администратору детальный контроль над распределением пространства и позволяет резервировать место для критически важных файловых систем.\n"
"\n"
"ZFS поддерживает различные типы квот: квоту набора данных,\n"
"crossref:zfs[zfs-term-refquota,референтную квоту (refquota)],\n"
"crossref:zfs[zfs-term-userquota,пользовательскую квоту] и\n"
"crossref:zfs[zfs-term-groupquota,групповую квоту].\n"
"\n"
"Квоты ограничивают общий размер набора данных и его потомков, включая снимки набора данных, дочерние наборы данных и снимки этих наборов данных.\n"
"\n"
"[NOTE]\n"
"====\n"
"Тома не поддерживают квоты, так как свойство `volsize` действует как неявная квота.\n"
"===="

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2986
#, no-wrap
msgid "[[zfs-term-refquota]]Reference Quota"
msgstr "[[zfs-term-refquota]]Квота ссылки"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2988
#, no-wrap
msgid "A reference quota limits the amount of space a dataset can consume by enforcing a hard limit. This hard limit includes space referenced by the dataset alone and does not include space used by descendants, such as file systems or snapshots."
msgstr "Референтная квота ограничивает объем пространства, который может занимать набор данных, устанавливая жесткий лимит. Этот жесткий лимит включает только пространство, на которое ссылается сам набор данных, и не учитывает пространство, используемое его потомками, такими как файловые системы или снимки."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2989
#, no-wrap
msgid "[[zfs-term-userquota]]User Quota"
msgstr "[[zfs-term-userquota]]Квота пользователя"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2991
#, no-wrap
msgid "User quotas are useful to limit the amount of space used by the specified user."
msgstr "Пользовательские квоты полезны для ограничения объема пространства, используемого указанным пользователем."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2992
#, no-wrap
msgid "[[zfs-term-groupquota]]Group Quota"
msgstr "[[zfs-term-groupquota]]Квота группы"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2994
#, no-wrap
msgid "The group quota limits the amount of space that a specified group can consume."
msgstr "Квота группы ограничивает объем пространства, который может использовать указанная группа."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:2995
#, no-wrap
msgid "[[zfs-term-reservation]]Dataset Reservation"
msgstr "[[zfs-term-reservation]]Резервирование для набора данных"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3003
#, no-wrap
msgid ""
"The `reservation` property makes it possible to guarantee an amount of space\n"
"for a specific dataset and its descendants. This means that setting a 10 GB\n"
"reservation on [.filename]#storage/home/bob# prevents other datasets from using\n"
"up all free space, reserving at least 10 GB of space for this dataset. Unlike a\n"
"regular crossref:zfs[zfs-term-refreservation,`refreservation`], space used by snapshots and descendants is not counted against the reservation. For example, if taking a snapshot of [.filename]#storage/home/bob#, enough disk space other than the `refreservation` amount must exist for the operation to succeed. Descendants of the main data set are not counted in the `refreservation` amount and so do not encroach on the space set.\n"
"\n"
"Reservations of any sort are useful in situations such as planning and testing the suitability of disk space allocation in a new system, or ensuring that enough space is available on file systems for audio logs or system recovery procedures and files."
msgstr ""
"Свойство `reservation` позволяет гарантировать определённый объём пространства для конкретного набора данных и его потомков.\n"
"Это означает, что установка резерва в 10 ГБ для [.filename]#storage/home/bob# предотвращает использование всего свободного пространства другими наборами данных, резервируя как минимум 10 ГБ для этого набора.\n"
"В отличие от обычного `reservation`, при crossref:zfs[zfs-term-refreservation,`refreservation`] пространство, используемое снимками и потомками,\n"
"не учитывается в резерве. Например, при создании снимка [.filename]#storage/home/bob# для успешного выполнения операции должно быть достаточно дискового пространства, помимо объёма `refreservation`.\n"
"Потомки основного набора данных не учитываются в объёме `refreservation` и, следовательно, не занимают зарезервированное пространство.\n"
"\n"
"Резервирование любого типа полезно в таких ситуациях, как планирование и тестирование распределения дискового пространства в новой системе, или для обеспечения достаточного места в файловых системах для аудио-логов, процедур восстановления системы и файлов."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3004
#, no-wrap
msgid "[[zfs-term-refreservation]]Reference Reservation"
msgstr "[[zfs-term-refreservation]]Референтное резервирование"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3010
#, no-wrap
msgid ""
"The `refreservation` property makes it possible to guarantee an amount of space\n"
"for the use of a specific dataset _excluding_ its descendants. This means that\n"
"setting a 10 GB reservation on [.filename]#storage/home/bob#, and another\n"
"dataset tries to use the free space, reserving at least 10 GB of space  for this\n"
"dataset. In contrast to a regular crossref:zfs[zfs-term-reservation,reservation], space used by snapshots and descendant datasets is not counted against the reservation. For example, if taking a snapshot of [.filename]#storage/home/bob#, enough disk space other than the `refreservation` amount must exist for the operation to succeed. Descendants of the  main data set are not counted in the `refreservation` amount and so do not encroach on the space set."
msgstr ""
"Свойство `refreservation` позволяет гарантировать определённый объём пространства\n"
"для использования конкретным набором данных _исключая_ его потомков.\n"
"Это означает, что если установить резервирование в 10 ГБ для [.filename]#storage/home/bob#, а другой набор данных попытается использовать свободное пространство, то он оставит как минимум 10 ГБ, зарезервированных для [.filename]#storage/home/bob#.\n"
"В отличие от обычного crossref:zfs[zfs-term-reservation,резервирования], пространство,\n"
"используемое снимками и наборами-потомками, не учитывается в резервировании. Например, при создании снимка [.filename]#storage/home/bob# для успешного выполнения операции должно быть достаточно места на диске помимо объёма, указанного в `refreservation`. Наборы данных-потомки не учитываются в объёме `refreservation` и, следовательно, не уменьшают зарезервированное пространство."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3011
#, no-wrap
msgid "[[zfs-term-resilver]]Resilver"
msgstr "[[zfs-term-resilver]]Ресильверинг"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3012
#, no-wrap
msgid "When replacing a failed disk, ZFS must fill the new disk with the lost data. _Resilvering_ is the process of using the parity information distributed across the remaining drives to calculate and write the missing data to the new drive."
msgstr "При замене вышедшего из строя диска ZFS необходимо заполнить новый диск утерянными данными. _Ресильверинг_ (resilvering — серебрение, восстановление зеркала) — это процесс использования информации о четности, распределенной по оставшимся дискам, для вычисления и записи отсутствующих данных на новый диск."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3013
#, no-wrap
msgid "[[zfs-term-online]]Online"
msgstr "[[zfs-term-online]]Online"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3015
#, no-wrap
msgid "A pool or vdev in the `Online` state has its member devices connected and fully operational. Individual devices in the `Online` state are functioning."
msgstr "Пул или vdev в состоянии `Online` имеет подключенные и полностью работоспособные устройства-участники. Отдельные устройства в состоянии `Online` функционируют."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3016
#, no-wrap
msgid "[[zfs-term-offline]]Offline"
msgstr "[[zfs-term-offline]]Offline"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3020
#, no-wrap
msgid ""
"The administrator puts individual devices in an `Offline` state if enough\n"
"redundancy exists to avoid putting the pool or vdev into a\n"
"crossref:zfs[zfs-term-faulted,Faulted] state. An administrator may choose to offline a disk in preparation for replacing it, or to make it easier to identify."
msgstr ""
"Администратор переводит отдельные устройства в состояние `Offline`,\n"
"если существует достаточная избыточность, чтобы избежать перевода пула или vdev в состояние crossref:zfs[zfs-term-faulted,Faulted].\n"
"Администратор может отключить диск для подготовки к его замене или для упрощения идентификации."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3021
#, no-wrap
msgid "[[zfs-term-degraded]]Degraded"
msgstr "[[zfs-term-degraded]]Degraded"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3028
#, no-wrap
msgid ""
"A pool or vdev in the `Degraded` state has one or more disks that disappeared\n"
"or failed. The pool is still usable, but if other devices fail, the pool may\n"
"become unrecoverable. Reconnecting the missing devices or replacing the failed\n"
"disks will return the pool to an crossref:zfs[zfs-term-online,Online] state\n"
"after the reconnected or new device has completed the\n"
"crossref:zfs[zfs-term-resilver,Resilver] process."
msgstr ""
"Пул или vdev в состоянии `Degraded` имеет один или несколько дисков, которые исчезли или вышли из строя.\n"
"Пул по-прежнему можно использовать, но если другие устройства выйдут из строя, пул может стать невосстановимым.\n"
"Повторное подключение отсутствующих устройств\n"
"или замена неисправных дисков вернет пул\n"
"в состояние crossref:zfs[zfs-term-online,Online] после того,\n"
"как повторно подключенное или новое устройство завершит процесс crossref:zfs[zfs-term-resilver,ресильверинга]."

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3029
#, no-wrap
msgid "[[zfs-term-faulted]]Faulted"
msgstr "[[zfs-term-faulted]]Faulted"

#. type: Table
#: documentation/content/en/books/handbook/zfs/_index.adoc:3034
#, no-wrap
msgid ""
"A pool or vdev in the `Faulted` state is no longer operational. Accessing the\n"
"data is no longer possible. A pool or vdev enters the `Faulted` state when the\n"
"number of missing or failed devices exceeds the level of redundancy in the vdev.\n"
"If reconnecting missing devices the pool will return to an\n"
"crossref:zfs[zfs-term-online,Online] state. Insufficient redundancy to compensate for the number of failed disks loses the pool contents and requires restoring from backups."
msgstr ""
"Пул или vdev в состоянии `Faulted` больше не функционирует. Доступ к данным становится невозможным.\n"
"Пул или vdev переходит в состояние `Faulted`, когда количество отсутствующих или неисправных устройств\n"
"превышает уровень избыточности vdev.\n"
"Если отсутствующие устройства будут снова подключены, пул вернётся в состояние crossref:zfs[zfs-term-online,Online].\n"
"Недостаточная избыточность для компенсации количества неисправных дисков приводит к потере содержимого пула и требует восстановления из резервных копий."
