# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Kyung-tak, Yoo <stonegaze@me.com>, 2023.
# "Kyung-tak, Yoo" <stonegaze@me.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2025-05-01 19:56-0300\n"
"PO-Revision-Date: 2023-08-26 02:56+0000\n"
"Last-Translator: \"Kyung-tak, Yoo\" <stonegaze@me.com>\n"
"Language-Team: Korean <https://translate-dev.freebsd.org/projects/"
"documentation/bookshandbookdisks_index/ko/>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.17\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/disks/_index.adoc:1
#, no-wrap
msgid "This chapter covers the use of disks and storage media in FreeBSD. This includes SCSI and IDE disks, CD and DVD media, memory-backed disks, and USB storage devices."
msgstr "이 장에서는 FreeBSD에서 디스크와 저장 매체의 사용에 대해 다룹니다. 여기에는 SCSI 및 IDE 디스크, CD 및 DVD 미디어, 메모리 지원 디스크, USB 저장 장치가 포함됩니다."

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/disks/_index.adoc:1
#, no-wrap
msgid "Part III. System Administration"
msgstr "파트 III. 시스템 관리"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/disks/_index.adoc:1
#, no-wrap
msgid "Chapter 20. Storage"
msgstr "20장. 스토리지"

#. type: Title =
#: documentation/content/en/books/handbook/disks/_index.adoc:15
#, no-wrap
msgid "Storage"
msgstr "스토리지"

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:53
#, no-wrap
msgid "Synopsis"
msgstr "요약"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:57
msgid ""
"This chapter covers the use of disks and storage media in FreeBSD.  This "
"includes SCSI and IDE disks, CD and DVD media, memory-backed disks, and USB "
"storage devices."
msgstr ""
"이 장에서는 FreeBSD에서 디스크와 저장 매체의 사용에 대해 다룹니다.  여기에는 "
"SCSI 및 IDE 디스크, CD 및 DVD 미디어, 메모리 지원 디스크, USB 저장 장치가 포"
"함됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:59
msgid "After reading this chapter, you will know:"
msgstr "이 장을 읽고 나면 다음을 알 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:61
msgid "How to add additional hard disks to a FreeBSD system."
msgstr "FreeBSD 시스템에 하드디스크를 추가하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:62
msgid "How to grow the size of a disk's partition on FreeBSD."
msgstr "FreeBSD에서 디스크 파티션의 크기를 늘리는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:63
msgid "How to configure FreeBSD to use USB storage devices."
msgstr "USB 저장 장치를 사용하도록 FreeBSD를 구성하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:64
msgid "How to use CD and DVD media on a FreeBSD system."
msgstr "FreeBSD 시스템에서 CD 및 DVD 미디어를 사용하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:65
msgid "How to use the backup programs available under FreeBSD."
msgstr "FreeBSD에서 제공되는 백업 프로그램을 사용하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:66
msgid "How to set up memory disks."
msgstr "메모리 디스크를 설정하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:67
msgid "What file system snapshots are and how to use them efficiently."
msgstr "파일 시스템 스냅샷의 정의와 효율적인 사용 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:68
msgid "How to use quotas to limit disk space usage."
msgstr "할당량을 사용하여 디스크 공간 사용량을 제한하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:69
msgid "How to encrypt disks and swap to secure them against attackers."
msgstr "디스크를 암호화하고 스왑하여 공격자로부터 보호하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:70
msgid "How to configure a highly available storage network."
msgstr "고가용성 스토리지 네트워크를 구성하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:72
msgid "Before reading this chapter, you should:"
msgstr "이 챕터를 읽기 전에 알아두어야 할 사항입니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:74
msgid ""
"Know how to crossref:kernelconfig[kernelconfig,configure and install a new "
"FreeBSD kernel]."
msgstr ""
"crossref:kernelconfig[kernelconfig,configure and install a new FreeBSD "
"kernel] 방법을 알아야 합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:76
#, no-wrap
msgid "Adding Disks"
msgstr "디스크 추가하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:81
msgid ""
"This section describes how to add a new SATA disk to a machine that "
"currently only has a single drive.  First, turn off the computer and install "
"the drive in the computer following the instructions of the computer, "
"controller, and drive manufacturers.  Reboot the system and become `root`."
msgstr ""
"이 섹션에서는 현재 드라이브가 하나만 있는 컴퓨터에 새 SATA 디스크를 추가하는 "
"방법을 설명합니다.  먼저 컴퓨터를 끄고 컴퓨터, 컨트롤러 및 드라이브 제조업체"
"의 지침에 따라 컴퓨터에 드라이브를 설치합니다.  시스템을 재부팅하고 `root` "
"가 됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:84
msgid ""
"Inspect [.filename]#/var/run/dmesg.boot# to ensure the new disk was found.  "
"In this example, the newly added SATA drive will appear as [.filename]#ada1#."
msgstr ""
"[.filename]#/var/run/dmesg.boot# 를 검사하여 새 디스크가 발견되었는지 확인합"
"니다.  이 예제에서는 새로 추가된 SATA 드라이브가 [.filename]#ada1# 으로 표시"
"됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:87
#, fuzzy
#| msgid ""
#| "For this example, a single large partition will be created on the new "
#| "disk.  The http://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] "
#| "partitioning scheme will be used in preference to the older and less "
#| "versatile MBR scheme."
msgid ""
"For this example, a single large partition will be created on the new disk.  "
"The https://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] partitioning "
"scheme will be used in preference to the older and less versatile MBR scheme."
msgstr ""
"이 예에서는 새 디스크에 하나의 큰 파티션이 만들어집니다.  더 오래되고 활용도"
"가 낮은 MBR 스키마 대신, http://en.wikipedia.org/wiki/"
"GUID_Partition_Table[GPT] 파티션 스키마를 우선적으로 사용할 것입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:92
msgid ""
"If the disk to be added is not blank, old partition information can be "
"removed with `gpart delete`.  See man:gpart[8] for details."
msgstr ""
"추가할 디스크가 비어있지 않으면 `gpart delete` 로 이전 파티션 정보를 제거할 "
"수 있습니다.  자세한 내용은 man:gpart[8]를 참고하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:96
msgid ""
"The partition scheme is created, and then a single partition is added.  To "
"improve performance on newer disks with larger hardware block sizes, the "
"partition is aligned to one megabyte boundaries:"
msgstr ""
"파티션 스키마가 생성된 다음 단일 파티션이 추가됩니다.  하드웨어 블록 크기가 "
"더 큰 최신 디스크에서 성능을 향상시키기 위해 파티션은 1메가바이트 경계에 맞"
"춰 정렬됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:101
#, no-wrap
msgid ""
"# gpart create -s GPT ada1\n"
"# gpart add -t freebsd-ufs -a 1M ada1\n"
msgstr ""
"# gpart create -s GPT ada1\n"
"# gpart add -t freebsd-ufs -a 1M ada1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:105
msgid ""
"Depending on use, several smaller partitions may be desired.  See man:"
"gpart[8] for options to create partitions smaller than a whole disk."
msgstr ""
"용도에 따라 여러 개의 작은 파티션이 필요할 수 있습니다.  전체 디스크보다 작"
"은 파티션을 만드는 옵션은 man:gpart[8]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:107
msgid "The disk partition information can be viewed with `gpart show`:"
msgstr "디스크 파티션 정보는 `gpart show` 로 확인할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:115
#, no-wrap
msgid ""
"% gpart show ada1\n"
"=>        34  1465146988  ada1  GPT  (699G)\n"
"          34        2014        - free -  (1.0M)\n"
"        2048  1465143296     1  freebsd-ufs  (699G)\n"
"  1465145344        1678        - free -  (839K)\n"
msgstr ""
"% gpart show ada1\n"
"=>        34  1465146988  ada1  GPT  (699G)\n"
"          34        2014        - free -  (1.0M)\n"
"        2048  1465143296     1  freebsd-ufs  (699G)\n"
"  1465145344        1678        - free -  (839K)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:118
msgid "A file system is created in the new partition on the new disk:"
msgstr "새 디스크의 새 파티션에 파일 시스템이 만들어집니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:122
#, no-wrap
msgid "# newfs -U /dev/ada1p1\n"
msgstr "# newfs -U /dev/ada1p1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:125
msgid ""
"An empty directory is created as a _mountpoint_, a location for mounting the "
"new disk in the original disk's file system:"
msgstr ""
"원본 디스크의 파일 시스템에서 새 디스크를 마운트하기 위해, _마운트 포인트_ "
"로 사용할 빈 디렉터리를 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:129
#, no-wrap
msgid "# mkdir /newdisk\n"
msgstr "# mkdir /newdisk\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:132
msgid ""
"Finally, an entry is added to [.filename]#/etc/fstab# so the new disk will "
"be mounted automatically at startup:"
msgstr ""
"마지막으로 [.filename]#/etc/fstab# 에 항목을 추가하여 시작 시 새 디스크가 자"
"동으로 마운트되도록 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:136
#, no-wrap
msgid "/dev/ada1p1\t/newdisk\tufs\trw\t2\t2\n"
msgstr "/dev/ada1p1\t/newdisk\tufs\trw\t2\t2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:139
msgid "The new disk can be mounted manually, without restarting the system:"
msgstr ""
"새 디스크는 시스템을 다시 시작하지 않고도 수동으로 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:143
#, no-wrap
msgid "# mount /newdisk\n"
msgstr "# mount /newdisk\n"

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:146
#, no-wrap
msgid "Resizing and Growing Disks"
msgstr "디스크 크기 조정 및 크기 늘리기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:152
msgid ""
"A disk's capacity can increase without any changes to the data already "
"present.  This happens commonly with virtual machines, when the virtual disk "
"turns out to be too small and is enlarged.  Sometimes a disk image is "
"written to a USB memory stick, but does not use the full capacity.  Here we "
"describe how to resize or _grow_ disk contents to take advantage of "
"increased capacity."
msgstr ""
"디스크의 용량은 이미 존재하는 데이터를 변경하지 않고도 증가시킬 수 있습니"
"다.  이는 가상 머신에서 가상 디스크가 너무 작은 것으로 판명되어 확대할 때 주"
"로 발생합니다.  때때로 디스크 이미지가 USB 메모리 스틱에 기록되지만 전체 용량"
"을 사용하지 않는 경우가 있습니다.  여기에서는 늘어난 용량을 활용하기 위해 디"
"스크 콘텐츠의 크기를 조정하거나 _늘리는_ 방법을 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:155
msgid ""
"Determine the device name of the disk to be resized by inspecting [."
"filename]#/var/run/dmesg.boot#.  In this example, there is only one SATA "
"disk in the system, so the drive will appear as [.filename]#ada0#."
msgstr ""
"[.filename]#/var/run/dmesg.boot# 을 검사하여 크기를 조정할 디스크의 장치 이름"
"을 확인합니다.  이 예제에서는 시스템에 SATA 디스크가 하나만 있으므로 드라이브"
"가 [.filename]#ada0# 로 표시됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:157
msgid "List the partitions on the disk to see the current configuration:"
msgstr "디스크의 파티션을 나열하여 현재 구성을 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:166
#, no-wrap
msgid ""
"# gpart show ada0\n"
"=>      34  83886013  ada0  GPT  (48G) [CORRUPT]\n"
"        34       128     1  freebsd-boot  (64k)\n"
"       162  79691648     2  freebsd-ufs  (38G)\n"
"  79691810   4194236     3  freebsd-swap  (2G)\n"
"  83886046         1        - free -  (512B)\n"
msgstr ""
"# gpart show ada0\n"
"=>      34  83886013  ada0  GPT  (48G) [CORRUPT]\n"
"        34       128     1  freebsd-boot  (64k)\n"
"       162  79691648     2  freebsd-ufs  (38G)\n"
"  79691810   4194236     3  freebsd-swap  (2G)\n"
"  83886046         1        - free -  (512B)\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:172
#, fuzzy
#| msgid ""
#| "If the disk was formatted with the http://en.wikipedia.org/wiki/"
#| "GUID_Partition_Table[GPT] partitioning scheme, it may show as \"corrupted"
#| "\" because the GPT backup partition table is no longer at the end of the "
#| "drive.  Fix the backup partition table with `gpart`:"
msgid ""
"If the disk was formatted with the https://en.wikipedia.org/wiki/"
"GUID_Partition_Table[GPT] partitioning scheme, it may show as \"corrupted\" "
"because the GPT backup partition table is no longer at the end of the "
"drive.  Fix the backup partition table with `gpart`:"
msgstr ""
"디스크가 http://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] 파티션 스키마"
"로 포맷된 경우 GPT 백업 파티션 테이블이 더 이상 드라이브의 끝에 있지 않기 때"
"문에 \"corrupted\"으로 표시될 수 있습니다.  `gpart` 로 백업 파티션 테이블을 "
"수정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:177
#, no-wrap
msgid ""
"# gpart recover ada0\n"
"ada0 recovered\n"
msgstr ""
"# gpart recover ada0\n"
"ada0 recovered\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:182
msgid ""
"Now the additional space on the disk is available for use by a new "
"partition, or an existing partition can be expanded:"
msgstr ""
"이제 디스크의 추가 공간을 새 파티션에서 사용하거나 기존 파티션을 확장할 수 있"
"습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:191
#, no-wrap
msgid ""
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810    4194236     3  freebsd-swap  (2G)\n"
"   83886046   18513921        - free -  (8.8G)\n"
msgstr ""
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810    4194236     3  freebsd-swap  (2G)\n"
"   83886046   18513921        - free -  (8.8G)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:196
msgid ""
"Partitions can only be resized into contiguous free space.  Here, the last "
"partition on the disk is the swap partition, but the second partition is the "
"one that needs to be resized.  Swap partitions only contain temporary data, "
"so it can safely be unmounted, deleted, and then recreate the third "
"partition after resizing the second partition."
msgstr ""
"파티션은 인접한 여유 공간으로만 크기를 조정할 수 있습니다.  여기서 디스크의 "
"마지막 파티션은 스왑 파티션이지만 크기를 조정해야 하는 파티션은 두 번째 파티"
"션입니다.  스왑 파티션은 임시 데이터만 포함하므로 안전하게 마운트 해제하고 삭"
"제한 다음 두 번째 파티션의 크기를 조정한 후 세 번째 파티션을 다시 만들 수 있"
"습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:198
msgid "Disable the swap partition:"
msgstr "스왑 파티션을 비활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:202
#, no-wrap
msgid "# swapoff /dev/ada0p3\n"
msgstr "# swapoff /dev/ada0p3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:205
msgid ""
"Delete the third partition, specified by the `-i` flag, from the disk _ada0_."
msgstr "`-i` 플래그로 지정된 세 번째 파티션을 _ada0_ 디스크에서 삭제합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:215
#, no-wrap
msgid ""
"# gpart delete -i 3 ada0\n"
"ada0p3 deleted\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810   22708157        - free -  (10G)\n"
msgstr ""
"# gpart delete -i 3 ada0\n"
"ada0p3 deleted\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810   22708157        - free -  (10G)\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:223
msgid ""
"There is risk of data loss when modifying the partition table of a mounted "
"file system.  It is best to perform the following steps on an unmounted file "
"system while running from a live CD-ROM or USB device.  However, if "
"absolutely necessary, a mounted file system can be resized after disabling "
"GEOM safety features:"
msgstr ""
"마운트된 파일 시스템의 파티션 테이블을 수정하면 데이터가 손실될 위험이 있습니"
"다.  라이브 CD-ROM 또는 USB 장치에서 실행하는 동안 마운트되지 않은 파일 시스"
"템에서 다음 단계를 수행하는 것이 가장 좋습니다.  그러나 꼭 필요한 경우 GEOM "
"안전 기능을 비활성화한 후 마운트된 파일 시스템의 크기를 조정할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:227
#, no-wrap
msgid "# sysctl kern.geom.debugflags=16\n"
msgstr "# sysctl kern.geom.debugflags=16\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:236
msgid ""
"Resize the partition, leaving room to recreate a swap partition of the "
"desired size.  The partition to resize is specified with `-i`, and the new "
"desired size with `-s`.  Optionally, alignment of the partition is "
"controlled with `-a`.  This only modifies the size of the partition.  The "
"file system in the partition will be expanded in a separate step."
msgstr ""
"파티션 크기를 조정하여 원하는 크기의 스왑 파티션을 다시 만들 수 있는 공간을 "
"남겨 둡니다.  크기를 조정할 파티션은 `-i` 로 지정하고 새로 원하는 크기는 `-"
"s` 로 지정합니다.  선택적으로 파티션 정렬은 `-a` 로 제어합니다.  이것은 파티"
"션의 크기만 수정합니다.  파티션의 파일 시스템은 별도의 단계에서 확장됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:246
#, no-wrap
msgid ""
"# gpart resize -i 2 -s 47G -a 4k ada0\n"
"ada0p2 resized\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661        - free -  (1.8G)\n"
msgstr ""
"# gpart resize -i 2 -s 47G -a 4k ada0\n"
"ada0p2 resized\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661        - free -  (1.8G)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:250
msgid ""
"Recreate the swap partition and activate it.  If no size is specified with `-"
"s`, all remaining space is used:"
msgstr ""
"스왑 파티션을 다시 생성하고 활성화합니다.  `-s` 로 크기를 지정하지 않으면 남"
"은 공간이 모두 사용됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:261
#, no-wrap
msgid ""
"# gpart add -t freebsd-swap -a 4k ada0\n"
"ada0p3 added\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661     3  freebsd-swap  (1.8G)\n"
"# swapon /dev/ada0p3\n"
msgstr ""
"# gpart add -t freebsd-swap -a 4k ada0\n"
"ada0p3 added\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661     3  freebsd-swap  (1.8G)\n"
"# swapon /dev/ada0p3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:264
msgid ""
"Grow the UFS file system to use the new capacity of the resized partition:"
msgstr ""
"크기가 조정된 파티션의 새 용량을 사용하도록 UFS 파일 시스템을 확장합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:274
#, no-wrap
msgid ""
"# growfs /dev/ada0p2\n"
"Device is mounted read-write; resizing will result in temporary write suspension for /.\n"
"It's strongly recommended to make a backup before growing the file system.\n"
"OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes\n"
"super-block backups (for fsck -b #) at:\n"
" 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,\n"
" 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432\n"
msgstr ""
"# growfs /dev/ada0p2\n"
"Device is mounted read-write; resizing will result in temporary write suspension for /.\n"
"It's strongly recommended to make a backup before growing the file system.\n"
"OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes\n"
"super-block backups (for fsck -b #) at:\n"
" 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,\n"
" 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:277
msgid ""
"If the file system is ZFS, the resize is triggered by running the `online` "
"subcommand with `-e`:"
msgstr ""
"파일 시스템이 ZFS인 경우, `-e` 와 함께 `online` 하위 명령을 실행하면 크기 조"
"정이 트리거됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:281
#, no-wrap
msgid "# zpool online -e zroot /dev/ada0p2\n"
msgstr "# zpool online -e zroot /dev/ada0p2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:284
msgid ""
"Both the partition and the file system on it have now been resized to use "
"the newly-available disk space."
msgstr ""
"이제 파티션과 그 안의 파일 시스템 모두 새로운 디스크 공간을 사용하도록 크기"
"가 조정되었습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:286
#, no-wrap
msgid "USB Storage Devices"
msgstr "USB 저장 장치"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:290
msgid ""
"Many external storage solutions, such as hard drives, USB thumbdrives, and "
"CD and DVD burners, use the Universal Serial Bus (USB).  FreeBSD provides "
"support for USB 1.x, 2.0, and 3.0 devices."
msgstr ""
"하드 드라이브, USB 썸드라이브, CD 및 DVD 버너와 같은 많은 외장 스토리지 솔루"
"션은 USB(범용 직렬 버스)를 사용합니다.  FreeBSD는 USB 1.x, 2.0 및 3.0 장치를 "
"지원합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:295
msgid ""
"USB 3.0 support is not compatible with some hardware, including Haswell "
"(Lynx point) chipsets.  If FreeBSD boots with a `failed with error 19` "
"message, disable xHCI/USB3 in the system BIOS."
msgstr ""
"USB 3.0 지원은 하스웰(Lynx 포인트) 칩셋을 포함한 일부 하드웨어와 호환되지 않"
"습니다.  `failed with error 19` 라는 메시지와 함께 FreeBSD가 부팅되는 경우, "
"시스템 BIOS에서 xHCI/USB3를 비활성화하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:299
msgid ""
"Support for USB storage devices is built into the [.filename]#GENERIC# "
"kernel.  For a custom kernel, be sure that the following lines are present "
"in the kernel configuration file:"
msgstr ""
"USB 저장 장치에 대한 지원은 [.filename]#GENERIC# 커널에 내장되어 있습니다.  "
"사용자 지정 커널의 경우 커널 구성 파일에 다음 줄이 있는지 확인하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:312
#, no-wrap
msgid ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"
"device cd\t# needed for CD and DVD burners\n"
msgstr ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"
"device cd\t# needed for CD and DVD burners\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:316
msgid ""
"FreeBSD uses the man:umass[4] driver which uses the SCSI subsystem to access "
"USB storage devices.  Since any USB device will be seen as a SCSI device by "
"the system, if the USB device is a CD or DVD burner, do _not_ include "
"`device atapicam` in a custom kernel configuration file."
msgstr ""
"FreeBSD는 SCSI 서브 시스템을 사용하여 USB 저장 장치에 액세스하는 man:"
"umass[4] 드라이버를 사용합니다.  모든 USB 장치는 시스템에서 SCSI 장치로 간주"
"되므로, USB 장치가 CD나 DVD 버너인 경우 커스텀 커널 구성 파일에 `device "
"atapicam` 을 _포함시키지_ 마세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:318
msgid ""
"The rest of this section demonstrates how to verify that a USB storage "
"device is recognized by FreeBSD and how to configure the device so that it "
"can be used."
msgstr ""
"이 섹션의 나머지 부분에서는 USB 저장 장치가 FreeBSD에서 인식되는지 확인하는 "
"방법과 장치를 사용할 수 있도록 구성하는 방법을 설명합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:319
#, no-wrap
msgid "Device Configuration"
msgstr "장치 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:324
msgid ""
"To test the USB configuration, plug in the USB device.  Use `dmesg` to "
"confirm that the drive appears in the system message buffer.  It should look "
"something like this:"
msgstr ""
"USB 구성을 테스트하려면 USB 장치를 연결합니다.  `dmesg` 를 사용하여 드라이브"
"가 시스템 메시지 버퍼에 나타나는지 확인합니다.  다음과 같이 표시되어야 합니"
"다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:336
#, no-wrap
msgid ""
"umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0\n"
"umass0:  SCSI over Bulk-Only; quirks = 0x0100\n"
"umass0:4:0:-1: Attached to scbus4\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device\n"
"da0: Serial Number WD-WXE508CAN263\n"
"da0: 40.000MB/s transfers\n"
"da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)\n"
"da0: quirks=0x2<NO_6_BYTE>\n"
msgstr ""
"umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0\n"
"umass0:  SCSI over Bulk-Only; quirks = 0x0100\n"
"umass0:4:0:-1: Attached to scbus4\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device\n"
"da0: Serial Number WD-WXE508CAN263\n"
"da0: 40.000MB/s transfers\n"
"da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)\n"
"da0: quirks=0x2<NO_6_BYTE>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:339
msgid ""
"The brand, device node ([.filename]#da0#), speed, and size will differ "
"according to the device."
msgstr ""
"브랜드, 디바이스 노드( [.filename]#da0# ), 속도, 크기는 디바이스에 따라 달라"
"집니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:341
msgid ""
"Since the USB device is seen as a SCSI one, `camcontrol` can be used to list "
"the USB storage devices attached to the system:"
msgstr ""
"USB 장치는 SCSI 장치로 간주되므로 `camcontrol` 을 사용하여 시스템에 연결된 "
"USB 저장 장치를 나열할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:346
#, no-wrap
msgid ""
"# camcontrol devlist\n"
"<STECH Simple Drive 1.04>          at scbus4 target 0 lun 0 (pass3,da0)\n"
msgstr ""
"# camcontrol devlist\n"
"<STECH Simple Drive 1.04>          at scbus4 target 0 lun 0 (pass3,da0)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:350
msgid ""
"Alternately, `usbconfig` can be used to list the device.  Refer to man:"
"usbconfig[8] for more information about this command."
msgstr ""
"다른 방법으로 `usbconfig` 를 사용하여 장치를 나열할 수 있습니다.  이 명령에 "
"대한 자세한 내용은 man:usbconfig[8]을 참조하세요."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:355
#, no-wrap
msgid ""
"# usbconfig\n"
"ugen0.3: <Simple Drive STECH> at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)\n"
msgstr ""
"# usbconfig\n"
"ugen0.3: <Simple Drive STECH> at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:359
#, fuzzy
#| msgid ""
#| "If the device has not been formatted, refer to <<disks-adding>> for "
#| "instructions on how to format and create partitions on the USB drive.  If "
#| "the drive comes with a file system, it can be mounted by `root` using the "
#| "instructions in crossref:basics[mount-unmount,“Mounting and Unmounting "
#| "File Systems”]."
msgid ""
"If the device has not been formatted, refer to crossref:disks[disks-adding, "
"Adding Disks] for instructions on how to format and create partitions on the "
"USB drive.  If the drive comes with a file system, it can be mounted by "
"`root` using the instructions in crossref:basics[mount-unmount,“Mounting and "
"Unmounting File Systems”]."
msgstr ""
"장치를 포맷하지 않은 경우, <<disks-adding>> 에서 USB 드라이브의 포맷 및 파티"
"션 생성 방법을 참조하세요.  드라이브에 파일 시스템이 함께 제공된 경우, "
"crossref:basics[mount-unmount,“Mounting and Unmounting File Systems”]의 지침"
"에 따라 `root` 로 마운트할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:364
msgid ""
"Allowing untrusted users to mount arbitrary media, by enabling `vfs."
"usermount` as described below, should not be considered safe from a security "
"point of view.  Most file systems were not built to safeguard against "
"malicious devices."
msgstr ""
"아래 설명된 대로 `vfs.usermount` 를 활성화하여 신뢰할 수 없는 사용자가 임의"
"의 미디어를 마운트할 수 있도록 허용하는 것은 보안 관점에서 안전하다고 볼 수 "
"없습니다.  대부분의 파일 시스템은 악성 디바이스로부터 보호하도록 설계되지 않"
"았습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:368
msgid ""
"To make the device mountable as a normal user, one solution is to make all "
"users of the device a member of the `operator` group using man:pw[8].  Next, "
"ensure that `operator` is able to read and write the device by adding these "
"lines to [.filename]#/etc/devfs.rules#:"
msgstr ""
"일반 사용자로 장치를 마운트할 수 있게 하려면 man:pw[8]을 사용하여 장치의 모"
"든 사용자를 `operator` 그룹의 멤버로 만드는 것이 한 가지 해결책입니다.  그런 "
"다음 [.filename]#/etc/devfs.rules# 에 다음을 추가하여 `operator` 가 장치를 읽"
"고 쓸 수 있는지 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:373
#, no-wrap
msgid ""
"[localrules=5]\n"
"add path 'da*' mode 0660 group operator\n"
msgstr ""
"[localrules=5]\n"
"add path 'da*' mode 0660 group operator\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:378
msgid ""
"If internal SCSI disks are also installed in the system, change the second "
"line as follows:"
msgstr ""
"시스템에 내부 SCSI 디스크도 설치되어 있는 경우 두 번째 줄을 다음과 같이 변경"
"합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:382
#, no-wrap
msgid "add path 'da[3-9]*' mode 0660 group operator\n"
msgstr "add path 'da[3-9]*' mode 0660 group operator\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:387
msgid ""
"This will exclude the first three SCSI disks ([.filename]#da0# to [."
"filename]#da2#) from belonging to the `operator` group.  Replace _3_ with "
"the number of internal SCSI disks.  Refer to man:devfs.rules[5] for more "
"information about this file."
msgstr ""
"이렇게 하면 처음 세 개의 SCSI 디스크( [.filename]#da0# ~ [.filename]#da2# )"
"가 `operator` 그룹에 속하지 않게 됩니다.  _3_ 을 내부 SCSI 디스크의 수로 바꿉"
"니다.  이 파일에 대한 자세한 내용은 man:devfs.rules[5]를 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:390
msgid "Next, enable the ruleset in [.filename]#/etc/rc.conf#:"
msgstr "그런 다음 [.filename]#/etc/rc.conf# 에 규칙 집합을 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:394
#, no-wrap
msgid "devfs_system_ruleset=\"localrules\"\n"
msgstr "devfs_system_ruleset=\"localrules\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:397
msgid ""
"Then, instruct the system to allow regular users to mount file systems by "
"adding the following line to [.filename]#/etc/sysctl.conf#:"
msgstr ""
"그리고 나서 [.filename]#/etc/sysctl.conf# 에 다음 줄을 추가하여 일반 사용자"
"가 파일 시스템을 마운트할 수 있도록 시스템에 지시합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:401
#, no-wrap
msgid "vfs.usermount=1\n"
msgstr "vfs.usermount=1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:404
msgid ""
"Since this only takes effect after the next reboot, use `sysctl` to set this "
"variable now:"
msgstr ""
"이 변수는 다음 재부팅 후에만 적용되므로 지금 `sysctl` 을 사용하여 이 변수를 "
"설정하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:409
#, no-wrap
msgid ""
"# sysctl vfs.usermount=1\n"
"vfs.usermount: 0 -> 1\n"
msgstr ""
"# sysctl vfs.usermount=1\n"
"vfs.usermount: 0 -> 1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:415
msgid ""
"The final step is to create a directory where the file system is to be "
"mounted.  This directory needs to be owned by the user that is to mount the "
"file system.  One way to do that is for `root` to create a subdirectory "
"owned by that user as [.filename]#/mnt/username#.  In the following example, "
"replace _username_ with the login name of the user and _usergroup_ with the "
"user's primary group:"
msgstr ""
"마지막 단계는 파일 시스템을 마운트할 디렉터리를 만드는 것입니다.  이 디렉터리"
"는 파일 시스템을 마운트할 사용자가 소유해야 합니다.  이를 위한 한 가지 방법"
"은 'root' 가 해당 사용자가 소유한 하위 디렉터리를 [.filename]#/mnt/username# "
"으로 만드는 것입니다.  다음 예제에서는 _username_ 을 사용자의 로그인 이름으"
"로 바꾸고 _usergroup_ 을 사용자의 기본 그룹으로 바꿉니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:420
#, no-wrap
msgid ""
"# mkdir /mnt/username\n"
"# chown username:usergroup /mnt/username\n"
msgstr ""
"# mkdir /mnt/username\n"
"# chown username:usergroup /mnt/username\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:424
msgid ""
"Suppose a USB thumbdrive is plugged in, and a device [.filename]#/dev/da0s1# "
"appears.  If the device is formatted with a FAT file system, the user can "
"mount it using:"
msgstr ""
"USB 썸드라이브가 연결되어 있고 [.filename]#/dev/da0s1# 장치가 표시된다고 가정"
"합니다.  장치가 FAT 파일 시스템으로 포맷된 경우 사용자는 다음을 사용하여 마운"
"트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:428
#, no-wrap
msgid "% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username\n"
msgstr "% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:431
msgid "Before the device can be unplugged, it _must_ be unmounted first:"
msgstr "장치의 플러그를 뽑기 전에 먼저 마운트를 해제해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:435
#, no-wrap
msgid "% umount /mnt/username\n"
msgstr "% umount /mnt/username\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:438
msgid ""
"After device removal, the system message buffer will show messages similar "
"to the following:"
msgstr ""
"장치를 제거한 후 시스템 메시지 버퍼에 다음과 유사한 메시지가 표시됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:445
#, no-wrap
msgid ""
"umass0: at uhub3, port 2, addr 3 (disconnected)\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> s/n WD-WXE508CAN263          detached\n"
"(da0:umass-sim0:0:0:0): Periph destroyed\n"
msgstr ""
"umass0: at uhub3, port 2, addr 3 (disconnected)\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> s/n WD-WXE508CAN263          detached\n"
"(da0:umass-sim0:0:0:0): Periph destroyed\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:447
#, no-wrap
msgid "Automounting Removable Media"
msgstr "이동식 미디어 자동 마운트"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:450
msgid ""
"USB devices can be automatically mounted by uncommenting this line in [."
"filename]#/etc/auto_master#:"
msgstr ""
"USB 장치는 [.filename]#/etc/auto_master# 에서 다음 줄을 주석 처리하면 자동으"
"로 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:454
#, no-wrap
msgid "/media\t\t-media\t\t-nosuid\n"
msgstr "/media\t\t-media\t\t-nosuid\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:457
msgid "Then add these lines to [.filename]#/etc/devd.conf#:"
msgstr "그런 다음 [.filename]#/etc/devd.conf# 에 이 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:465
#, no-wrap
msgid ""
"notify 100 {\n"
"\tmatch \"system\" \"GEOM\";\n"
"\tmatch \"subsystem\" \"DEV\";\n"
"\taction \"/usr/sbin/automount -c\";\n"
"};\n"
msgstr ""
"notify 100 {\n"
"\tmatch \"system\" \"GEOM\";\n"
"\tmatch \"subsystem\" \"DEV\";\n"
"\taction \"/usr/sbin/automount -c\";\n"
"};\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:468
msgid ""
"Reload the configuration if man:autofs[5] and man:devd[8] are already "
"running:"
msgstr ""
"man:autofs[5] 및 man:devd[8]가 이미 실행 중이면 구성을 다시 로드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:473
#, no-wrap
msgid ""
"# service automount restart\n"
"# service devd restart\n"
msgstr ""
"# service automount restart\n"
"# service devd restart\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:476
msgid ""
"man:autofs[5] can be set to start at boot by adding this line to [."
"filename]#/etc/rc.conf#:"
msgstr ""
"man:autofs[5]가 부팅 시 시작되도록 설정하려면 [.filename]#/etc/rc.conf# 에 "
"이 줄을 추가하면 됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:480
#, no-wrap
msgid "autofs_enable=\"YES\"\n"
msgstr "autofs_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:483
msgid "man:autofs[5] requires man:devd[8] to be enabled, as it is by default."
msgstr ""
"man:autofs[5]를 사용하려면 기본적으로 man:devd[8]가 활성화되어 있어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:485
msgid "Start the services immediately with:"
msgstr "즉시 서비스를 시작하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:492
#, no-wrap
msgid ""
"# service automount start\n"
"# service automountd start\n"
"# service autounmountd start\n"
"# service devd start\n"
msgstr ""
"# service automount start\n"
"# service automountd start\n"
"# service autounmountd start\n"
"# service devd start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:497
msgid ""
"Each file system that can be automatically mounted appears as a directory in "
"[.filename]#/media/#.  The directory is named after the file system label.  "
"If the label is missing, the directory is named after the device node."
msgstr ""
"자동으로 마운트할 수 있는 각 파일 시스템은 [.filename]#/media/# 에 디렉터리"
"로 나타납니다.  디렉터리는 파일 시스템 레이블의 이름을 따서 명명됩니다.  레이"
"블이 없는 경우 디렉터리는 장치 노드의 이름을 따서 명명됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:500
msgid ""
"The file system is transparently mounted on the first access, and unmounted "
"after a period of inactivity.  Automounted drives can also be unmounted "
"manually:"
msgstr ""
"파일 시스템은 처음 액세스할 때 투명하게 마운트되고 일정 시간 동안 사용하지 않"
"으면 마운트 해제됩니다.  자동 마운트된 드라이브는 수동으로 마운트 해제할 수"
"도 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:504
#, no-wrap
msgid "# automount -fu\n"
msgstr "# automount -fu\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:508
msgid ""
"This mechanism is typically used for memory cards and USB memory sticks.  It "
"can be used with any block device, including optical drives or iSCSILUNs."
msgstr ""
"이 메커니즘은 일반적으로 메모리 카드와 USB 메모리 스틱에 사용됩니다.  광학 드"
"라이브나 iSCSILUN을 포함한 모든 블록 장치와 함께 사용할 수 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:510
#, no-wrap
msgid "Creating and Using CD Media"
msgstr "CD 미디어 만들기 및 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:516
msgid ""
"Compact Disc (CD) media provide a number of features that differentiate them "
"from conventional disks.  They are designed so that they can be read "
"continuously without delays to move the head between tracks.  While CD media "
"do have tracks, these refer to a section of data to be read continuously, "
"and not a physical property of the disk.  The ISO 9660 file system was "
"designed to deal with these differences."
msgstr ""
"CD(컴팩트 디스크) 미디어는 기존 디스크와 차별화되는 여러 가지 기능을 제공합니"
"다.  트랙 간에 헤드를 이동하는 데 지연 없이 연속적으로 읽을 수 있도록 설계되"
"었습니다.  CD 미디어에도 트랙이 있지만 이는 디스크의 물리적 특성이 아니라 연"
"속적으로 읽을 수 있는 데이터 섹션을 의미합니다.  ISO 9660 파일 시스템은 이러"
"한 차이점을 처리하도록 설계되었습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:520
msgid ""
"The FreeBSD Ports Collection provides several utilities for burning and "
"duplicating audio and data CDs.  This chapter demonstrates the use of "
"several command line utilities.  For CD burning software with a graphical "
"utility, consider installing the package:sysutils/xcdroast[] or package:"
"sysutils/k3b[] packages or ports."
msgstr ""
"FreeBSD 포트 컬렉션은 오디오 및 데이터 CD를 굽고 복제하기 위한 여러 유틸리티"
"를 제공합니다.  이 장에서는 몇 가지 명령줄 유틸리티의 사용법을 설명합니다.  "
"그래픽 유틸리티가 있는 CD 굽기 소프트웨어의 경우, package:sysutils/"
"xcdroast[] 또는 package:sysutils/k3b[] 패키지 또는 포트를 설치하는 것을 고려"
"하십시오."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:522
#, no-wrap
msgid "Supported Devices"
msgstr "지원되는 장치"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:526
msgid ""
"The [.filename]#GENERIC# kernel provides support for SCSI, USB, and ATAPICD "
"readers and burners.  If a custom kernel is used, the options that need to "
"be present in the kernel configuration file vary by the type of device."
msgstr ""
"[.filename]#GENERIC# 커널은 SCSI, USB, ATAPICD 리더 및 버너를 지원합니다.  사"
"용자 지정 커널을 사용하는 경우 커널 구성 파일에 있어야 하는 옵션은 장치 유형"
"에 따라 다릅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:528
msgid "For a SCSI burner, make sure these options are present:"
msgstr "SCSI 버너의 경우 이러한 옵션이 있는지 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:535
#, no-wrap
msgid ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
msgstr ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:538
msgid "For a USB burner, make sure these options are present:"
msgstr "USB 버너의 경우 이러한 옵션이 있는지 확인하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:551
#, no-wrap
msgid ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"
msgstr ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:554
msgid "For an ATAPI burner, make sure these options are present:"
msgstr "ATAPI 버너의 경우 이러한 옵션이 있는지 확인하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:561
#, no-wrap
msgid ""
"device ata\t# Legacy ATA/SATA controllers\n"
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
msgstr ""
"device ata\t# Legacy ATA/SATA controllers\n"
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:566
msgid ""
"On FreeBSD versions prior to 10.x, this line is also needed in the kernel "
"configuration file if the burner is an ATAPI device:"
msgstr ""
"10.x 이전 FreeBSD 버전에서는 버너가 ATAPI 장치인 경우 커널 구성 파일에 다음 "
"내용이 필요합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:570
#, no-wrap
msgid "device atapicam\n"
msgstr "device atapicam\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:573
msgid ""
"Alternately, this driver can be loaded at boot time by adding the following "
"line to [.filename]#/boot/loader.conf#:"
msgstr ""
"또는 [.filename]#/boot/loader.conf# 에 다음 줄을 추가하여 부팅 시 이 드라이버"
"를 로드할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:577
#, no-wrap
msgid "atapicam_load=\"YES\"\n"
msgstr "atapicam_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:580
msgid ""
"This will require a reboot of the system as this driver can only be loaded "
"at boot time."
msgstr ""
"이 드라이버는 부팅 시에만 로드할 수 있으므로 시스템을 재부팅해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:584
msgid ""
"To verify that FreeBSD recognizes the device, run `dmesg` and look for an "
"entry for the device.  On systems prior to 10.x, the device name in the "
"first line of the output will be [.filename]#acd0# instead of [."
"filename]#cd0#."
msgstr ""
"FreeBSD가 장치를 인식하는지 확인하려면 `dmesg` 를 실행하고 장치에 대한 항목"
"을 찾습니다.  10.x 이전 시스템에서는 출력 첫 줄의 장치 이름이 [."
"filename]#cd0# 이 아닌 [.filename]#acd0# 이 됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:593
#, no-wrap
msgid ""
"% dmesg | grep cd\n"
"cd0 at ahcich1 bus 0 scbus1 target 0 lun 0\n"
"cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device\n"
"cd0: Serial Number M3OD3S34152\n"
"cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)\n"
"cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed\n"
msgstr ""
"% dmesg | grep cd\n"
"cd0 at ahcich1 bus 0 scbus1 target 0 lun 0\n"
"cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device\n"
"cd0: Serial Number M3OD3S34152\n"
"cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)\n"
"cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:596
#, no-wrap
msgid "Burning a CD"
msgstr "CD 굽기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:600
msgid ""
"In FreeBSD, `cdrecord` can be used to burn CDs.  This command is installed "
"with the package:sysutils/cdrtools[] package or port."
msgstr ""
"FreeBSD에서는 `cdrecord` 를 사용하여 CD를 구울 수 있습니다.  이 명령은 "
"package:sysutils/cdrtools[] 패키지 또는 포트와 함께 설치됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:603
msgid ""
"While `cdrecord` has many options, basic usage is simple.  Specify the name "
"of the ISO file to burn and, if the system has multiple burner devices, "
"specify the name of the device to use:"
msgstr ""
"`cdrecord` 에는 많은 옵션이 있지만 기본 사용법은 간단합니다.  레코딩할 ISO 파"
"일의 이름을 지정하고, 시스템에 여러 개의 버너 장치가 있는 경우 사용할 장치의 "
"이름을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:607
#, no-wrap
msgid "# cdrecord dev=device imagefile.iso\n"
msgstr "# cdrecord dev=device imagefile.iso\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:610
msgid ""
"To determine the device name of the burner, use `-scanbus` which might "
"produce results like this:"
msgstr ""
"버너의 장치 이름을 확인하기 위해 `-scanbus` 를 사용하면 다음과 같은 결과가 나"
"올 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:634
#, no-wrap
msgid ""
"# cdrecord -scanbus\n"
"ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 Jörg Schilling\n"
"Using libscg version 'schily-0.9'\n"
"scsibus0:\n"
"        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk\n"
"        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk\n"
"        0,2,0     2) *\n"
"        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk\n"
"        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM\n"
"        0,5,0     5) *\n"
"        0,6,0     6) *\n"
"        0,7,0     7) *\n"
"scsibus1:\n"
"        1,0,0   100) *\n"
"        1,1,0   101) *\n"
"        1,2,0   102) *\n"
"        1,3,0   103) *\n"
"        1,4,0   104) *\n"
"        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM\n"
"        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner\n"
"        1,7,0   107) *\n"
msgstr ""
"# cdrecord -scanbus\n"
"ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 Jörg Schilling\n"
"Using libscg version 'schily-0.9'\n"
"scsibus0:\n"
"        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk\n"
"        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk\n"
"        0,2,0     2) *\n"
"        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk\n"
"        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM\n"
"        0,5,0     5) *\n"
"        0,6,0     6) *\n"
"        0,7,0     7) *\n"
"scsibus1:\n"
"        1,0,0   100) *\n"
"        1,1,0   101) *\n"
"        1,2,0   102) *\n"
"        1,3,0   103) *\n"
"        1,4,0   104) *\n"
"        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM\n"
"        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner\n"
"        1,7,0   107) *\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:639
msgid ""
"Locate the entry for the CD burner and use the three numbers separated by "
"commas as the value for `dev`.  In this case, the Yamaha burner device is "
"`1,5,0`, so the appropriate input to specify that device is `dev=1,5,0`.  "
"Refer to the manual page for `cdrecord` for other ways to specify this value "
"and for information on writing audio tracks and controlling the write speed."
msgstr ""
"CD 버너에 대한 항목을 찾아보면 쉼표로 구분된 세 개의 숫자를 `dev` 의 값으로 "
"사용하고 있습니다.  이 경우 Yamaha 버너 장치는 `1,5,0` 이므로 해당 장치를 지"
"정하는 데 적합한 입력은 `dev=1,5,0` 입니다.  이 값을 지정하는 다른 방법과 오"
"디오 트랙 쓰기 및 쓰기 속도 제어에 대한 정보는 `cdrecord` 의 설명서 페이지를 "
"참조하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:641
msgid ""
"Alternately, run the following command to get the device address of the "
"burner:"
msgstr "또는 다음 명령을 실행하여 버너의 장치 주소를 가져옵니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:646
#, no-wrap
msgid ""
"# camcontrol devlist\n"
"<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (cd0,pass0)\n"
msgstr ""
"# camcontrol devlist\n"
"<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (cd0,pass0)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:650
msgid ""
"Use the numeric values for `scbus`, `target`, and `lun`.  For this example, "
"`1,0,0` is the device name to use."
msgstr ""
"`scbus`, `target` 및 `lun` 에 숫자 값을 사용합니다.  이 예제에서 `1,0,0` 은 "
"사용할 장치 이름입니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:652
#, no-wrap
msgid "Writing Data to an ISO File System"
msgstr "ISO 파일 시스템에 데이터 쓰기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:657
msgid ""
"In order to produce a data CD, the data files that are going to make up the "
"tracks on the CD must be prepared before they can be burned to the CD.  In "
"FreeBSD, package:sysutils/cdrtools[] installs `mkisofs`, which can be used "
"to produce an ISO 9660 file system that is an image of a directory tree "
"within a UNIX(R) file system.  The simplest usage is to specify the name of "
"the ISO file to create and the path to the files to place into the ISO 9660 "
"file system:"
msgstr ""
"데이터 CD를 제작하려면, CD의 트랙을 구성할 데이터 파일을 CD에 구울 수 있도록 "
"먼저 준비해야 합니다.  FreeBSD에서, package:sysutils/cdrtools[]는 `mkisofs` "
"를 설치하는데, 이는 UNIX(R) 파일 시스템 내의 디렉토리 트리 이미지인 ISO 9660 "
"파일 시스템을 생성하는 데 사용할 수 있습니다.  가장 간단한 사용법은 생성할 "
"ISO 파일의 이름과 ISO 9660 파일 시스템에 배치할 파일 경로를 지정하는 것입니"
"다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:661
#, no-wrap
msgid "# mkisofs -o imagefile.iso /path/to/tree\n"
msgstr "# mkisofs -o imagefile.iso /path/to/tree\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:664
msgid ""
"This command maps the file names in the specified path to names that fit the "
"limitations of the standard ISO 9660 file system, and will exclude files "
"that do not meet the standard for ISO file systems."
msgstr ""
"이 명령은 지정된 경로의 파일 이름을 표준 ISO 9660 파일 시스템의 제한에 맞는 "
"이름으로 매핑하고 ISO 파일 시스템 표준에 맞지 않는 파일은 제외합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:667
msgid ""
"A number of options are available to overcome the restrictions imposed by "
"the standard.  In particular, `-R` enables the Rock Ridge extensions common "
"to UNIX(R) systems and `-J` enables Joliet extensions used by Microsoft(R) "
"systems."
msgstr ""
"표준에 의해 부과된 제한을 극복하기 위해 여러 가지 옵션을 사용할 수 있습니"
"다.  특히 `-R` 은 UNIX(R) 시스템에 공통적으로 사용되는 Rock Ridge 확장을 활성"
"화하고 `-J` 는 Microsoft(R) 시스템에서 사용되는 Joliet 확장을 활성화합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:670
msgid ""
"For CDs that are going to be used only on FreeBSD systems, `-U` can be used "
"to disable all filename restrictions.  When used with `-R`, it produces a "
"file system image that is identical to the specified FreeBSD tree, even if "
"it violates the ISO 9660 standard."
msgstr ""
"FreeBSD 시스템에서만 사용하려는 CD의 경우, `-U` 를 사용하여 모든 파일 이름 제"
"한을 비활성화할 수 있습니다.  `-R` 과 함께 사용하면 ISO 9660 표준을 위반하더"
"라도 지정된 FreeBSD 트리와 동일한 파일 시스템 이미지를 생성합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:678
msgid ""
"The last option of general use is `-b`.  This is used to specify the "
"location of a boot image for use in producing an \"El Torito\" bootable CD.  "
"This option takes an argument which is the path to a boot image from the top "
"of the tree being written to the CD.  By default, `mkisofs` creates an ISO "
"image in \"floppy disk emulation\" mode, and thus expects the boot image to "
"be exactly 1200, 1440 or 2880 KB in size.  Some boot loaders, like the one "
"used by the FreeBSD distribution media, do not use emulation mode.  In this "
"case, `-no-emul-boot` should be used.  So, if [.filename]#/tmp/myboot# holds "
"a bootable FreeBSD system with the boot image in [.filename]#/tmp/myboot/"
"boot/cdboot#, this command would produce [.filename]#/tmp/bootable.iso#:"
msgstr ""
"일반적으로 사용되는 마지막 옵션은 `-b` 입니다.  이 옵션은 \"El Torito\" 부팅 "
"가능한 CD를 생성할 때 사용할 부팅 이미지의 위치를 지정하는 데 사용됩니다.  "
"이 옵션은 CD에 기록되는 트리의 맨 위에 있는 부팅 이미지의 경로인 인수를 받습"
"니다.  기본적으로 `mkisofs` 는 \"플로피 디스크 에뮬레이션\" 모드에서 ISO 이미"
"지를 생성하므로 부팅 이미지의 크기는 정확히 1200, 1440 또는 2880KB가 될 것으"
"로 예상합니다.  FreeBSD 배포 미디어에서 사용하는 것과 같은 일부 부트 로더는 "
"에뮬레이션 모드를 사용하지 않습니다.  이 경우 `-no-emul-boot` 를 사용해야 합"
"니다.  따라서 [.filename]#/tmp/myboot# 에 부팅 이미지가 있는 부팅 가능한 "
"FreeBSD 시스템이 [.filename]#/tmp/myboot/boot/cdboot# 에 있는 경우, 이 명령"
"은 [.filename]#/tmp/bootable.iso# 를 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:682
#, no-wrap
msgid "# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot\n"
msgstr "# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:685
msgid "The resulting ISO image can be mounted as a memory disk with:"
msgstr ""
"결과 ISO 이미지는 다음을 사용하여 메모리 디스크로 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:690
#, no-wrap
msgid ""
"# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"
msgstr ""
"# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:693
msgid ""
"One can then verify that [.filename]#/mnt# and [.filename]#/tmp/myboot# are "
"identical."
msgstr ""
"그런 다음 [.filename]#/mnt# 와 [.filename]#/tmp/myboot# 가 동일한지 확인할 "
"수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:696
msgid ""
"There are many other options available for `mkisofs` to fine-tune its "
"behavior.  Refer to man:mkisofs[8] for details."
msgstr ""
"다른 많은 옵션을 사용하여 `mkisofs` 의 동작을 세부조정할 수 있습니다.  자세"
"한 내용은 man:mkisofs[8]을 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:701
msgid ""
"It is possible to copy a data CD to an image file that is functionally "
"equivalent to the image file created with `mkisofs`.  To do so, use [."
"filename]#dd# with the device name as the input file and the name of the ISO "
"to create as the output file:"
msgstr ""
"데이터 CD를 `mkisofs` 로 생성한 이미지 파일과 기능적으로 동일한 이미지 파일"
"로 복사할 수 있습니다.  이렇게 하려면 [.filename]#dd# 를 장치 이름과 함께 입"
"력 파일로 사용하고 생성할 ISO의 이름을 출력 파일로 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:705
#, no-wrap
msgid "# dd if=/dev/cd0 of=file.iso bs=2048\n"
msgstr "# dd if=/dev/cd0 of=file.iso bs=2048\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:708
#, fuzzy
#| msgid ""
#| "The resulting image file can be burned to CD as described in <<cdrecord>>."
msgid ""
"The resulting image file can be burned to CD as described in crossref:"
"disks[cdrecord, Burning a CD]."
msgstr "결과 이미지 파일은 <<cdrecord>> 에 설명된 대로 CD에 구울 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:711
#, no-wrap
msgid "Using Data CDs"
msgstr "데이터 CD 사용"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:714
msgid ""
"Once an ISO has been burned to a CD, it can be mounted by specifying the "
"file system type, the name of the device containing the CD, and an existing "
"mount point:"
msgstr ""
"ISO를 CD에 구운 후에는 파일 시스템 유형, CD가 들어 있는 장치 이름, 기존 마운"
"트 지점을 지정하여 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:718
#, no-wrap
msgid "# mount -t cd9660 /dev/cd0 /mnt\n"
msgstr "# mount -t cd9660 /dev/cd0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:721
msgid ""
"Since `mount` assumes that a file system is of type `ufs`, an `Incorrect "
"super block` error will occur if `-t cd9660` is not included when mounting a "
"data CD."
msgstr ""
"`mount` 는 파일 시스템이 `ufs` 유형이라고 가정하기 때문에 데이터 CD를 마운트"
"할 때 `-t cd9660` 이 포함되지 않으면 `Incorrect super block` 오류가 발생합니"
"다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:726
msgid ""
"While any data CD can be mounted this way, disks with certain ISO 9660 "
"extensions might behave oddly.  For example, Joliet disks store all "
"filenames in two-byte Unicode characters.  If some non-English characters "
"show up as question marks, specify the local charset with `-C`.  For more "
"information, refer to man:mount_cd9660[8]."
msgstr ""
"모든 데이터 CD를 이 방법으로 마운트할 수 있지만, 특정 ISO 9660 확장자를 가진 "
"디스크는 이상하게 작동할 수 있습니다.  예를 들어, Joliet 디스크는 모든 파일 "
"이름을 2바이트 유니코드 문자로 저장합니다.  영어가 아닌 일부 문자가 물음표로 "
"표시되는 경우 `-C` 로 로컬 문자 집합을 지정합니다.  자세한 내용은 man:"
"mount_cd9660[8]을 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:731
msgid ""
"In order to do this character conversion with the help of `-C`, the kernel "
"requires the [.filename]#cd9660_iconv.ko# module to be loaded.  This can be "
"done either by adding this line to [.filename]#loader.conf#:"
msgstr ""
"`-C` 를 사용하여 이 문자 변환을 수행하려면 커널에 [.filename]#cd9660_iconv."
"ko# 모듈이 로드되어야 합니다.  이 작업은 [.filename]#loader.conf# 에 다음 줄"
"을 추가하여 수행할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:735
#, no-wrap
msgid "cd9660_iconv_load=\"YES\"\n"
msgstr "cd9660_iconv_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:738
msgid ""
"and then rebooting the machine, or by directly loading the module with "
"`kldload`."
msgstr ""
"그리고 나서 머신을 재부팅하거나 `kldload` 를 사용하여 모듈을 직접 로드합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:743
msgid ""
"Occasionally, `Device not configured` will be displayed when trying to mount "
"a data CD.  This usually means that the CD drive has not detected a disk in "
"the tray, or that the drive is not visible on the bus.  It can take a couple "
"of seconds for a CD drive to detect media, so be patient."
msgstr ""
"데이터 CD를 마운트하려고 할 때 `Device not configured` 이 표시되는 경우가 있"
"습니다.  이는 일반적으로 CD 드라이브가 트레이에 있는 디스크를 감지하지 못했거"
"나 드라이브가 버스에 표시되지 않는다는 의미입니다.  CD 드라이브가 미디어를 감"
"지하는 데 몇 초 정도 걸릴 수 있으므로 조금만 기다려주세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:747
msgid ""
"Sometimes, a SCSICD drive may be missed because it did not have enough time "
"to answer the bus reset.  To resolve this, a custom kernel can be created "
"which increases the default SCSI delay.  Add the following option to the "
"custom kernel configuration file and rebuild the kernel using the "
"instructions in crossref:kernelconfig[kernelconfig-building,“Building and "
"Installing a Custom Kernel”]:"
msgstr ""
"때때로 버스 재설정에 응답할 시간이 충분하지 않아 SCSICD 드라이브가 누락될 수 "
"있습니다.  이 문제를 해결하기 위해 사용자 지정 커널을 생성하여 기본 SCSI 지연"
"을 늘릴 수 있습니다.  사용자 지정 커널 구성 파일에 다음 옵션을 추가하고  "
"crossref:kernelconfig[kernelconfig-building,“Building and Installing a "
"Custom Kernel”]의 지침에 따라 커널을 다시 빌드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:751
#, no-wrap
msgid "options SCSI_DELAY=15000\n"
msgstr "options SCSI_DELAY=15000\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:754
msgid ""
"This tells the SCSI bus to pause 15 seconds during boot, to give the CD "
"drive every possible chance to answer the bus reset."
msgstr ""
"이렇게 하면 부팅하는 동안 SCSI 버스가 15초 동안 일시 중지되어 CD 드라이브가 "
"버스 재설정에 응답할 수 있는 기회를 갖도록 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:759
msgid ""
"It is possible to burn a file directly to CD, without creating an ISO 9660 "
"file system.  This is known as burning a raw data CD and some people do this "
"for backup purposes."
msgstr ""
"ISO 9660 파일 시스템을 만들지 않고도 파일을 CD에 직접 구울 수 있습니다.  이"
"를 원시 데이터(raw data ) CD 굽기라고 하며 일부 사람들은 백업 목적으로 이 작"
"업을 수행합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:763
msgid ""
"This type of disk can not be mounted as a normal data CD.  In order to "
"retrieve the data burned to such a CD, the data must be read from the raw "
"device node.  For example, this command will extract a compressed tar file "
"located on the second CD device into the current working directory:"
msgstr ""
"이 유형의 디스크는 일반 데이터 CD로 마운트할 수 없습니다.  이러한 CD에 구운 "
"데이터를 검색하려면 원시 장치 노드에서 데이터를 읽어야 합니다.  예를 들어, "
"이 명령은 두 번째 CD 장치에 있는 압축된 tar 파일을 현재 작업 디렉터리로 추출"
"합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:767
#, no-wrap
msgid "# tar xzvf /dev/cd1\n"
msgstr "# tar xzvf /dev/cd1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:770
msgid "In order to mount a data CD, the data must be written using `mkisofs`."
msgstr ""
"데이터 CD를 마운트하려면 `mkisofs` 를 사용하여 데이터를 작성해야 합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:773
#, no-wrap
msgid "Duplicating Audio CDs"
msgstr "오디오 CD 복제하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:776
msgid ""
"To duplicate an audio CD, extract the audio data from the CD to a series of "
"files, then write these files to a blank CD."
msgstr ""
"오디오 CD를 복제하려면 CD에서 오디오 데이터를 일련의 파일로 추출한 다음 이 파"
"일을 빈 CD에 씁니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:780
#, fuzzy
#| msgid ""
#| "<<using-cdrecord>> describes how to duplicate and burn an audio CD.  If "
#| "the FreeBSD version is less than 10.0 and the device is ATAPI, the "
#| "`atapicam` module must be first loaded using the instructions in "
#| "<<atapicam>>."
msgid ""
"crossref:disks[using-cdrecord, Duplicating an Audio CD] describes how to "
"duplicate and burn an audio CD.  If the FreeBSD version is less than 10.0 "
"and the device is ATAPI, the `atapicam` module must be first loaded using "
"the instructions in crossref:disks[atapicam, Supported Devices]."
msgstr ""
"<<using-cdrecord>> 에서 오디오 CD를 복제하고 굽는 방법을 설명합니다.  "
"FreeBSD 버전이 10.0 미만이고 장치가 ATAPI인 경우, <<atapicam>> 의 지침에 따"
"라 `atapicam` 모듈을 먼저 로드해야 합니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:783
#, no-wrap
msgid "Procedure: Duplicating an Audio CD"
msgstr "절차: 오디오 CD 복제하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:785
msgid ""
"The package:sysutils/cdrtools[] package or port installs `cdda2wav`. This "
"command can be used to extract all of the audio tracks, with each track "
"written to a separate WAV file in the current working directory:"
msgstr ""
"package:sysutils/cdrtools[] 패키지 또는 포트는 `cdda2wav` 를 설치합니다. 이 "
"명령은 모든 오디오 트랙을 추출하는 데 사용할 수 있으며, 각 트랙은 현재 작업 "
"디렉터리에 별도의 WAV 파일로 기록됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:789
#, no-wrap
msgid "% cdda2wav -vall -B -Owav\n"
msgstr "% cdda2wav -vall -B -Owav\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:793
msgid ""
"A device name does not need to be specified if there is only one CD device "
"on the system.  Refer to the `cdda2wav` manual page for instructions on how "
"to specify a device and to learn more about the other options available for "
"this command."
msgstr ""
"시스템에 CD 장치가 하나만 있는 경우 장치 이름을 지정할 필요가 없습니다.  장치"
"를 지정하는 방법에 대한 지침과 이 명령에 사용할 수 있는 다른 옵션에 대해 자세"
"히 알아보려면 `cdda2wav` 매뉴얼 페이지를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:794
msgid "Use `cdrecord` to write the [.filename]#.wav# files:"
msgstr "`cdrecord` 를 사용하여 [.filename]#.wav# 파일을 작성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:798
#, no-wrap
msgid "% cdrecord -v dev=2,0 -dao -useinfo  *.wav\n"
msgstr "% cdrecord -v dev=2,0 -dao -useinfo  *.wav\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:801
#, fuzzy
#| msgid ""
#| "Make sure that _2,0_ is set appropriately, as described in <<cdrecord>>."
msgid ""
"Make sure that _2,0_ is set appropriately, as described in crossref:"
"disks[cdrecord, Burning a CD]."
msgstr ""
"<<cdrecord>> 에서 설명된 대로 _2,0_ 이 적절하게 설정되었는지 확인합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:803
#, no-wrap
msgid "Creating and Using DVD Media"
msgstr "DVD 미디어 만들기 및 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:807
msgid ""
"Compared to the CD, the DVD is the next generation of optical media storage "
"technology.  The DVD can hold more data than any CD and is the standard for "
"video publishing."
msgstr ""
"CD에 비해 DVD는 차세대 광학 미디어 저장 기술입니다.  DVD는 어떤 CD보다 더 많"
"은 데이터를 저장할 수 있으며 비디오 퍼블리싱의 표준입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:809
msgid "Five physical recordable formats can be defined for a recordable DVD:"
msgstr "레코딩 가능한 DVD에는 5가지 물리적 레코딩 형식을 정의할 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:811
msgid ""
"DVD-R: This was the first DVD recordable format available. The DVD-R "
"standard is defined by the http://www.dvdforum.org/forum.shtml[DVD Forum]. "
"This format is write once."
msgstr ""
"DVD-R: 최초의 DVD 기록 가능 포맷입니다. DVD-R 표준은 http://www.dvdforum.org/"
"forum.shtml[DVD 포럼]에서 정의합니다. 이 형식은 한 번만 기록할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:812
msgid ""
"DVD-RW: This is the rewritable version of the DVD-R standard. A DVD-RW can "
"be rewritten about 1000 times."
msgstr ""
"DVD-RW: DVD-R 표준의 재기록 가능 버전입니다. DVD-RW는 약 1000번 다시 쓸 수 있"
"습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:816
#, fuzzy
#| msgid ""
#| "DVD-RAM: This is a rewritable format which can be seen as a removable "
#| "hard drive. However, this media is not compatible with most DVD-ROM "
#| "drives and DVD-Video players as only a few DVD writers support the DVD-"
#| "RAM format. Refer to <<creating-dvd-ram>> for more information on DVD-RAM "
#| "use."
msgid ""
"DVD-RAM: This is a rewritable format which can be seen as a removable hard "
"drive. However, this media is not compatible with most DVD-ROM drives and "
"DVD-Video players as only a few DVD writers support the DVD-RAM format. "
"Refer to crossref:disks[creating-dvd-ram, Using a DVD-RAM] for more "
"information on DVD-RAM use."
msgstr ""
"DVD-RAM: 이동식 하드 드라이브로 볼 수 있는 재기록 가능한 형식입니다. 그러나 "
"이 미디어는 일부 DVD 라이터만 DVD-RAM 포맷을 지원하므로 대부분의 DVD-ROM 드라"
"이브 및 DVD-Video 플레이어와 호환되지 않습니다. DVD-RAM 사용에 대한 자세한 내"
"용은 <<creating-dvd-ram>> 을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:817
msgid ""
"DVD+RW: This is a rewritable format defined by the https://en.wikipedia.org/"
"wiki/DVD%2BRW_Alliance[DVD+RW Alliance]. A DVD+RW can be rewritten about "
"1000 times."
msgstr ""
"DVD+RW: https://en.wikipedia.org/wiki/DVD%2BRW_Alliance[DVD+RW 얼라이언스]에"
"서 정의한 재기록 가능 포맷입니다. DVD+RW는 약 1000번 다시 쓸 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:818
msgid "DVD+R: This format is the write once variation of the DVD+RW format."
msgstr "DVD+R: 이 형식은 DVD+RW 형식의 한 번 쓰기 변형입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:820
msgid ""
"A single layer recordable DVD can hold up to 4,700,000,000 bytes which is "
"actually 4.38 GB or 4485 MB as 1 kilobyte is 1024 bytes."
msgstr ""
"단일 레이어 기록 가능 DVD는 최대 4,700,000,000바이트를 저장할 수 있으며, 1킬"
"로바이트는 1024바이트이므로 실제로는 4.38GB 또는 4485MB에 해당합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:826
msgid ""
"A distinction must be made between the physical media and the application.  "
"For example, a DVD-Video is a specific file layout that can be written on "
"any recordable DVD physical media such as DVD-R, DVD+R, or DVD-RW.  Before "
"choosing the type of media, ensure that both the burner and the DVD-Video "
"player are compatible with the media under consideration."
msgstr ""
"물리적 미디어와 애플리케이션을 구분해야 합니다.  예를 들어, DVD-Video는 DVD-"
"R, DVD+R 또는 DVD-RW와 같은 기록 가능한 DVD 물리적 미디어에 기록할 수 있는 특"
"정 파일 레이아웃입니다.  미디어 유형을 선택하기 전에 버너와 DVD-비디오 플레이"
"어 모두, 고려 중인 미디어와 호환되는지 확인하십시오."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:828
#, no-wrap
msgid "Configuration"
msgstr "구성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:832
msgid ""
"To perform DVD recording, use man:growisofs[1].  This command is part of the "
"package:sysutils/dvd+rw-tools[] utilities which support all DVD media types."
msgstr ""
"DVD 레코딩을 수행하려면 man:growisofs[1]를 사용합니다.  이 명령은 모든 DVD 미"
"디어 유형을 지원하는 package:sysutils/dvd+rw-tools[] 유틸리티의 일부입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:837
#, fuzzy
#| msgid ""
#| "These tools use the SCSI subsystem to access the devices, therefore "
#| "<<atapicam,ATAPI/CAM support>> must be loaded or statically compiled into "
#| "the kernel.  This support is not needed if the burner uses the USB "
#| "interface.  Refer to <<usb-disks>> for more details on USB device "
#| "configuration."
msgid ""
"These tools use the SCSI subsystem to access the devices, therefore crossref:"
"disks[atapicam,ATAPI/CAM support] must be loaded or statically compiled into "
"the kernel.  This support is not needed if the burner uses the USB "
"interface.  Refer to crossref:disks[usb-disks, USB Storage Devices] for more "
"details on USB device configuration."
msgstr ""
"이러한 도구는 SCSI 하위 시스템을 사용하여 장치에 액세스하므로 <<atapicam,"
"ATAPI/CAM support>> 이 커널에 로드되거나 정적으로 컴파일되어야 합니다.  버너"
"가 USB 인터페이스를 사용하는 경우 이 지원은 필요하지 않습니다.  USB 장치 구성"
"에 대한 자세한 내용은 <<usb-disks>> 를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:839
msgid ""
"DMA access must also be enabled for ATAPI devices, by adding the following "
"line to [.filename]#/boot/loader.conf#:"
msgstr ""
"DMA는 [.filename]#/boot/loader.conf# 에 다음 줄을 추가하여 ATAPI 장치에 대한 "
"액세스 활성화를 해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:843
#: documentation/content/en/books/handbook/disks/_index.adoc:1076
#, no-wrap
msgid "hw.ata.atapi_dma=\"1\"\n"
msgstr "hw.ata.atapi_dma=\"1\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:846
msgid ""
"Before attempting to use dvd+rw-tools, consult the http://fy.chalmers.se/"
"~appro/linux/DVD+RW/hcn.html[Hardware Compatibility Notes]."
msgstr ""
"dvd+rw-tools를 사용하기 전에 http://fy.chalmers.se/~appro/linux/DVD+RW/hcn."
"html[하드웨어 호환성 참고 사항]을 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:850
msgid ""
"For a graphical user interface, consider using package:sysutils/k3b[] which "
"provides a user friendly interface to man:growisofs[1] and many other "
"burning tools."
msgstr ""
"그래픽 사용자 인터페이스의 경우, man:growisofs[1] 및 기타 여러 굽기 도구에 사"
"용자 친화적인 인터페이스를 제공하는 package:sysutils/k3b[]를 사용하는 것이 좋"
"습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:852
#, no-wrap
msgid "Burning Data DVDs"
msgstr "데이터 DVD 굽기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:856
#, fuzzy
#| msgid ""
#| "Since man:growisofs[1] is a front-end to <<mkisofs,mkisofs>>, it will "
#| "invoke man:mkisofs[8] to create the file system layout and perform the "
#| "write on the DVD.  This means that an image of the data does not need to "
#| "be created before the burning process."
msgid ""
"Since man:growisofs[1] is a front-end to crossref:disks[mkisofs,mkisofs], it "
"will invoke man:mkisofs[8] to create the file system layout and perform the "
"write on the DVD.  This means that an image of the data does not need to be "
"created before the burning process."
msgstr ""
"man:growisofs[1]는 <<mkisofs,mkisofs>> 에 대한 프런트 엔드이므로, man:"
"mkisofs[8]을 호출하여 파일 시스템 레이아웃을 생성하고 DVD에 쓰기를 수행합니"
"다.  즉, 굽기 프로세스 전에 데이터 이미지를 만들 필요가 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:858
msgid ""
"To burn to a DVD+R or a DVD-R the data in [.filename]#/path/to/data#, use "
"the following command:"
msgstr ""
"[.filename]#/path/to/data# 에 있는 데이터를 DVD+R 또는 DVD-R로 구우려면 다음 "
"명령을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:862
#, no-wrap
msgid "# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data\n"
msgstr "# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:866
msgid ""
"In this example, `-J -R` is passed to man:mkisofs[8] to create an ISO 9660 "
"file system with Joliet and Rock Ridge extensions.  Refer to man:mkisofs[8] "
"for more details."
msgstr ""
"이 예제에서는 `-J -R` 을 man:mkisofs[8]에 전달하여 Joliet 및 Rock Ridge 확장"
"자를 가진 ISO 9660 파일 시스템을 생성합니다.  자세한 내용은 man:mkisofs[8]을 "
"참조하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:871
msgid ""
"For the initial session recording, `-Z` is used for both single and multiple "
"sessions.  Replace _/dev/cd0_, with the name of the DVD device.  Using `-dvd-"
"compat` indicates that the disk will be closed and that the recording will "
"be unappendable.  This should also provide better media compatibility with "
"DVD-ROM drives."
msgstr ""
"초기 세션 녹화의 경우 단일 세션과 다중 세션 모두에 `-Z` 가 사용됩니다.  _/"
"dev/cd0_ 를 DVD 장치의 이름으로 바꿉니다.  `-dvd-compat` 을 사용하면 디스크"
"가 닫히고 레코딩을 추가할 수 없음을 나타냅니다.  이렇게 하면 DVD-ROM 드라이브"
"와의 미디어 호환성이 향상됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:873
msgid "To burn a pre-mastered image, such as _imagefile.iso_, use:"
msgstr "_imagefile.iso_ 와 같이 미리 마스터링된 이미지를 구우려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:877
#, no-wrap
msgid "# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso\n"
msgstr "# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:881
msgid ""
"The write speed should be detected and automatically set according to the "
"media and the drive being used.  To force the write speed, use `-speed=`. "
"Refer to man:growisofs[1] for example usage."
msgstr ""
"쓰기 속도는 사용 중인 미디어와 드라이브에 따라 감지되고 자동으로 설정되어야 "
"합니다.  쓰기 속도를 강제로 설정하려면 `-speed=` 를 사용합니다. 예제 사용법"
"은 man:growisofs[1]을 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:888
msgid ""
"In order to support working files larger than 4.38GB, an UDF/ISO-9660 hybrid "
"file system must be created by passing `-udf -iso-level 3` to man:mkisofs[8] "
"and all related programs, such as man:growisofs[1].  This is required only "
"when creating an ISO image file or when writing files directly to a disk.  "
"Since a disk created this way must be mounted as an UDF file system with man:"
"mount_udf[8], it will be usable only on an UDF aware operating system.  "
"Otherwise it will look as if it contains corrupted files."
msgstr ""
"4.38GB보다 큰 작업 파일을 지원하려면 `-udf -iso-level 3` 을 man:mkisofs[8] "
"및 man:growisofs[1]와 같은 모든 관련 프로그램에 전달하여 UDF/ISO-9660 하이브"
"리드 파일 시스템을 만들어야 합니다.  이 옵션은 ISO 이미지 파일을 만들거나 디"
"스크에 직접 파일을 쓸 때만 필요합니다.  이렇게 만든 디스크는 man:mount_udf[8]"
"를 사용하여 UDF 파일 시스템으로 마운트해야 하므로, UDF를 인식하는 운영 체제에"
"서만 사용할 수 있습니다.  그렇지 않으면 손상된 파일이 포함된 것처럼 보입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:890
msgid "To create this type of ISO file:"
msgstr "이 유형의 ISO 파일을 만들려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:894
#, no-wrap
msgid "% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data\n"
msgstr "% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:897
msgid "To burn files directly to a disk:"
msgstr "디스크에 직접 파일을 구우려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:901
#, no-wrap
msgid "# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data\n"
msgstr "# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:904
msgid ""
"When an ISO image already contains large files, no additional options are "
"required for man:growisofs[1] to burn that image on a disk."
msgstr ""
"ISO 이미지에 이미 대용량 파일이 포함되어 있는 경우, man:growisofs[1]가 해당 "
"이미지를 디스크에 구울 때 추가 옵션이 필요하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:907
msgid ""
"Be sure to use an up-to-date version of package:sysutils/cdrtools[], which "
"contains man:mkisofs[8], as an older version may not contain large files "
"support.  If the latest version does not work, install package:sysutils/"
"cdrtools-devel[] and read its man:mkisofs[8]."
msgstr ""
"이전 버전에는 대용량 파일을 지원하지 않을 수 있으므로 man:mkisofs[8]가 포함"
"된 최신 버전의 package:sysutils/cdrtools[]를 사용해야 합니다.  최신 버전이 작"
"동하지 않는 경우 package:sysutils/cdrtools-devel[]을 설치하고 man:mkisofs[8]"
"을 읽어보세요."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:909
#, no-wrap
msgid "Burning a DVD-Video"
msgstr "DVD-비디오 굽기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:913
msgid ""
"A DVD-Video is a specific file layout based on the ISO 9660 and micro-UDF (M-"
"UDF) specifications.  Since DVD-Video presents a specific data structure "
"hierarchy, a particular program such as package:multimedia/dvdauthor[] is "
"needed to author the DVD."
msgstr ""
"DVD-비디오는 ISO 9660 및 micro-UDF (M-UDF) 사양에 기반한 파일 레이아웃입니"
"다.  DVD-Video는 특징적인 데이터 구조 계층 구조를 제공하므로 DVD를 제작하려"
"면 package:multimedia/dvdauthor[]와 같은 프로그램이 필요합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:916
msgid ""
"If an image of the DVD-Video file system already exists, it can be burned in "
"the same way as any other image.  If `dvdauthor` was used to make the DVD "
"and the result is in [.filename]#/path/to/video#, the following command "
"should be used to burn the DVD-Video:"
msgstr ""
"DVD-Video 파일 시스템의 이미지가 이미 존재하는 경우 다른 이미지와 동일한 방법"
"으로 구울 수 있습니다.  DVD를 만드는 데 `dvdauthor` 를 사용했고 그 결과가 [."
"filename]#/path/to/video# 에 있는 경우, 다음 명령을 사용하여 DVD-Video를 구워"
"야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:920
#, no-wrap
msgid "# growisofs -Z /dev/cd0 -dvd-video /path/to/video\n"
msgstr "# growisofs -Z /dev/cd0 -dvd-video /path/to/video\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:924
msgid ""
"`-dvd-video` is passed to man:mkisofs[8] to instruct it to create a DVD-"
"Video file system layout.  This option implies the `-dvd-compat` man:"
"growisofs[1] option."
msgstr ""
"`-dvd-video` 는 DVD-Video 파일 시스템 레이아웃을 만들도록 man:mkisofs[8]에 지"
"시하는 옵션입니다.  이 옵션은 `-dvd-compat` man:growisofs[1] 옵션을 뜻합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:925
#, no-wrap
msgid "Using a DVD+RW"
msgstr "DVD+RW 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:930
msgid ""
"Unlike CD-RW, a virgin DVD+RW needs to be formatted before first use.  It is "
"_recommended_ to let man:growisofs[1] take care of this automatically "
"whenever appropriate.  However, it is possible to use `dvd+rw-format` to "
"format the DVD+RW:"
msgstr ""
"CD-RW와 달리 비어있는 DVD+RW는 처음 사용하기 전에 포맷해야 합니다.  가능하면 "
"man:growisofs[1]가 이 작업을 자동으로 처리하도록 하는 것을 _권장_ 합니다.  그"
"러나 `dvd+rw-format` 을 사용하여 DVD+RW를 포맷할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:934
#: documentation/content/en/books/handbook/disks/_index.adoc:1024
#, no-wrap
msgid "# dvd+rw-format /dev/cd0\n"
msgstr "# dvd+rw-format /dev/cd0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:938
msgid ""
"Only perform this operation once and keep in mind that only virgin DVD+RW "
"medias need to be formatted.  Once formatted, the DVD+RW can be burned as "
"usual."
msgstr ""
"이 작업은 한 번만 수행하고 비어있는 DVD+RW 미디어만 포맷해야 한다는 점에 유의"
"하세요.  포맷이 완료되면 DVD+RW는 평소와 같이 구울 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:941
msgid ""
"To burn a totally new file system and not just append some data onto a DVD"
"+RW, the media does not need to be blanked first.  Instead, write over the "
"previous recording like this:"
msgstr ""
"DVD+RW에 일부 데이터를 추가하는 것이 아니라 완전히 새로운 파일 시스템을 구우"
"려면 먼저 미디어를 비울 필요가 없습니다.  다음과 같이 이전 레코딩을 덮어쓰면 "
"됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:945
#, no-wrap
msgid "# growisofs -Z /dev/cd0 -J -R /path/to/newdata\n"
msgstr "# growisofs -Z /dev/cd0 -J -R /path/to/newdata\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:950
msgid ""
"The DVD+RW format supports appending data to a previous recording.  This "
"operation consists of merging a new session to the existing one as it is not "
"considered to be multi-session writing.  man:growisofs[1] will _grow_ the "
"ISO 9660 file system present on the media."
msgstr ""
"DVD+RW 포맷은 이전 기록에 데이터를 추가하는 기능을 지원합니다.  이 작업은 다"
"중 세션 쓰기로 간주되지 않으므로 새 세션을 기존 세션에 병합하는 것으로 구성됩"
"니다. man:growisofs[1]은 미디어에 있는 ISO 9660 파일 시스템을 _성장_ 시킵니"
"다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:952
msgid "For example, to append data to a DVD+RW, use the following:"
msgstr "예를 들어 DVD+RW에 데이터를 추가하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:956
#: documentation/content/en/books/handbook/disks/_index.adoc:1044
#, no-wrap
msgid "# growisofs -M /dev/cd0 -J -R /path/to/nextdata\n"
msgstr "# growisofs -M /dev/cd0 -J -R /path/to/nextdata\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:959
msgid ""
"The same man:mkisofs[8] options used to burn the initial session should be "
"used during next writes."
msgstr ""
"다음 쓰기 시에는 초기 세션을 구울 때 사용한 것과 동일한 man:mkisofs[8] 옵션"
"을 사용해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:964
msgid ""
"Use `-dvd-compat` for better media compatibility with DVD-ROM drives.  When "
"using DVD+RW, this option will not prevent the addition of data."
msgstr ""
"DVD-ROM 드라이브와의 미디어 호환성을 높이려면 `-dvd-compat` 을 사용하세요.  "
"DVD+RW를 사용하는 경우 이 옵션은 데이터 추가를 막지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:967
msgid "To blank the media, use:"
msgstr "미디어를 비우려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:971
#, no-wrap
msgid "# growisofs -Z /dev/cd0=/dev/zero\n"
msgstr "# growisofs -Z /dev/cd0=/dev/zero\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:973
#, no-wrap
msgid "Using a DVD-RW"
msgstr "DVD-RW 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:977
msgid ""
"A DVD-RW accepts two disc formats: incremental sequential and restricted "
"overwrite.  By default, DVD-RW discs are in sequential format."
msgstr ""
"DVD-RW는 두 가지 디스크 포맷을 지원합니다: 증분 순차 덮어쓰기와 제한 덮어쓰기"
"입니다.  기본적으로 DVD-RW 디스크는 순차 포맷입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:980
msgid ""
"A virgin DVD-RW can be directly written without being formatted.  However, a "
"non-virgin DVD-RW in sequential format needs to be blanked before writing a "
"new initial session."
msgstr ""
"비어있는 DVD-RW는 포맷하지 않고 직접 기록할 수 있습니다.  그러나 순차 포맷이 "
"아닌 공 DVD-RW는 새 초기 세션을 쓰기 전에 한차례 삭제해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:982
msgid "To blank a DVD-RW in sequential mode:"
msgstr "순차 모드에서 DVD-RW를 비우려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:986
#: documentation/content/en/books/handbook/disks/_index.adoc:1031
#, no-wrap
msgid "# dvd+rw-format -blank=full /dev/cd0\n"
msgstr "# dvd+rw-format -blank=full /dev/cd0\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:993
msgid ""
"A full blanking using `-blank=full` will take about one hour on a 1x media.  "
"A fast blanking can be performed using `-blank`, if the DVD-RW will be "
"recorded in Disk-At-Once (DAO) mode.  To burn the DVD-RW in DAO mode, use "
"the command:"
msgstr ""
"`-blank=full` 를 사용한 전체 블랭크는 1x 미디어에서 약 1시간이 소요됩니다.  "
"DVD-RW를 한번에 디스크 기록(DAO) 모드로 기록할 경우 `-blank` 를 사용하여 빠"
"른 삭제를 수행할 수 있습니다.  DAO 모드에서 DVD-RW를 구우려면 다음 명령을 사"
"용하십시오:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:997
#, no-wrap
msgid "# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso\n"
msgstr "# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1000
msgid ""
"Since man:growisofs[1] automatically attempts to detect fast blanked media "
"and engage DAO write, `-use-the-force-luke=dao` should not be required."
msgstr ""
"man:growisofs[1]는 자동으로 빠르게 비워진 미디어를 감지하고 DAO 쓰기를 시도하"
"므로 `-use-the-force-luke=dao` 옵션이 필요하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1002
msgid ""
"One should instead use restricted overwrite mode with any DVD-RW as this "
"format is more flexible than the default of incremental sequential."
msgstr ""
"이 형식은 기본값인 증분 순차보다 유연성이 뛰어나므로 DVD-RW에 제한 덮어쓰기 "
"모드를 사용하는 것이 좋습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1005
msgid ""
"To write data on a sequential DVD-RW, use the same instructions as for the "
"other DVD formats:"
msgstr ""
"순차모드로 DVD-RW에 데이터를 기록하려면 다른 DVD 포맷과 동일한 지침을 따르세"
"요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1009
#, no-wrap
msgid "# growisofs -Z /dev/cd0 -J -R /path/to/data\n"
msgstr "# growisofs -Z /dev/cd0 -J -R /path/to/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1013
msgid ""
"To append some data to a previous recording, use `-M` with man:"
"growisofs[1].  However, if data is appended on a DVD-RW in incremental "
"sequential mode, a new session will be created on the disc and the result "
"will be a multi-session disc."
msgstr ""
"이전 레코딩에 일부 데이터를 추가하려면 `-M` 과 함께 man:growisofs[1]을 사용합"
"니다.  그러나 DVD-RW에 데이터를 증분 순차 모드로 추가하면 디스크에 새 세션이 "
"생성되고 그 결과 멀티 세션 디스크가 됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1018
msgid ""
"A DVD-RW in restricted overwrite format does not need to be blanked before a "
"new initial session.  Instead, overwrite the disc with `-Z`.  It is also "
"possible to grow an existing ISO 9660 file system written on the disc with `-"
"M`.  The result will be a one-session DVD."
msgstr ""
"제한된 덮어쓰기 형식의 DVD-RW는 새로운 초기 세션 전에 디스크를 비울 필요가 없"
"습니다.  대신 `-Z` 로 디스크를 덮어씁니다.  디스크에 기록된 기존 ISO 9660 파"
"일 시스템을 `-M` 으로 성장시킬 수도 있습니다.  결과적으로 싱글 세션 DVD가 됩"
"니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1020
msgid ""
"To put a DVD-RW in restricted overwrite format, the following command must "
"be used:"
msgstr ""
"DVD-RW를 제한된 덮어쓰기 포맷으로 설정하려면 다음 명령을 사용해야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1027
msgid "To change back to sequential format, use:"
msgstr "순차 형식으로 다시 변경하려면 다음을 사용합니다:"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1033
#, no-wrap
msgid "Multi-Session"
msgstr "멀티 세션"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1038
msgid ""
"Few DVD-ROM drives support multi-session DVDs and most of the time only read "
"the first session.  DVD+R, DVD-R and DVD-RW in sequential format can accept "
"multiple sessions.  The notion of multiple sessions does not exist for the "
"DVD+RW and the DVD-RW restricted overwrite formats."
msgstr ""
"멀티 세션 DVD를 지원하는 DVD-ROM 드라이브는 거의 없으며 대부분의 경우 첫 번"
"째 세션만 읽습니다.  순차 형식의 DVD+R, DVD-R 및 DVD-RW는 여러 세션을 수용할 "
"수 있습니다.  DVD+RW 및 덮어쓰기 제한 형식의 DVD-RW에는 다중 세션이라는 개념"
"이 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1040
msgid ""
"Using the following command after an initial non-closed session on a DVD+R, "
"DVD-R, or DVD-RW in sequential format, will add a new session to the disc:"
msgstr ""
"DVD+R, DVD-R 또는 DVD-RW에서 순차적으로 닫히지 않은 초기 세션이 끝난 후 다음 "
"명령을 사용하면 디스크에 새 세션이 추가됩니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1049
msgid ""
"Using this command with a DVD+RW or a DVD-RW in restricted overwrite mode "
"will append data while merging the new session to the existing one.  The "
"result will be a single-session disc.  Use this method to add data after an "
"initial write on these types of media."
msgstr ""
"이 명령을 제한된 덮어쓰기 모드에서 DVD+RW 또는 DVD-RW와 함께 사용하면 새 세션"
"을 기존 세션에 병합하면서 데이터를 추가할 수 있습니다.  결과는 단일 세션 디스"
"크가 됩니다.  이러한 유형의 미디어에 처음 쓴 후 데이터를 추가하려면 다음 방법"
"을 사용하십시오."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1054
msgid ""
"Since some space on the media is used between each session to mark the end "
"and start of sessions, one should add sessions with a large amount of data "
"to optimize media space.  The number of sessions is limited to 154 for a DVD"
"+R, about 2000 for a DVD-R, and 127 for a DVD+R Double Layer."
msgstr ""
"각 세션 사이에는 세션의 끝과 시작을 표시하기 위해 미디어의 일부 공간이 사용되"
"므로 미디어 공간을 최적화하려면 데이터 용량이 큰 세션을 추가해야 합니다.  세"
"션 수는 DVD+R의 경우 154개, DVD-R의 경우 약 2000개, DVD+R 더블 레이어의 경우 "
"127개로 제한됩니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1056
#, no-wrap
msgid "For More Information"
msgstr "추가정보"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1059
msgid ""
"To obtain more information about a DVD, use `dvd+rw-mediainfo _/dev/cd0_` "
"while the disc in the specified drive."
msgstr ""
"DVD에 대한 자세한 정보를 얻으려면 지정된 드라이브에 디스크가 있는 상태에서 "
"`dvd+rw-mediainfo _/dev/cd0_` 를 사용하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1061
msgid ""
"More information about dvd+rw-tools can be found in man:growisofs[1], on the "
"http://fy.chalmers.se/~appro/linux/DVD+RW/[dvd+rw-tools web site], and in "
"the http://lists.debian.org/cdwrite/[cdwrite mailing list] archives."
msgstr ""
"dvd+rw-tools에 대한 자세한 내용은 man:growisofs[1], http://fy.chalmers.se/"
"~appro/linux/DVD+RW/[dvd+rw-tools 웹 사이트] 및 http://lists.debian.org/"
"cdwrite/[cdwrite 메일링 리스트] 아카이브에서 확인할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1065
msgid ""
"When creating a problem report related to the use of dvd+rw-tools, always "
"include the output of `dvd+rw-mediainfo`."
msgstr ""
"DVD+RW 도구 사용과 관련된 문제 보고서를 작성할 때는 항상 `dvd+rw-mediainfo` "
"의 출력을 포함하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1068
#, no-wrap
msgid "Using a DVD-RAM"
msgstr "DVD-RAM 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1072
msgid ""
"DVD-RAM writers can use either a SCSI or ATAPI interface.  For ATAPI "
"devices, DMA access has to be enabled by adding the following line to [."
"filename]#/boot/loader.conf#:"
msgstr ""
"DVD-RAM 라이터는 SCSI 또는 ATAPI 인터페이스를 사용할 수 있습니다.  ATAPI 장치"
"의 경우 [.filename]#/boot/loader.conf# 에 다음 줄을 추가하여 DMA 액세스를 활"
"성화해야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1081
msgid ""
"A DVD-RAM can be seen as a removable hard drive.  Like any other hard drive, "
"the DVD-RAM must be formatted before it can be used.  In this example, the "
"whole disk space will be formatted with a standard UFS2 file system:"
msgstr ""
"DVD-RAM은 이동식 하드 드라이브로 볼 수 있습니다.  다른 하드 드라이브와 마찬가"
"지로 DVD-RAM을 사용하려면 먼저 포맷해야 합니다.  이 예에서는 전체 디스크 공간"
"이 표준 UFS2 파일 시스템으로 포맷됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1087
#, no-wrap
msgid ""
"# dd if=/dev/zero of=/dev/acd0 bs=2k count=1\n"
"# bsdlabel -Bw acd0\n"
"# newfs /dev/acd0\n"
msgstr ""
"# dd if=/dev/zero of=/dev/acd0 bs=2k count=1\n"
"# bsdlabel -Bw acd0\n"
"# newfs /dev/acd0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1090
msgid ""
"The DVD device, [.filename]#acd0#, must be changed according to the "
"configuration."
msgstr "DVD 장치인 [.filename]#acd0# 은 반드시 구성을 이용해 변경해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1092
msgid ""
"Once the DVD-RAM has been formatted, it can be mounted as a normal hard "
"drive:"
msgstr "DVD-RAM을 포맷한 후에는 일반 하드 드라이브처럼 마운트 할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1096
#, no-wrap
msgid "# mount /dev/acd0 /mnt\n"
msgstr "# mount /dev/acd0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1099
msgid "Once mounted, the DVD-RAM will be both readable and writeable."
msgstr "마운트가 완료되면 DVD-RAM은 읽기 및 쓰기가 모두 가능합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1101
#, no-wrap
msgid "Creating and Using Floppy Disks"
msgstr "플로피 디스크 만들기 및 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1104
msgid "This section explains how to format a 3.5 inch floppy disk in FreeBSD."
msgstr ""
"이 섹션에서는 FreeBSD에서 3.5인치 플로피 디스크를 포맷하는 방법을 설명합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1108
#, no-wrap
msgid "*Procedure: Steps to Format a Floppy*\n"
msgstr "*절차: 플로피 포맷 단계*\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1113
msgid ""
"A floppy disk needs to be low-level formatted before it can be used.  This "
"is usually done by the vendor, but formatting is a good way to check media "
"integrity.  To low-level format the floppy disk on FreeBSD, use man:"
"fdformat[1].  When using this utility, make note of any error messages, as "
"these can help determine if the disk is good or bad."
msgstr ""
"플로피 디스크를 사용하려면 먼저 로우 레벨 포맷을 해야 합니다.  이 작업은 일반"
"적으로 공급업체에서 수행하지만, 포맷은 미디어 무결성을 확인하는 좋은 방법입니"
"다.  FreeBSD에서 플로피 디스크를 로우레벨 포맷하려면 man:fdformat[1]을 사용합"
"니다.  이 유틸리티를 사용할 때는 디스크의 양호 여부를 판단하는 데 도움이 될 "
"수 있으므로 오류 메시지를 기록해 두세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1115
msgid ""
"To format the floppy, insert a new 3.5 inch floppy disk into the first "
"floppy drive and issue:"
msgstr ""
"플로피를 포맷하려면 새 3.5인치 플로피 디스크를 첫 번째 플로피 드라이브에 삽입"
"하고:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1119
#, no-wrap
msgid "# /usr/sbin/fdformat -f 1440 /dev/fd0\n"
msgstr "# /usr/sbin/fdformat -f 1440 /dev/fd0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1122
msgid ""
"After low-level formatting the disk, create a disk label as it is needed by "
"the system to determine the size of the disk and its geometry. The supported "
"geometry values are listed in [.filename]#/etc/disktab#."
msgstr ""
"디스크를 로우레벨 포맷한 후 시스템에서 디스크의 크기와 지오메트리를 결정하는 "
"데 필요한 디스크 레이블을 생성합니다. 지원되는 지오메트리 값은 [.filename]#/"
"etc/disktab# 에 나열됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1124
msgid "To write the disk label, use man:bsdlabel[8]:"
msgstr "디스크 레이블을 작성하려면 man:bsdlabel[8]을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1128
#, no-wrap
msgid "# /sbin/bsdlabel -B -w /dev/fd0 fd1440\n"
msgstr "# /sbin/bsdlabel -B -w /dev/fd0 fd1440\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1131
msgid ""
"The floppy is now ready to be high-level formatted with a file system. The "
"floppy's file system can be either UFS or FAT, where FAT is generally a "
"better choice for floppies."
msgstr ""
"이제 플로피에 파일 시스템을 사용하여 높은 수준의 포맷을 할 준비가 되었습니"
"다. 플로피의 파일 시스템은 UFS 또는 FAT 중 하나를 선택할 수 있으며, 일반적으"
"로 플로피에는 FAT가 더 좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1133
msgid "To format the floppy with FAT, issue:"
msgstr "FAT로 플로피를 포맷하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1137
#, no-wrap
msgid "# /sbin/newfs_msdos /dev/fd0\n"
msgstr "# /sbin/newfs_msdos /dev/fd0\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1143
msgid ""
"The disk is now ready for use.  To use the floppy, mount it with man:"
"mount_msdosfs[8].  One can also install and use package:emulators/mtools[] "
"from the Ports Collection."
msgstr ""
"이제 디스크를 사용할 준비가 되었습니다.  플로피를 사용하려면 man:"
"mount_msdosfs[8]로 마운트합니다.  포트 컬렉션에서 package:emulators/mtools[]"
"를 설치하여 사용할 수도 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1145
#, no-wrap
msgid "Backup Basics"
msgstr "백업의 기초"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1148
msgid ""
"Implementing a backup plan is essential in order to have the ability to "
"recover from disk failure, accidental file deletion, random file corruption, "
"or complete machine destruction, including destruction of on-site backups."
msgstr ""
"디스크 장애, 우발적인 파일 삭제, 무작위 파일 손상 또는 온사이트 백업의 파괴"
"를 포함한 완전한 시스템 파괴로부터 복구할 수 있는 능력을 갖추려면 백업 계획"
"을 실행하는 것이 필수적입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1151
msgid ""
"The backup type and schedule will vary, depending upon the importance of the "
"data, the granularity needed for file restores, and the amount of acceptable "
"downtime.  Some possible backup techniques include:"
msgstr ""
"백업 유형과 일정은 데이터의 중요도, 파일 복원에 필요한 세부 수준, 허용 가능"
"한 다운타임의 양에 따라 달라집니다.  몇 가지 가능한 백업 기술은 다음과 같습니"
"다:"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1153
msgid ""
"Archives of the whole system, backed up onto permanent, off-site media. This "
"provides protection against all of the problems listed above, but is slow "
"and inconvenient to restore from, especially for non-privileged users."
msgstr ""
"영구적인 오프사이트 미디어에 백업된 전체 시스템 아카이브. 이 방법은 위에 나열"
"된 모든 문제에 대한 보호 기능을 제공하지만, 특히 권한이 없는 사용자의 경우 복"
"원 속도가 느리고 불편합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1154
msgid ""
"File system snapshots, which are useful for restoring deleted files or "
"previous versions of files."
msgstr ""
"파일 시스템 스냅샷은 삭제된 파일이나 이전 버전의 파일을 복원하는 데 유용합니"
"다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1155
msgid ""
"Copies of whole file systems or disks which are synchronized with another "
"system on the network using a scheduled package:net/rsync[]."
msgstr ""
"예약된 package:net/rsync[]를 사용하여 네트워크의 다른 시스템과 동기화되는 전"
"체 파일 시스템 또는 디스크의 복사본입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1156
msgid ""
"Hardware or software RAID, which minimizes or avoids downtime when a disk "
"fails."
msgstr ""
"디스크 장애 시 다운타임을 최소화하거나 방지하는 하드웨어 또는 소프트웨어 RAID"
"입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1160
msgid ""
"Typically, a mix of backup techniques is used.  For example, one could "
"create a schedule to automate a weekly, full system backup that is stored "
"off-site and to supplement this backup with hourly ZFS snapshots.  In "
"addition, one could make a manual backup of individual directories or files "
"before making file edits or deletions."
msgstr ""
"일반적으로 여러 백업 기술이 혼합되어 사용됩니다.  예를 들어, 매주 오프사이트"
"에 저장되는 전체 시스템 백업을 자동화하고 이 백업을 시간별 ZFS 스냅샷으로 보"
"완하는 일정을 만들 수 있습니다.  또한 파일을 편집하거나 삭제하기 전에 개별 디"
"렉터리 또는 파일을 수동으로 백업할 수도 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1162
msgid ""
"This section describes some of the utilities which can be used to create and "
"manage backups on a FreeBSD system."
msgstr ""
"이 섹션에서는 FreeBSD 시스템에서 백업을 생성하고 관리하는 데 사용할 수 있는 "
"몇 가지 유틸리티에 대해 설명합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1163
#, no-wrap
msgid "File System Backups"
msgstr "파일 시스템 백업"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1169
msgid ""
"The traditional UNIX(R) programs for backing up a file system are man:"
"dump[8], which creates the backup, and man:restore[8], which restores the "
"backup.  These utilities work at the disk block level, below the "
"abstractions of the files, links, and directories that are created by file "
"systems.  Unlike other backup software, `dump` backs up an entire file "
"system and is unable to backup only part of a file system or a directory "
"tree that spans multiple file systems.  Instead of writing files and "
"directories, `dump` writes the raw data blocks that comprise files and "
"directories."
msgstr ""
"파일 시스템을 백업하는 전통적인 UNIX(R) 프로그램은 백업을 생성하는 man:"
"dump[8]와 백업을 복원하는 man:restore[8]입니다.  이러한 유틸리티는 파일 시스"
"템에서 생성되는 파일, 링크 및 디렉터리의 추상화 아래인 디스크 블록 수준에서 "
"작동합니다.  다른 백업 소프트웨어와 달리 `dump` 는 전체 파일 시스템을 백업하"
"며 파일 시스템의 일부만 백업하거나 여러 파일 시스템에 걸쳐 있는 디렉토리 트리"
"를 백업할 수 없습니다.  `dump` 는 파일과 디렉터리를 쓰는 대신 파일과 디렉터리"
"를 구성하는 원시 데이터 블록을 기록합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1173
#, fuzzy
#| msgid ""
#| "If `dump` is used on the root directory, it will not back up [.filename]#/"
#| "home#, [.filename]#/usr# or many other directories since these are "
#| "typically mount points for other file systems or symbolic links into "
#| "those file systems."
msgid ""
"If `dump` is used on the root directory, it will not back up [.filename]#/"
"home#, [.filename]#/usr#, or many other directories since these are "
"typically mount points for other file systems or symbolic links into those "
"file systems."
msgstr ""
"루트 디렉터리에 `dump` 를 사용하면 일반적으로 다른 파일 시스템의 마운트 지점 "
"또는 해당 파일 시스템에 대한 심볼릭 링크로 구성된 [.filename]#/home#, [."
"filename]#/usr# 또는 다른 대부분의 디렉터리를 백업하지 않습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1177
#, fuzzy
#| msgid ""
#| "When used to restore data, `restore` stores temporary files in [."
#| "filename]#/tmp/# by default.  When using a recovery disk with a small [."
#| "filename]#/tmp#, set `TMPDIR` to a directory with more free space in "
#| "order for the restore to succeed."
msgid ""
"When used to restore data, `restore` stores temporary files in [.filename]#/"
"tmp/# by default.  When using a recovery disk with a small [.filename]#/"
"tmp#, set `TMPDIR` to a directory with more free space for the restore to "
"succeed."
msgstr ""
"데이터를 복원하는 데 사용하는 경우 `restore` 는 기본적으로 임시 파일을 [."
"filename]#/tmp/# 에 저장합니다.  작은 [.filename]#/tmp# 의 복구 디스크를 사용"
"하는 경우 복원이 성공하려면 여유 공간이 더 많은 디렉터리로 `TMPDIR` 을 설정하"
"세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1181
msgid ""
"When using `dump`, be aware that some quirks remain from its early days in "
"Version 6 of AT&T UNIX(R),circa 1975.  The default parameters assume a "
"backup to a 9-track tape, rather than to another type of media or to the "
"high-density tapes available today.  These defaults must be overridden on "
"the command line."
msgstr ""
"`dump` 를 사용할 때는 1975년경 AT&T UNIX(R) 버전 6 초기의 몇 가지 특이한 점"
"이 남아 있다는 점에 유의하세요.  기본 매개변수는 다른 유형의 미디어나 현재 사"
"용 가능한 고밀도 테이프가 아닌 9트랙 테이프에 백업한다고 가정합니다.  이러한 "
"기본값은 명령줄에서 재정의해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1184
#, fuzzy
#| msgid ""
#| "It is possible to backup a file system across the network to a another "
#| "system or to a tape drive attached to another computer.  While the man:"
#| "rdump[8] and man:rrestore[8] utilities can be used for this purpose, they "
#| "are not considered to be secure."
msgid ""
"It is possible to backup a file system across the network to another system "
"or a tape drive attached to another computer.  While the man:rdump[8] and "
"man:rrestore[8] utilities can be used for this purpose, they are not "
"considered to be secure."
msgstr ""
"네트워크를 통해 파일 시스템을 다른 시스템이나 다른 컴퓨터에 연결된 테이프 드"
"라이브에 백업할 수 있습니다.  man:rdump[8] 및 man:rrestore[8] 유틸리티를 이 "
"용도로 사용할 수 있지만, 이 유틸리티는 안전하지 않은 것으로 간주됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1187
#, fuzzy
#| msgid ""
#| "Instead, one can use `dump` and `restore` in a more secure fashion over "
#| "an SSH connection.  This example creates a full, compressed backup of [."
#| "filename]#/usr# and sends the backup file to the specified host over a "
#| "SSH connection."
msgid ""
"Instead, one can use `dump` and `restore` more securely over an SSH "
"connection.  This example creates a full, compressed backup of [.filename]#/"
"usr# and sends the backup file to the specified host over an SSH connection."
msgstr ""
"대신, `dump` 와 `restore` 을 사용하여 SSH 연결을 통해 보다 안전한 방식으로 백"
"업할 수 있습니다.  이 예에서는 [.filename]#/usr# 의 전체 압축 백업을 만들고 "
"SSH 연결을 통해 지정된 호스트로 백업 파일을 보냅니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1188
#, no-wrap
msgid "Using `dump` over ssh"
msgstr "ssh에서 `dump` 사용하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1195
#, no-wrap
msgid ""
"# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \\\n"
"          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz\n"
msgstr ""
"# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \\\n"
"          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1199
#, fuzzy
#| msgid ""
#| "This example sets `RSH` in order to write the backup to a tape drive on a "
#| "remote system over a SSH connection:"
msgid ""
"This example sets `RSH` in order to write the backup to a tape drive on a "
"remote system over an SSH connection:"
msgstr ""
"이 예에서는 SSH 연결을 통해 원격 시스템의 테이프 드라이브에 백업을 쓰기 위해 "
"`RSH` 를 설정합니다:"

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1200
#, no-wrap
msgid "Using `dump` over ssh with `RSH` Set"
msgstr "ssh에 `dump` 를 `RSH` 설정으로 사용하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1206
#, no-wrap
msgid "# env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr\n"
msgstr "# env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1212
msgid ""
"Systems using the crossref:zfs[,Z file system (ZFS)] can make use of man:"
"zfs[8] for creating snapshots, as well as crossref:zfs[zfs-zfs-send,sending "
"and receiving] them to/from remote systems."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1214
#, no-wrap
msgid "Directory Backups"
msgstr "디렉터리 백업"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1217
msgid ""
"Several built-in utilities are available for backing up and restoring "
"specified files and directories as needed."
msgstr ""
"필요에 따라 지정된 파일과 디렉터리를 백업하고 복원할 수 있는 여러 가지 기본 "
"제공 유틸리티를 사용할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1221
msgid ""
"A good choice for making a backup of all of the files in a directory is man:"
"tar[1].  This utility dates back to Version 6 of AT&T UNIX(R) and by default "
"assumes a recursive backup to a local tape device.  Switches can be used to "
"instead specify the name of a backup file."
msgstr ""
"디렉터리에 있는 모든 파일을 백업하는 데는 man:tar[1]를 사용하는 것이 좋습니"
"다.  이 유틸리티는 AT&T UNIX(R) 버전 6으로 거슬러 올라가며 기본적으로 로컬 테"
"이프 장치에 대한 재귀 백업을 가정합니다.  스위치를 사용하여 백업 파일의 이름"
"을 대신 지정할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1224
msgid ""
"This example creates a compressed backup of the current directory and saves "
"it to [.filename]#/tmp/mybackup.tgz#.  When creating a backup file, make "
"sure that the backup is not saved to the same directory that is being backed "
"up."
msgstr ""
"이 예에서는 현재 디렉터리의 압축 백업을 만들어 [.filename]#/tmp/mybackup."
"tgz# 에 저장합니다.  백업 파일을 만들 때 백업이 백업 중인 디렉터리와 동일한 "
"디렉터리에 저장되지 않도록 하세요."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1225
#, no-wrap
msgid "Backing Up the Current Directory with `tar`"
msgstr "`tar` 로 현재 디렉토리 백업하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1231
#, no-wrap
msgid "# tar czvf /tmp/mybackup.tgz .\n"
msgstr "# tar czvf /tmp/mybackup.tgz .\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1237
msgid ""
"To restore the entire backup, `cd` into the directory to restore into and "
"specify the name of the backup.  Note that this will overwrite any newer "
"versions of files in the restore directory.  When in doubt, restore to a "
"temporary directory or specify the name of the file within the backup to "
"restore."
msgstr ""
"전체 백업을 복원하려면 복원할 디렉터리에 `cd` 를 입력하고 백업 이름을 지정합"
"니다.  이렇게 하면 복원 디렉터리에 있는 최신 버전의 파일을 덮어쓰게 됩니다.  "
"확실하지 않은 경우 임시 디렉터리로 복원하거나 복원할 백업 내의 파일 이름을 지"
"정하세요."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1238
#, no-wrap
msgid "Restoring Up the Current Directory with `tar`"
msgstr "`tar` 로 현재 디렉토리 복원하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1244
#, no-wrap
msgid "# tar xzvf /tmp/mybackup.tgz\n"
msgstr "# tar xzvf /tmp/mybackup.tgz\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1249
msgid ""
"There are dozens of available switches which are described in man:tar[1].  "
"This utility also supports the use of exclude patterns to specify which "
"files should not be included when backing up the specified directory or "
"restoring files from a backup."
msgstr ""
"man:tar[1]에 설명된 수십 가지 스위치를 사용할 수 있습니다.  이 유틸리티는 지"
"정한 디렉터리를 백업하거나 백업에서 파일을 복원할 때 포함하지 말아야 할 파일"
"을 지정하는 제외 패턴 사용도 지원합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1252
msgid ""
"To create a backup using a specified list of files and directories, man:"
"cpio[1] is a good choice.  Unlike `tar`, `cpio` does not know how to walk "
"the directory tree and it must be provided the list of files to backup."
msgstr ""
"지정된 파일 및 디렉터리 목록을 사용하여 백업을 생성하려면 man:cpio[1]를 사용"
"하는 것이 좋습니다.  `tar` 와 달리 `cpio` 는 디렉토리 트리를 탐색하는 방법을 "
"모르기 때문에 백업할 파일 목록을 제공해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1255
msgid ""
"For example, a list of files can be created using `ls` or `find`.  This "
"example creates a recursive listing of the current directory which is then "
"piped to `cpio` in order to create an output backup file named [.filename]#/"
"tmp/mybackup.cpio#."
msgstr ""
"예를 들어, `ls` 또는 `find` 를 사용하여 파일 목록을 만들 수 있습니다.  이 예"
"에서는 현재 디렉터리의 재귀 목록을 생성한 다음 `cpio` 로 파이프하여 [."
"filename]#/tmp/mybackup.cpio# 라는 이름의 출력 백업 파일을 생성합니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1256
#, no-wrap
msgid "Using `ls` and `cpio` to Make a Recursive Backup of the Current Directory"
msgstr "`ls` 및 `cpio` 를 사용하여 현재 디렉토리의 재귀적 백업 만들기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1262
#, no-wrap
msgid "# ls -R | cpio -ovF /tmp/mybackup.cpio\n"
msgstr "# ls -R | cpio -ovF /tmp/mybackup.cpio\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1268
msgid ""
"A backup utility which tries to bridge the features provided by `tar` and "
"`cpio` is man:pax[1].  Over the years, the various versions of `tar` and "
"`cpio` became slightly incompatible.  POSIX(R) created `pax` which attempts "
"to read and write many of the various `cpio` and `tar` formats, plus new "
"formats of its own."
msgstr ""
"`tar` 와 `cpio` 가 제공하는 기능을 연결하는 백업 유틸리티는 man:pax[1]입니"
"다.  수년에 걸쳐, `tar` 와 `cpio` 의 다양한 버전은 약간 호환되지 않게 되었습"
"니다.  POSIX(R)는 다양한 `cpio` 와 `tar` 포맷과 새로운 포맷을 읽고 쓰도록 시"
"도하는 `pax` 를 만들었습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1270
msgid "The `pax` equivalent to the previous examples would be:"
msgstr "이전 예제에 해당하는 'pax' 는 다음과 같습니다:"

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1271
#, no-wrap
msgid "Backing Up the Current Directory with `pax`"
msgstr "`pax` 로 현재 디렉토리 백업하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1277
#, no-wrap
msgid "# pax -wf /tmp/mybackup.pax .\n"
msgstr "# pax -wf /tmp/mybackup.pax .\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1281
#, no-wrap
msgid "Using Data Tapes for Backups"
msgstr "백업에 데이터 테이프 사용하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1286
msgid ""
"While tape technology has continued to evolve, modern backup systems tend to "
"combine off-site backups with local removable media.  FreeBSD supports any "
"tape drive that uses SCSI, such as LTO or DAT.  There is limited support for "
"SATA and USB tape drives."
msgstr ""
"테이프 기술은 계속 발전해 왔지만, 최신 백업 시스템은 오프사이트 백업과 로컬 "
"이동식 미디어를 결합하는 경향이 있습니다.  FreeBSD는 LTO 또는 DAT와 같은 SCSI"
"를 사용하는 모든 테이프 드라이브를 지원합니다.  SATA 및 USB 테이프 드라이브"
"에 대한 지원은 제한적입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1290
msgid ""
"For SCSI tape devices, FreeBSD uses the man:sa[4] driver and the [."
"filename]#/dev/sa0#, [.filename]#/dev/nsa0#, and [.filename]#/dev/esa0# "
"devices.  The physical device name is [.filename]#/dev/sa0#. When [."
"filename]#/dev/nsa0# is used, the backup application will not rewind the "
"tape after writing a file, which allows writing more than one file to a "
"tape.  Using [.filename]#/dev/esa0# ejects the tape after the device is "
"closed."
msgstr ""
"SCSI 테이프 장치의 경우, FreeBSD는 man:sa[4] 드라이버와 [.filename]#/dev/"
"sa0#, [.filename]#/dev/nsa0# 및 [.filename]#/dev/esa0# 장치를 사용합니다.  실"
"제 장치 이름은 [.filename]#/dev/sa0# 입니다. [.filename]#/dev/nsa0# 을 사용하"
"면 백업 애플리케이션이 파일 쓰기 후 테이프를 되감지 않으므로 테이프에 두 개 "
"이상의 파일을 쓸 수 있습니다.  [.filename]#/dev/esa0# 을 사용하면 장치를 닫"
"은 후 테이프가 배출됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1293
msgid ""
"In FreeBSD, `mt` is used to control operations of the tape drive, such as "
"seeking through files on a tape or writing tape control marks to the tape.  "
"For example, the first three files on a tape can be preserved by skipping "
"past them before writing a new file:"
msgstr ""
"FreeBSD에서 `mt` 는 테이프에 있는 파일을 찾거나 테이프에 테이프 제어 표시를 "
"쓰는 등 테이프 드라이브의 작업을 제어하는 데 사용됩니다.  예를 들어, 테이프"
"에 있는 처음 세 개의 파일은 새 파일을 쓰기 전에 건너뛰어서 보존할 수 있습니"
"다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1297
#, no-wrap
msgid "# mt -f /dev/nsa0 fsf 3\n"
msgstr "# mt -f /dev/nsa0 fsf 3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1300
msgid "This utility supports many operations. Refer to man:mt[1] for details."
msgstr ""
"이 유틸리티는 다양한 작업을 지원합니다. 자세한 내용은 man:mt[1]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1302
msgid ""
"To write a single file to tape using `tar`, specify the name of the tape "
"device and the file to backup:"
msgstr ""
"`tar` 를 사용하여 단일 파일을 테이프에 기록하려면 테이프 장치의 이름과 백업"
"할 파일을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1306
#, no-wrap
msgid "# tar cvf /dev/sa0 file\n"
msgstr "# tar cvf /dev/sa0 file\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1309
msgid ""
"To recover files from a `tar` archive on tape into the current directory:"
msgstr "테이프의 'tar' 아카이브에서 현재 디렉토리로 파일을 복구하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1313
#, no-wrap
msgid "# tar xvf /dev/sa0\n"
msgstr "# tar xvf /dev/sa0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1317
msgid ""
"To backup a UFS file system, use `dump`.  This examples backs up [."
"filename]#/usr# without rewinding the tape when finished:"
msgstr ""
"UFS 파일 시스템을 백업하려면 `dump` 를 사용합니다.  이 예제는 완료되면 테이프"
"를 되감지 않고 [.filename]#/usr# 을 백업합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1321
#, no-wrap
msgid "# dump -0aL -b64 -f /dev/nsa0 /usr\n"
msgstr "# dump -0aL -b64 -f /dev/nsa0 /usr\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1324
msgid ""
"To interactively restore files from a `dump` file on tape into the current "
"directory:"
msgstr "테이프의 `dump` 파일에서 현재 디렉토리로 파일을 대화형으로 복원합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1328
#, no-wrap
msgid "# restore -i -f /dev/nsa0\n"
msgstr "# restore -i -f /dev/nsa0\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1331
#, no-wrap
msgid "Third-Party Backup Utilities"
msgstr "타사 백업 유틸리티"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1335
msgid ""
"The FreeBSD Ports Collection provides many third-party utilities which can "
"be used to schedule the creation of backups, simplify tape backup, and make "
"backups easier and more convenient.  Many of these applications are client/"
"server based and can be used to automate the backups of a single system or "
"all of the computers in a network."
msgstr ""
"FreeBSD 포트 컬렉션은 백업 생성을 예약하고, 테이프 백업을 단순화하며, 백업을 "
"더 쉽고 편리하게 만드는 데 사용할 수 있는 많은 타사 유틸리티를 제공합니다.  "
"이러한 애플리케이션 중 다수는 클라이언트/서버 기반이며 단일 시스템 또는 네트"
"워크에 있는 모든 컴퓨터의 백업을 자동화하는 데 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1337
msgid "Popular utilities include:"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1339
msgid "Amanda (package:misc/amanda-server[] and package:misc/amanda-client[]),"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1340
msgid ""
"Bacula (package:sysutils/bacula13-server[] and package:sysutils/bacula13-"
"client[]),"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1341
msgid ""
"Bareos (package:sysutils/bareos-server[] and package:sysutils/bareos-"
"client[]),"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1342
msgid "package:net/rsync[],"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1343
msgid "package:sysutils/duply[], and"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1344
msgid "package:sysutils/duplicity[]."
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1345
#, no-wrap
msgid "Emergency Recovery"
msgstr "긴급 복구"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1348
msgid ""
"In addition to regular backups, it is recommended to perform the following "
"steps as part of an emergency preparedness plan."
msgstr ""
"정기 백업 외에도 비상 대비 계획의 일환으로 다음 단계를 수행하는 것이 좋습니"
"다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1350
msgid "Create a print copy of the output of the following commands:"
msgstr "다음 명령 출력의 인쇄 사본을 만듭니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1352
msgid "`gpart show`"
msgstr "`gpart show`"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1353
msgid "`more /etc/fstab`"
msgstr "`more /etc/fstab`"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1354
msgid "`pkg prime-list`"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1355
msgid "`dmesg`"
msgstr "`dmesg`"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1359
msgid ""
"Store this printout and a copy of the installation media in a secure "
"location.  Should an emergency restore be needed, boot into the installation "
"media and select `Live CD` to access a rescue shell.  This rescue mode can "
"be used to view the current state of the system, and if needed, to reformat "
"disks and restore data from backups."
msgstr ""
"이 출력물과 설치 미디어 사본을 안전한 장소에 보관하세요.  긴급 복원이 필요한 "
"경우, 설치 미디어로 부팅하고 `Live CD` 를 선택하여 복구 셸에 액세스합니다.  "
"이 복구 모드에서는 시스템의 현재 상태를 확인하고 필요한 경우 디스크를 다시 포"
"맷하고 백업에서 데이터를 복원하는 데 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1364
msgid ""
"Next, test the rescue shell and the backups.  Make notes of the procedure.  "
"Store these notes with the media, the printouts, and the backups.  These "
"notes may prevent the inadvertent destruction of the backups while under the "
"stress of performing an emergency recovery."
msgstr ""
"다음으로, 복구 셸과 백업을 테스트합니다.  절차를 메모합니다.  이 메모를 미디"
"어, 출력물, 백업과 함께 보관하세요.  이러한 메모는 긴급 복구를 수행해야 하는 "
"상황에서 백업이 실수로 파괴되는 것을 방지할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1366
msgid ""
"For an added measure of security, store the latest backup at a remote "
"location which is physically separated from the computers and disk drives by "
"a significant distance."
msgstr ""
"보안을 강화하려면 컴퓨터 및 디스크 드라이브와 물리적으로 멀리 떨어진 원격 위"
"치에 최신 백업을 저장하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1368
#, no-wrap
msgid "Memory Disks"
msgstr "메모리 디스크"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1372
msgid ""
"In addition to physical disks, FreeBSD also supports the creation and use of "
"memory disks.  One possible use for a memory disk is to access the contents "
"of an ISO file system without the overhead of first burning it to a CD or "
"DVD, then mounting the CD/DVD media."
msgstr ""
"물리 디스크 외에도, FreeBSD는 메모리 디스크의 생성과 사용도 지원합니다.  메모"
"리 디스크의 용도 중 하나는 ISO 파일 시스템의 콘텐츠에 액세스하기 위해 CD나 "
"DVD로 구운 다음 CD/DVD 미디어를 마운트하는 번거로움 없이 액세스하는 것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1376
msgid ""
"In FreeBSD, the man:md[4] driver is used to provide support for memory "
"disks.  The [.filename]#GENERIC# kernel includes this driver.  When using a "
"custom kernel configuration file, ensure it includes this line:"
msgstr ""
"FreeBSD에서는 man:md[4] 드라이버가 메모리 디스크에 대한 지원을 제공하는 데 사"
"용됩니다.  이 드라이버는 [.filename]#GENERIC# 커널에 포함되어 있습니다.  사용"
"자 정의 커널 구성 파일을 사용하는 경우 이 줄이 포함되어 있는지 확인하십시오:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1380
#, no-wrap
msgid "device md\n"
msgstr "device md\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1383
#, no-wrap
msgid "Attaching and Detaching Existing Images"
msgstr "기존 이미지 연결 및 분리하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1389
msgid ""
"To mount an existing file system image, use `mdconfig` to specify the name "
"of the ISO file and a free unit number.  Then, refer to that unit number to "
"mount it on an existing mount point.  Once mounted, the files in the ISO "
"will appear in the mount point.  This example attaches _diskimage.iso_ to "
"the memory device [.filename]#/dev/md0# then mounts that memory device on [."
"filename]#/mnt#:"
msgstr ""
"기존 파일 시스템 이미지를 마운트하려면 `mdconfig` 를 사용하여 ISO 파일의 이름"
"과 사용 가능한 단위 번호를 지정합니다.  그런 다음 해당 단위 번호를 참조하여 "
"기존 마운트 지점에 마운트합니다.  마운트되면 ISO의 파일이 마운트 지점에 나타"
"납니다.  이 예제에서는 메모리 장치 [.filename]#/dev/md0# 에 _diskimage.iso_ "
"를 첨부한 다음 해당 메모리 장치를 [.filename]#/mnt# 에 마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1394
#, no-wrap
msgid ""
"# mdconfig -f diskimage.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"
msgstr ""
"# mdconfig -f diskimage.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1399
msgid ""
"Notice that `-t cd9660` was used to mount an ISO format.  If a unit number "
"is not specified with `-u`, `mdconfig` will automatically allocate an unused "
"memory device and output the name of the allocated unit, such as [."
"filename]#md4#.  Refer to man:mdconfig[8] for more details about this "
"command and its options."
msgstr ""
"ISO 포맷을 마운트하기 위해 `-t cd9660` 이 사용되었음을 알 수 있습니다.  유닛 "
"번호를 `-u` 로 지정하지 않으면 `mdconfig` 는 사용하지 않는 메모리 장치를 자동"
"으로 할당하고 할당된 유닛의 이름(예: [.filename]#md4# )을 출력합니다.  이 명"
"령과 옵션에 대한 자세한 내용은 man:mdconfig[8]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1403
msgid ""
"When a memory disk is no longer in use, its resources should be released "
"back to the system.  First, unmount the file system, then use `mdconfig` to "
"detach the disk from the system and release its resources.  To continue this "
"example:"
msgstr ""
"메모리 디스크를 더 이상 사용하지 않을 때는 해당 리소스를 시스템에 다시 릴리스"
"해야 합니다.  먼저 파일 시스템을 마운트 해제하고 `mdconfig` 를 사용하여 시스"
"템에서 디스크를 분리하고 해당 리소스를 해제합니다.  이 예제를 계속 진행합니"
"다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1408
#, no-wrap
msgid ""
"# umount /mnt\n"
"# mdconfig -d -u 0\n"
msgstr ""
"# umount /mnt\n"
"# mdconfig -d -u 0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1411
msgid ""
"To determine if any memory disks are still attached to the system, type "
"`mdconfig -l`."
msgstr ""
"메모리 디스크가 아직 시스템에 연결되어 있는지 확인하려면 `mdconfig -l` 을 입"
"력합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1413
#, no-wrap
msgid "Creating a File- or Memory-Backed Memory Disk"
msgstr "파일 또는 메모리-백업 메모리 디스크 만들기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1418
msgid ""
"FreeBSD also supports memory disks where the storage to use is allocated "
"from either a hard disk or an area of memory.  The first method is commonly "
"referred to as a file-backed file system and the second method as a memory-"
"backed file system.  Both types can be created using `mdconfig`."
msgstr ""
"FreeBSD는 하드 디스크 또는 메모리 영역에서 사용할 스토리지를 할당하는 메모리 "
"디스크도 지원합니다.  첫 번째 방법을 일반적으로 파일-백업 파일 시스템이라고 "
"하고 두 번째 방법을 메모리-백업 파일 시스템이라고 합니다.  두 가지 유형 모두 "
"`mdconfig` 를 사용하여 만들 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1423
msgid ""
"To create a new memory-backed file system, specify a type of `swap` and the "
"size of the memory disk to create.  Then, format the memory disk with a file "
"system and mount as usual.  This example creates a 5M memory disk on unit "
"`1`.  That memory disk is then formatted with the UFS file system before it "
"is mounted:"
msgstr ""
"새 메모리-백업 파일 시스템을 만들려면 `swap` 유형과 만들 메모리 디스크의 크기"
"를 지정합니다.  그런 다음 메모리 디스크를 파일 시스템으로 포맷하고 평소와 같"
"이 마운트합니다.  이 예에서는 유닛 `1` 에 5M 메모리 디스크를 생성합니다.  그"
"런 다음 해당 메모리 디스크를 UFS 파일 시스템으로 포맷한 후 마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1437
#, no-wrap
msgid ""
"# mdconfig -a -t swap -s 5m -u 1\n"
"# newfs -U md1\n"
"/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.\n"
"        with soft updates\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2752, 5344, 7936\n"
"# mount /dev/md1 /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md1        4718    4  4338     0%    /mnt\n"
msgstr ""
"# mdconfig -a -t swap -s 5m -u 1\n"
"# newfs -U md1\n"
"/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.\n"
"        with soft updates\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2752, 5344, 7936\n"
"# mount /dev/md1 /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md1        4718    4  4338     0%    /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1441
msgid ""
"To create a new file-backed memory disk, first allocate an area of disk to "
"use.  This example creates an empty 5MB file named [.filename]#newimage#:"
msgstr ""
"새 파일-백업 메모리 디스크를 만들려면 먼저 사용할 디스크 영역을 할당합니다.  "
"이 예에서는 [.filename]#newimage# 라는 이름의 빈 5MB 파일을 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1447
#, no-wrap
msgid ""
"# dd if=/dev/zero of=newimage bs=1k count=5k\n"
"5120+0 records in\n"
"5120+0 records out\n"
msgstr ""
"# dd if=/dev/zero of=newimage bs=1k count=5k\n"
"5120+0 records in\n"
"5120+0 records out\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1450
msgid ""
"Next, attach that file to a memory disk, label the memory disk and format it "
"with the UFS file system, mount the memory disk, and verify the size of the "
"file-backed disk:"
msgstr ""
"그런 다음 해당 파일을 메모리 디스크에 첨부하고, 메모리 디스크에 레이블을 지정"
"하고, UFS 파일 시스템으로 포맷한 다음, 메모리 디스크를 마운트하고, 파일 백업 "
"디스크의 크기를 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1464
#, no-wrap
msgid ""
"# mdconfig -f newimage -u 0\n"
"# bsdlabel -w md0 auto\n"
"# newfs -U md0a\n"
"/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2720, 5280, 7840\n"
"# mount /dev/md0a /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md0a       4710    4  4330     0%    /mnt\n"
msgstr ""
"# mdconfig -f newimage -u 0\n"
"# bsdlabel -w md0 auto\n"
"# newfs -U md0a\n"
"/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2720, 5280, 7840\n"
"# mount /dev/md0a /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md0a       4710    4  4330     0%    /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1469
msgid ""
"It takes several commands to create a file- or memory-backed file system "
"using `mdconfig`.  FreeBSD also comes with `mdmfs` which automatically "
"configures a memory disk, formats it with the UFS file system, and mounts "
"it.  For example, after creating _newimage_ with `dd`, this one command is "
"equivalent to running the `bsdlabel`, `newfs`, and `mount` commands shown "
"above:"
msgstr ""
"`mdconfig` 를 사용하여 파일- 또는 메모리-백업 파일 시스템을 만들려면 몇 가지 "
"명령이 필요합니다.  FreeBSD에는 메모리 디스크를 자동으로 구성하고, UFS 파일 "
"시스템으로 포맷한 후 마운트하는 `mdmfs` 도 함께 제공됩니다.  예를 들어, `dd` "
"로 _newimage_ 를 생성한 후 다음 명령 하나로 위에 표시된 `bsdlabel`, `newfs`, "
"`mount` 명령을 실행하는 것과 동일한 결과를 얻을 수 있습니다.:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1473
#, no-wrap
msgid "# mdmfs -F newimage -s 5m md0 /mnt\n"
msgstr "# mdmfs -F newimage -s 5m md0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1476
msgid ""
"To instead create a new memory-based memory disk with `mdmfs`, use this one "
"command:"
msgstr ""
"대신 `mdmfs` 를 사용하여 새 메모리-기반 메모리 디스크를 만들려면 다음 명령어"
"를 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1480
#, no-wrap
msgid "# mdmfs -s 5m md1 /mnt\n"
msgstr "# mdmfs -s 5m md1 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1484
msgid ""
"If the unit number is not specified, `mdmfs` will automatically select an "
"unused memory device.  For more details about `mdmfs`, refer to man:mdmfs[8]."
msgstr ""
"단위 번호를 지정하지 않으면 `mdmfs` 가 사용하지 않는 메모리 장치를 자동으로 "
"선택합니다.  `mdmfs` 에 대한 자세한 내용은 man:mdmfs[8]을 참고하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1486
#, no-wrap
msgid "File System Snapshots"
msgstr "파일 시스템 스냅샷"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1489
msgid ""
"FreeBSD offers a feature in conjunction with crossref:config[soft-updates,"
"Soft Updates]: file system snapshots."
msgstr ""
"FreeBSD는 crossref:config[soft-updates,Soft Updates]와 함께 파일 시스템 스냅"
"샷이라는 기능을 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1491
msgid ""
"UFS snapshots allow a user to create images of specified file systems, and "
"treat them as a file. If you are using the crossref:zfs[,Z file system "
"(ZFS)], refer to crossref:zfs[zfs-zfs-snapshot,\"Managing Snapshots\"] on "
"how to use snapshots."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1496
#, fuzzy
#| msgid ""
#| "UFS snapshots allow a user to create images of specified file systems, "
#| "and treat them as a file.  Snapshot files must be created in the file "
#| "system that the action is performed on, and a user may create no more "
#| "than 20 snapshots per file system.  Active snapshots are recorded in the "
#| "superblock so they are persistent across unmount and remount operations "
#| "along with system reboots.  When a snapshot is no longer required, it can "
#| "be removed using man:rm[1].  While snapshots may be removed in any order, "
#| "all the used space may not be acquired because another snapshot will "
#| "possibly claim some of the released blocks."
msgid ""
"Snapshot files must be created in the file system that the action is "
"performed on, and a user may create no more than 20 snapshots per file "
"system.  Active snapshots are recorded in the superblock so they are "
"persistent across unmount and remount operations along with system reboots.  "
"When a snapshot is no longer required, it can be removed using man:rm[1].  "
"While snapshots may be removed in any order, all the used space may not be "
"acquired because another snapshot will possibly claim some of the released "
"blocks."
msgstr ""
"UFS 스냅샷을 사용하면 지정된 파일 시스템의 이미지를 생성하고 이를 파일로 취급"
"할 수 있습니다.  스냅샷 파일은 작업이 수행되는 파일 시스템에 만들어야 하며, "
"사용자는 파일 시스템당 20개 이하의 스냅샷을 만들 수 있습니다.  활성 스냅샷은 "
"슈퍼블록에 기록되므로 마운트 해제 및 재마운트 작업과 시스템 재부팅 시에도 영"
"구적으로 유지됩니다.  스냅샷이 더 이상 필요하지 않은 경우 man:rm[1]을 사용하"
"여 제거할 수 있습니다.  스냅샷은 어떤 순서로든 제거할 수 있지만, 다른 스냅샷"
"이 해제된 블록 중 일부를 차지할 가능성이 있으므로 사용된 공간을 모두 확보하"
"지 못할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1499
msgid ""
"The un-alterable `snapshot` file flag is set by man:mksnap_ffs[8] after "
"initial creation of a snapshot file.  man:unlink[1] makes an exception for "
"snapshot files since it allows them to be removed."
msgstr ""
"변경할 수 없는 `snapshot` 파일 플래그는 스냅샷 파일을 처음 생성한 후 man:"
"mksnap_ffs[8]에 의해 설정됩니다.  man:unlink[1]는 스냅샷 파일을 제거할 수 있"
"으므로 스냅샷 파일에 대해 예외를 만듭니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1502
msgid ""
"Snapshots are created using man:mount[8].  To place a snapshot of [."
"filename]#/var# in the file [.filename]#/var/snapshot/snap#, use the "
"following command:"
msgstr ""
"스냅샷은 man:mount[8]를 사용하여 만듭니다.  [.filename]#/var# 파일에 [."
"filename]#/var/snapshot/snap# 의 스냅샷을 배치하려면 다음 명령을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1506
#, no-wrap
msgid "# mount -u -o snapshot /var/snapshot/snap /var\n"
msgstr "# mount -u -o snapshot /var/snapshot/snap /var\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1509
msgid "Alternatively, use man:mksnap_ffs[8] to create the snapshot:"
msgstr "또는 man:mksnap_ffs[8]을 사용하여 스냅샷을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1513
#, no-wrap
msgid "# mksnap_ffs /var /var/snapshot/snap\n"
msgstr "# mksnap_ffs /var /var/snapshot/snap\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1516
msgid ""
"One can find snapshot files on a file system, such as [.filename]#/var#, "
"using man:find[1]:"
msgstr ""
"man:find[1]를 사용하여 [.filename]#/var# 과 같은 파일 시스템에서 스냅샷 파일"
"을 찾을 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1520
#, no-wrap
msgid "# find /var -flags snapshot\n"
msgstr "# find /var -flags snapshot\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1523
msgid "Once a snapshot has been created, it has several uses:"
msgstr "스냅샷이 생성되면 여러가지 용도로 사용할 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1525
msgid ""
"Some administrators will use a snapshot file for backup purposes, because "
"the snapshot can be transferred to CDs or tape."
msgstr ""
"일부 관리자는 스냅샷을 CD나 테이프로 전송할 수 있기 때문에 백업 목적으로 스냅"
"샷 파일을 사용하기도 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1526
msgid ""
"The file system integrity checker, man:fsck[8], may be run on the snapshot. "
"Assuming that the file system was clean when it was mounted, this should "
"always provide a clean and unchanging result."
msgstr ""
"파일 시스템 무결성 검사기인 man:fsck[8]를 스냅샷에서 실행할 수 있습니다. 파"
"일 시스템이 마운트될 때 깨끗한 상태였다고 가정하면 항상 깨끗하고 변경되지 않"
"은 결과를 제공해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1527
msgid ""
"Running man:dump[8] on the snapshot will produce a dump file that is "
"consistent with the file system and the timestamp of the snapshot. man:"
"dump[8] can also take a snapshot, create a dump image, and then remove the "
"snapshot in one command by using `-L`."
msgstr ""
"man:dump[8]를 스냅샷에 실행하면 파일 시스템 및 스냅샷의 타임스탬프와 일치하"
"는 덤프 파일이 생성됩니다. 또한 `-L` 을 사용하여 하나의 명령으로 스냅샷을 생"
"성하고 덤프 이미지를 생성한 다음 스냅샷을 제거할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1528
msgid ""
"The snapshot can be mounted as a frozen image of the file system. To man:"
"mount[8] the snapshot [.filename]#/var/snapshot/snap# run:"
msgstr ""
"스냅샷은 파일 시스템의 고정 이미지로 마운트할 수 있습니다. man:mount[8]으로 "
"스냅샷 [.filename]#/var/snapshot/snap# 을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1533
#, no-wrap
msgid ""
"# mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4\n"
"# mount -r /dev/md4 /mnt\n"
msgstr ""
"# mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4\n"
"# mount -r /dev/md4 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1539
msgid ""
"The frozen [.filename]#/var# is now available through [.filename]#/mnt#.  "
"Everything will initially be in the same state it was during the snapshot "
"creation time.  The only exception is that any earlier snapshots will appear "
"as zero length files.  To unmount the snapshot, use:"
msgstr ""
"고정된 [.filename]#/var# 는 이제 [.filename]#/mnt# 을 통해 사용할 수 있습니"
"다.  처음에는 모든 것이 스냅샷 생성 시와 동일한 상태로 유지됩니다.  유일한 예"
"외는 이전 스냅샷이 길이가 0인 파일로 표시된다는 점입니다.  스냅샷을 마운트 해"
"제하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1544
#, no-wrap
msgid ""
"# umount /mnt\n"
"# mdconfig -d -u 4\n"
msgstr ""
"# umount /mnt\n"
"# mdconfig -d -u 4\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1547
msgid ""
"For more information about `softupdates` and file system snapshots, "
"including technical papers, visit Marshall Kirk McKusick's website at http://"
"www.mckusick.com/[http://www.mckusick.com/]."
msgstr ""
"기술 문서를 포함하여 `softupdates` 및 파일 시스템 스냅샷에 대한 자세한 내용"
"은 Marshall Kirk McKusick의 웹사이트(http://www.mckusick.com/[http://www."
"mckusick.com/]를 참조하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1549
#, no-wrap
msgid "Disk Quotas"
msgstr "디스크 할당량"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1553
msgid ""
"Disk quotas can be used to limit the amount of disk space or the number of "
"files a user or members of a group may allocate on a per-file system basis.  "
"This prevents one user or group of users from consuming all of the available "
"disk space."
msgstr ""
"디스크 할당량을 사용하여 사용자 또는 그룹 구성원이 파일 시스템별로 할당할 수 "
"있는 디스크 공간의 양이나 파일 수를 제한할 수 있습니다.  이렇게 하면 한 사용"
"자 또는 사용자 그룹이 사용 가능한 디스크 공간을 모두 소비하는 것을 방지할 수 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1556
msgid ""
"This section describes how to configure disk quotas for the UFS file "
"system.  To configure quotas on the ZFS file system, refer to crossref:"
"zfs[zfs-zfs-quota,\"Dataset, User, and Group Quotas\"]"
msgstr ""
"이 섹션에서는 UFS 파일 시스템에 대한 디스크 할당량을 구성하는 방법에 대해 설"
"명합니다.  ZFS 파일 시스템에서 할당량을 구성하려면 crossref:zfs[zfs-zfs-"
"quota,\"Dataset, User, and Group Quotas\"]을 참조하세요"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1557
#, no-wrap
msgid "Enabling Disk Quotas"
msgstr "디스크 할당량 활성화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1560
msgid "To determine if the FreeBSD kernel provides support for disk quotas:"
msgstr "FreeBSD 커널이 디스크 할당량을 지원하는지 확인하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1565
#, no-wrap
msgid ""
"% sysctl kern.features.ufs_quota\n"
"kern.features.ufs_quota: 1\n"
msgstr ""
"% sysctl kern.features.ufs_quota\n"
"kern.features.ufs_quota: 1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1569
msgid ""
"In this example, the `1` indicates quota support.  If the value is instead "
"`0`, add the following line to a custom kernel configuration file and "
"rebuild the kernel using the instructions in crossref:"
"kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]:"
msgstr ""
"이 예에서 `1` 은 할당량 지원을 나타냅니다.  값이 대신 `0` 이면 커스텀 커널 구"
"성 파일에 다음 줄을 추가하고 crossref:kernelconfig[kernelconfig,Configuring "
"the FreeBSD Kernel]의 지침을 사용하여 커널을 다시 빌드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1573
#, no-wrap
msgid "options QUOTA\n"
msgstr "options QUOTA\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1576
msgid "Next, enable disk quotas in [.filename]#/etc/rc.conf#:"
msgstr "다음으로, [.filename]#/etc/rc.conf# 에서 디스크 할당량을 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1580
#, no-wrap
msgid "quota_enable=\"YES\"\n"
msgstr "quota_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1586
msgid ""
"Normally on bootup, the quota integrity of each file system is checked by "
"man:quotacheck[8].  This program insures that the data in the quota database "
"properly reflects the data on the file system.  This is a time consuming "
"process that will significantly affect the time the system takes to boot.  "
"To skip this step, add this variable to [.filename]#/etc/rc.conf#:"
msgstr ""
"일반적으로 부팅 시 각 파일 시스템의 할당량 무결성은 man:quotacheck[8]에 의해 "
"확인됩니다.  이 프로그램은 할당량 데이터베이스의 데이터가 파일 시스템의 데이"
"터를 올바르게 반영하는지 확인합니다.  이 과정은 시간이 오래 걸리므로 시스템 "
"부팅에 상당한 영향을 미칩니다.  이 단계를 건너뛰려면 [.filename]#/etc/rc.con "
"f#에 다음 변수를 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1590
#, no-wrap
msgid "check_quotas=\"NO\"\n"
msgstr "check_quotas=\"NO\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1595
msgid ""
"Finally, edit [.filename]#/etc/fstab# to enable disk quotas on a per-file "
"system basis.  To enable per-user quotas on a file system, add `userquota` "
"to the options field in the [.filename]#/etc/fstab# entry for the file "
"system to enable quotas on.  For example:"
msgstr ""
"마지막으로 [.filename]#/etc/fstab# 을 편집하여 파일 시스템 단위로 디스크 할당"
"량을 사용하도록 설정합니다.  파일 시스템에서 사용자별 할당량을 설정하려면 할"
"당량을 사용 설정할 파일 시스템의 [.filename]#/etc/fstab# 항목에 있는 옵션 필"
"드에 `userquota` 를 추가합니다.  예를 들어:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1599
#, no-wrap
msgid "/dev/da1s2g   /home    ufs rw,userquota 1 2\n"
msgstr "/dev/da1s2g   /home    ufs rw,userquota 1 2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1603
msgid ""
"To enable group quotas, use `groupquota` instead.  To enable both user and "
"group quotas, separate the options with a comma:"
msgstr ""
"그룹 할당량을 사용하려면 대신 `groupquota` 를 사용합니다.  사용자 할당량과 그"
"룹 할당량을 모두 사용하려면 쉼표로 옵션을 구분합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1607
#, no-wrap
msgid "/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2\n"
msgstr "/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1612
msgid ""
"By default, quota files are stored in the root directory of the file system "
"as [.filename]#quota.user# and [.filename]#quota.group#.  Refer to man:"
"fstab[5] for more information.  Specifying an alternate location for the "
"quota files is not recommended."
msgstr ""
"기본적으로 할당량 파일은 파일 시스템의 루트 디렉터리에 [.filename]#quota."
"user# 및 [.filename]#quota.group# 으로 저장됩니다.  자세한 내용은 man:"
"fstab[5]을 참조하세요.  할당량 파일의 대체 위치를 지정하는 것은 권장하지 않습"
"니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1614
msgid ""
"Once the configuration is complete, reboot the system and [.filename]#/etc/"
"rc# will automatically run the appropriate commands to create the initial "
"quota files for all of the quotas enabled in [.filename]#/etc/fstab#."
msgstr ""
"구성을 완료하고 시스템을 재부팅하면 [.filename]#/etc/rc# 가 자동으로 적절한 "
"명령을 실행하여 [.filename]#/etc/fstab# 에서 활성화된 모든 할당량에 대한 초"
"기 할당량 파일을 생성합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1617
msgid ""
"In the normal course of operations, there should be no need to manually run "
"man:quotacheck[8], man:quotaon[8], or man:quotaoff[8].  However, one should "
"read these manual pages to be familiar with their operation."
msgstr ""
"일반적인 작업 과정에서는 man:quotacheck[8], man:quotaon[8] 또는 man:"
"quotaoff[8]를 수동으로 실행할 필요가 없습니다.  그러나 설명서 페이지를 읽고 "
"작동법을 숙지해야 합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1618
#, no-wrap
msgid "Setting Quota Limits"
msgstr "할당량 한도 설정하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1621
msgid "To verify that quotas are enabled, run:"
msgstr "할당량이 활성화되어 있는지 확인하려면 다음을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1625
#, no-wrap
msgid "# quota -v\n"
msgstr "# quota -v\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1628
msgid ""
"There should be a one line summary of disk usage and current quota limits "
"for each file system that quotas are enabled on."
msgstr ""
"할당량이 활성화된 각 파일 시스템에 대해 디스크 사용량과 현재 할당량 제한에 대"
"한 한 줄 요약이 있어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1630
msgid "The system is now ready to be assigned quota limits with `edquota`."
msgstr ""
"이제 시스템에 `edquota` 을 사용하여 할당량 한도를 지정할 준비가 되었습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1634
msgid ""
"Several options are available to enforce limits on the amount of disk space "
"a user or group may allocate, and how many files they may create.  "
"Allocations can be limited based on disk space (block quotas), number of "
"files (inode quotas), or a combination of both.  Each limit is further "
"broken down into two categories: hard and soft limits."
msgstr ""
"사용자 또는 그룹이 할당할 수 있는 디스크 공간의 양과 생성할 수 있는 파일 수"
"에 제한을 적용하는 데는 여러 가지 옵션이 있습니다.  디스크 공간(블록 할당"
"량), 파일 수(이노드 할당량) 또는 이 두 가지의 조합을 기준으로 할당을 제한할 "
"수 있습니다.  각 제한은 하드 제한과 소프트 제한의 두 가지 범주로 더 세분화됩"
"니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1639
msgid ""
"A hard limit may not be exceeded.  Once a user reaches a hard limit, no "
"further allocations can be made on that file system by that user.  For "
"example, if the user has a hard limit of 500 kbytes on a file system and is "
"currently using 490 kbytes, the user can only allocate an additional 10 "
"kbytes.  Attempting to allocate an additional 11 kbytes will fail."
msgstr ""
"하드 제한은 초과할 수 없습니다.  사용자가 하드 제한에 도달하면 해당 사용자는 "
"해당 파일 시스템에 더 이상 할당할 수 없습니다.  예를 들어, 사용자가 파일 시스"
"템의 하드 제한이 500KB이고 현재 490KB를 사용 중인 경우, 사용자는 추가로 10KB"
"만 할당할 수 있습니다.  추가로 11바이트를 할당하려고 시도하면 실패합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1643
msgid ""
"Soft limits can be exceeded for a limited amount of time, known as the grace "
"period, which is one week by default.  If a user stays over their limit "
"longer than the grace period, the soft limit turns into a hard limit and no "
"further allocations are allowed.  When the user drops back below the soft "
"limit, the grace period is reset."
msgstr ""
"소프트 제한은 유예 기간이라고 하는 제한된 시간 동안 초과할 수 있으며, 이 기간"
"은 기본적으로 1주일입니다.  사용자가 유예 기간보다 더 오래 한도를 초과하면 소"
"프트 제한이 하드 제한으로 바뀌고 더 이상 할당이 허용되지 않습니다.  사용자가 "
"소프트 제한 아래로 다시 떨어지면 유예 기간이 초기화됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1647
msgid ""
"In the following example, the quota for the `test` account is being edited.  "
"When `edquota` is invoked, the editor specified by `EDITOR` is opened in "
"order to edit the quota limits.  The default editor is set to vi."
msgstr ""
"다음 예에서는 `test` 계정의 할당량을 편집하고 있습니다.  `edquota` 가 호출되"
"면 할당량 한도를 편집하기 위해 `EDITOR` 로 지정된 편집기가 열립니다.  기본 편"
"집기는 vi로 설정되어 있습니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1656
#, no-wrap
msgid ""
"# edquota -u test\n"
"Quotas for user test:\n"
"/usr: kbytes in use: 65, limits (soft = 50, hard = 75)\n"
"        inodes in use: 7, limits (soft = 50, hard = 60)\n"
"/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)\n"
"        inodes in use: 0, limits (soft = 50, hard = 60)\n"
msgstr ""
"# edquota -u test\n"
"Quotas for user test:\n"
"/usr: kbytes in use: 65, limits (soft = 50, hard = 75)\n"
"        inodes in use: 7, limits (soft = 50, hard = 60)\n"
"/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)\n"
"        inodes in use: 0, limits (soft = 50, hard = 60)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1662
msgid ""
"There are normally two lines for each file system that has quotas enabled.  "
"One line represents the block limits and the other represents the inode "
"limits.  Change the value to modify the quota limit.  For example, to raise "
"the block limit on [.filename]#/usr# to a soft limit of `500` and a hard "
"limit of `600`, change the values in that line as follows:"
msgstr ""
"할당량이 활성화된 각 파일 시스템에는 일반적으로 두 줄이 표시됩니다.  한 줄은 "
"블록 제한을 나타내고 다른 줄은 이노드 제한을 나타냅니다.  할당량 제한을 수정"
"하려면 값을 변경합니다.  예를 들어 [.filename]#/usr# 의 블록 제한을 소프트 제"
"한 `500` 과 하드 제한 `600` 으로 높이려면 해당 줄의 값을 다음과 같이 변경합니"
"다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1666
#, no-wrap
msgid "/usr: kbytes in use: 65, limits (soft = 500, hard = 600)\n"
msgstr "/usr: kbytes in use: 65, limits (soft = 500, hard = 600)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1669
msgid "The new quota limits take effect upon exiting the editor."
msgstr "새로운 할당량 제한은 편집기를 종료할 때 적용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1674
msgid ""
"Sometimes it is desirable to set quota limits on a range of users.  This can "
"be done by first assigning the desired quota limit to a user.  Then, use `-"
"p` to duplicate that quota to a specified range of user IDs (UIDs).  The "
"following command will duplicate those quota limits for UIDs `10,000` "
"through `19,999`:"
msgstr ""
"여러 사용자에 대해 할당량 제한을 설정하는 것이 바람직한 경우도 있습니다.  먼"
"저 원하는 할당량 제한을 사용자에게 할당하기 위해 이 작업을 수행할 수 있습니"
"다.  그런 다음 `-p` 를 사용하여 해당 할당량을 지정된 범위의 사용자 ID(UID)에 "
"복제합니다.  다음 명령은 UID `10,000` 부터 `19,999` 까지 해당 할당량 제한을 "
"복제합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1678
#, no-wrap
msgid "# edquota -p test 10000-19999\n"
msgstr "# edquota -p test 10000-19999\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1681
msgid "For more information, refer to man:edquota[8]."
msgstr "자세한 내용은 man:edquota[8]를 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1682
#, no-wrap
msgid "Checking Quota Limits and Disk Usage"
msgstr "할당량 제한 및 디스크 사용량 확인하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1688
msgid ""
"To check individual user or group quotas and disk usage, use man:quota[1].  "
"A user may only examine their own quota and the quota of a group they are a "
"member of.  Only the superuser may view all user and group quotas.  To get a "
"summary of all quotas and disk usage for file systems with quotas enabled, "
"use man:repquota[8]."
msgstr ""
"개별 사용자 또는 그룹 할당량과 디스크 사용량을 확인하려면 man:quota[1]를 사용"
"하세요.  사용자는 자신의 할당량과 자신이 속한 그룹의 할당량만 확인할 수 있습"
"니다.  수퍼유저만 모든 사용자 및 그룹 할당량을 볼 수 있습니다.  할당량이 활성"
"화된 파일 시스템에 대한 모든 할당량 및 디스크 사용량 요약을 보려면 man:"
"repquota[8]를 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1692
msgid ""
"Normally, file systems that the user is not using any disk space on will not "
"show in the output of `quota`, even if the user has a quota limit assigned "
"for that file system.  Use `-v` to display those file systems.  The "
"following is sample output from `quota -v` for a user that has quota limits "
"on two file systems."
msgstr ""
"일반적으로 사용자가 디스크 공간을 사용하지 않은 파일 시스템은, 사용자가 해당 "
"파일 시스템에 할당된 할당량 제한이 있더라도 `quota`  출력에 표시되지 않습니"
"다.  이러한 파일 시스템을 표시하려면 `-v` 를 사용하십시오.  다음은 두 파일 시"
"스템에 할당량 제한이 있는 사용자에 대해 `quota -v` 의 샘플 출력입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1699
#, no-wrap
msgid ""
"Disk quotas for user test (uid 1002):\n"
"     Filesystem  usage    quota   limit   grace   files   quota   limit   grace\n"
"           /usr      65*     50      75   5days       7      50      60\n"
"       /usr/var       0      50      75               0      50      60\n"
msgstr ""
"Disk quotas for user test (uid 1002):\n"
"     Filesystem  usage    quota   limit   grace   files   quota   limit   grace\n"
"           /usr      65*     50      75   5days       7      50      60\n"
"       /usr/var       0      50      75               0      50      60\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1703
msgid ""
"In this example, the user is currently 15 kbytes over the soft limit of 50 "
"kbytes on [.filename]#/usr# and has 5 days of grace period left.  The "
"asterisk `*` indicates that the user is currently over the quota limit."
msgstr ""
"이 예에서는 사용자가 현재 [.filename]#/usr# 에서 소프트 한도인 50KB를 15KB 초"
"과하고 있으며 유예 기간이 5일 남았습니다.  별표 `*` 는 사용자가 현재 할당량 "
"제한을 초과했음을 나타냅니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1704
#, no-wrap
msgid "Quotas over NFS"
msgstr "NFS를 통한 할당량"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1708
msgid ""
"Quotas are enforced by the quota subsystem on the NFS server.  The man:rpc."
"rquotad[8] daemon makes quota information available to `quota` on NFS "
"clients, allowing users on those machines to see their quota statistics."
msgstr ""
"할당량은 NFS 서버의 할당량 하위 시스템에 의해 적용됩니다.  man:rpc."
"rquotad[8] 데몬은 NFS 클라이언트의 `quota` 가 할당량 정보를 사용할 수 있도록 "
"하여 해당 시스템의 사용자가 할당량 통계를 볼 수 있도록 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1710
msgid ""
"On the NFS server, enable `rpc.rquotad` by removing the `+#+` from this line "
"in [.filename]*/etc/inetd.conf*:"
msgstr ""
"NFS 서버에서 [.filename]*/etc/inetd.conf* 의 줄에서 `+#+` 를 제거하여 `rpc."
"rquotad` 를 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1714
#, no-wrap
msgid "rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad\n"
msgstr "rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1717
msgid "Then, restart `inetd`:"
msgstr "그런 다음 `inetd` 를 다시 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1721
#, no-wrap
msgid "# service inetd restart\n"
msgstr "# service inetd restart\n"

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1724
#, no-wrap
msgid "Encrypting Disk Partitions"
msgstr "디스크 파티션 암호화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1729
msgid ""
"FreeBSD offers excellent online protections against unauthorized data "
"access.  File permissions and crossref:mac[mac,Mandatory Access Control] "
"(MAC) help prevent unauthorized users from accessing data while the "
"operating system is active and the computer is powered up.  However, the "
"permissions enforced by the operating system are irrelevant if an attacker "
"has physical access to a computer and can move the computer's hard drive to "
"another system to copy and analyze the data."
msgstr ""
"FreeBSD는 무단 데이터 액세스에 대한 탁월한 온라인 보호 기능을 제공합니다.  파"
"일 권한과 crossref:mac[mac,Mandatory Access Control](MAC)은 운영 체제가 활성"
"화되고 컴퓨터 전원이 켜져 있는 동안 권한이 없는 사용자가 데이터에 액세스하는 "
"것을 방지합니다.  그러나 공격자가 컴퓨터에 물리적으로 액세스할 수 있고 컴퓨터"
"의 하드 드라이브를 다른 시스템으로 이동하여 데이터를 복사하고 분석할 수 있는 "
"경우 운영 체제에서 시행하는 권한은 무의미합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1733
msgid ""
"Regardless of how an attacker may have come into possession of a hard drive "
"or powered-down computer, the GEOM-based cryptographic subsystems built into "
"FreeBSD are able to protect the data on the computer's file systems against "
"even highly-motivated attackers with significant resources.  Unlike "
"encryption methods that encrypt individual files, the built-in `gbde` and "
"`geli` utilities can be used to transparently encrypt entire file systems.  "
"No cleartext ever touches the hard drive's platter."
msgstr ""
"공격자가 하드 드라이브나 전원이 꺼진 컴퓨터를 어떻게 점유했는지에 상관없이, "
"FreeBSD에 내장된 GEOM 기반 암호화 서브 시스템은 상당한 자원을 가진 강력한 공"
"격자로부터 컴퓨터의 파일 시스템에 있는 데이터를 보호할 수 있습니다.  개별 파"
"일을 암호화하는 암호화 방법과 달리, 내장된 `gbde` 및 `geli` 유틸리티를 사용하"
"여 전체 파일 시스템을 투명하게 암호화할 수 있습니다.  클리어 텍스트는 하드 드"
"라이브의 플래터에 절대 닿지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1736
msgid ""
"This chapter demonstrates how to create an encrypted file system on "
"FreeBSD.  It first demonstrates the process using `gbde` and then "
"demonstrates the same example using `geli`."
msgstr ""
"이 장에서는 FreeBSD에서 암호화된 파일 시스템을 만드는 방법을 설명합니다.  먼"
"저 `gbde` 를 사용하여 프로세스를 보여준 다음 `geli` 를 사용하여 동일한 예제"
"를 보여줍니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1737
#, no-wrap
msgid "Disk Encryption with gbde"
msgstr "gbde를 사용한 디스크 암호화"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1742
msgid ""
"The objective of the man:gbde[4] facility is to provide a formidable "
"challenge for an attacker to gain access to the contents of a _cold_ storage "
"device.  However, if the computer is compromised while up and running and "
"the storage device is actively attached, or the attacker has access to a "
"valid passphrase, it offers no protection to the contents of the storage "
"device.  Thus, it is important to provide physical security while the system "
"is running and to protect the passphrase used by the encryption mechanism."
msgstr ""
"man:gbde[4] 기능의 목적은 공격자가 _콜드_ 저장 장치의 콘텐츠에 액세스하는 것"
"을 어렵게 만드는 것입니다.  그러나 컴퓨터가 실행 중이고 저장 장치가 활성 상태"
"로 연결되어 있거나 공격자가 유효한 암호에 액세스할 수 있는 경우 저장 장치의 "
"콘텐츠에 대한 보호 기능을 제공하지 않습니다.  따라서 시스템이 실행되는 동안 "
"물리적 보안을 제공하고 암호화 메커니즘에서 사용하는 암호 구문을 보호하는 것"
"이 중요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1747
msgid ""
"This facility provides several barriers to protect the data stored in each "
"disk sector.  It encrypts the contents of a disk sector using 128-bit AES in "
"CBC mode.  Each sector on the disk is encrypted with a different AES key.  "
"For more information on the cryptographic design, including how the sector "
"keys are derived from the user-supplied passphrase, refer to man:gbde[4]."
msgstr ""
"이 기능은 각 디스크 섹터에 저장된 데이터를 보호하기 위해 몇 가지 배리어를 제"
"공합니다.  CBC 모드에서 128비트 AES를 사용하여 디스크 섹터의 내용을 암호화합"
"니다.  디스크의 각 섹터는 서로 다른 AES 키로 암호화됩니다.  사용자가 제공한 "
"암호문에서 섹터 키가 파생되는 방법을 포함하여 암호화 설계에 대한 자세한 내용"
"은 man:gbde[4]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1749
msgid ""
"FreeBSD provides a kernel module for gbde which can be loaded with this "
"command:"
msgstr "FreeBSD는 이 명령으로 로드할 수 있는 gbde용 커널 모듈을 제공합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1753
#, no-wrap
msgid "# kldload geom_bde\n"
msgstr "# kldload geom_bde\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1756
msgid ""
"If using a custom kernel configuration file, ensure it contains this line:"
msgstr ""
"사용자 정의 커널 구성 파일을 사용하는 경우 다음 내용이 포함되어 있는지 확인하"
"세요:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1758
msgid "`options GEOM_BDE`"
msgstr "`options GEOM_BDE`"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1760
msgid ""
"The following example demonstrates adding a new hard drive to a system that "
"will hold a single encrypted partition that will be mounted as [.filename]#/"
"private#."
msgstr ""
"다음 예제에서는 [.filename]#/private# 으로 마운트할 단일 암호화된 파티션을 보"
"관할 새 하드 드라이브를 시스템에 추가하는 방법을 보여 줍니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1762
#, no-wrap
msgid "Procedure: Encrypting a Partition with gbde"
msgstr "절차: gbde로 파티션 암호화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1764
msgid "Add the New Hard Drive"
msgstr "새 하드 드라이브 추가"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1767
#, fuzzy
#| msgid ""
#| "Install the new drive to the system as explained in <<disks-adding>>.  "
#| "For the purposes of this example, a new hard drive partition has been "
#| "added as [.filename]#/dev/ad4s1c# and [.filename]#/dev/ad0s1*# represents "
#| "the existing standard FreeBSD partitions."
msgid ""
"Install the new drive to the system as explained in crossref:disks[disks-"
"adding, Adding Disks].  For the purposes of this example, a new hard drive "
"partition has been added as [.filename]#/dev/ad4s1c# and [.filename]#/dev/"
"ad0s1*# represents the existing standard FreeBSD partitions."
msgstr ""
"<<disks-adding>> 에 설명된 대로 시스템에 새 드라이브를 설치합니다.  이 예제에"
"서는 [.filename]#/dev/ad4s1c# 로 새 하드 드라이브 파티션이 추가되었으며 [."
"filename]#/dev/ad0s1*# 은 기존 표준 FreeBSD 파티션을 나타냅니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1774
#, no-wrap
msgid ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4\n"
msgstr ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1777
msgid "Create a Directory to Hold `gbde` Lock Files"
msgstr "`gbde` 잠금 파일을 보관할 디렉터리 생성"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1781
#, no-wrap
msgid "# mkdir /etc/gbde\n"
msgstr "# mkdir /etc/gbde\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1786
msgid ""
"The gbde lock file contains information that gbde requires to access "
"encrypted partitions.  Without access to the lock file, gbde will not be "
"able to decrypt the data contained in the encrypted partition without "
"significant manual intervention which is not supported by the software.  "
"Each encrypted partition uses a separate lock file."
msgstr ""
"gbde 잠금 파일에는 gbde가 암호화된 파티션에 액세스하는 데 필요한 정보가 포함"
"되어 있습니다.  잠금 파일에 액세스할 수 없으면 소프트웨어에서 지원하지 않는 "
"상당한 수동 개입 없이는 암호화된 파티션에 포함된 데이터의 암호를 해독할 수 없"
"습니다.  암호화된 각 파티션은 별도의 잠금 파일을 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1787
msgid "Initialize the `gbde` Partition"
msgstr "`gbde` 파티션 초기화"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1792
msgid ""
"A gbde partition must be initialized before it can be used.  This "
"initialization needs to be performed only once.  This command will open the "
"default editor, in order to set various configuration options in a "
"template.  For use with the UFS file system, set the sector_size to 2048:"
msgstr ""
"gbde 파티션을 사용하려면 먼저 초기화해야 합니다.  이 초기화는 한 번만 수행하"
"면 됩니다.  템플릿에서 다양한 구성 옵션을 설정하기 위해 기본 편집기를 엽니"
"다.  UFS 파일 시스템과 함께 사용하려면 sector_size를 2048로 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1804
#, fuzzy, no-wrap
#| msgid ""
#| "# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock\n"
#| "# $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $\n"
#| "#\n"
#| "# Sector size is the smallest unit of data which can be read or written.\n"
#| "# Making it too small decreases performance and decreases available space.\n"
#| "# Making it too large may prevent filesystems from working.  512 is the\n"
#| "# minimum and always safe.  For UFS, use the fragment size\n"
#| "#\n"
#| "sector_size\t=\t2048\n"
#| "[...]\n"
msgid ""
"# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock\n"
"#\n"
"# Sector size is the smallest unit of data which can be read or written.\n"
"# Making it too small decreases performance and decreases available space.\n"
"# Making it too large may prevent filesystems from working.  512 is the\n"
"# minimum and always safe.  For UFS, use the fragment size\n"
"#\n"
"sector_size\t=\t2048\n"
"[...]\n"
msgstr ""
"# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock\n"
"# $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $\n"
"#\n"
"# Sector size is the smallest unit of data which can be read or written.\n"
"# Making it too small decreases performance and decreases available space.\n"
"# Making it too large may prevent filesystems from working.  512 is the\n"
"# minimum and always safe.  For UFS, use the fragment size\n"
"#\n"
"sector_size\t=\t2048\n"
"[...]\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1810
msgid ""
"Once the edit is saved, the user will be asked twice to type the passphrase "
"used to secure the data.  The passphrase must be the same both times.  The "
"ability of gbde to protect data depends entirely on the quality of the "
"passphrase.  For tips on how to select a secure passphrase that is easy to "
"remember, see http://world.std.com/\\~reinhold/diceware.html[http://world."
"std.com/~reinhold/diceware.htm]."
msgstr ""
"편집 내용이 저장되면 데이터 보안에 사용되는 비밀번호를 입력하라는 메시지가 "
"두 번 표시됩니다.  암호는 두 번 모두 동일해야 합니다.  데이터를 보호하는 gbde"
"의 기능은 전적으로 암호의 품질에 달려 있습니다.  기억하기 쉬운 보안 암호를 선"
"택하는 방법에 대한 팁은 http://world.std.com/\\~reinhold/diceware."
"html[http://world.std.com/~reinhold/diceware.htm]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1814
msgid ""
"This initialization creates a lock file for the gbde partition.  In this "
"example, it is stored as [.filename]#/etc/gbde/ad4s1c.lock#.  Lock files "
"must end in \".lock\" in order to be correctly detected by the [.filename]#/"
"etc/rc.d/gbde# start up script."
msgstr ""
"이 초기화는 gbde 파티션에 대한 잠금 파일을 생성합니다.  이 예제에서는 [."
"filename]#/etc/gbde/ad4s1c.lock# 으로 저장됩니다.  잠금 파일은 \".lock\"으로 "
"끝나야 [.filename]#/etc/rc.d/gbde# 시작 스크립트에서 올바르게 감지할 수 있습"
"니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1819
msgid ""
"Lock files _must_ be backed up together with the contents of any encrypted "
"partitions.  Without the lock file, the legitimate owner will be unable to "
"access the data on the encrypted partition."
msgstr ""
"잠금 파일은 암호화된 파티션의 콘텐츠와 함께 _반드시_ 백업해야 합니다.  잠금 "
"파일이 없으면 정당한 소유자도 암호화된 파티션의 데이터에 액세스할 수 없습니"
"다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1822
msgid "Attach the Encrypted Partition to the Kernel"
msgstr "암호화된 파티션을 커널에 연결"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1826
#, no-wrap
msgid "# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock\n"
msgstr "# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1830
msgid ""
"This command will prompt to input the passphrase that was selected during "
"the initialization of the encrypted partition.  The new encrypted device "
"will appear in [.filename]#/dev# as [.filename]#/dev/device_name.bde#:"
msgstr ""
"이 명령은 암호화된 파티션을 초기화할 때 선택한 암호를 입력하라는 메시지를 표"
"시합니다.  암호화된 새 장치가 [.filename]#/dev# 에 [.filename]#/dev/"
"device_name.bde# 로 표시됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1837
#, no-wrap
msgid ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde\n"
msgstr ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1840
msgid "Create a File System on the Encrypted Device"
msgstr "암호화된 장치에 파일 시스템 생성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1844
msgid ""
"Once the encrypted device has been attached to the kernel, a file system can "
"be created on the device.  This example creates a UFS file system with soft "
"updates enabled.  Be sure to specify the partition which has a [.filename]#*."
"bde# extension:"
msgstr ""
"암호화된 디바이스가 커널에 연결되면 디바이스에 파일 시스템을 만들 수 있습니"
"다.  이 예에서는 소프트 업데이트가 활성화된 UFS 파일 시스템을 생성합니다.  확"
"장자가 [.filename]#*.bde# 인 파티션을 지정해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1848
#, no-wrap
msgid "# newfs -U /dev/ad4s1c.bde\n"
msgstr "# newfs -U /dev/ad4s1c.bde\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1851
msgid "Mount the Encrypted Partition"
msgstr "암호화된 파티션 마운트"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1853
msgid "Create a mount point and mount the encrypted file system:"
msgstr "마운트 지점을 생성하고 암호화된 파일 시스템을 마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1858
#, no-wrap
msgid ""
"# mkdir /private\n"
"# mount /dev/ad4s1c.bde /private\n"
msgstr ""
"# mkdir /private\n"
"# mount /dev/ad4s1c.bde /private\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1861
msgid "Verify That the Encrypted File System is Available"
msgstr "암호화된 파일 시스템을 사용할 수 있는지 확인"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1863
msgid "The encrypted file system should now be visible and available for use:"
msgstr "이제 암호화된 파일 시스템이 표시되고 사용할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1874
#, no-wrap
msgid ""
"% df -H\n"
"Filesystem        Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a      1037M    72M   883M     8%    /\n"
"/devfs            1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f       8.1G    55K   7.5G     0%    /home\n"
"/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp\n"
"/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr\n"
"/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private\n"
msgstr ""
"% df -H\n"
"Filesystem        Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a      1037M    72M   883M     8%    /\n"
"/devfs            1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f       8.1G    55K   7.5G     0%    /home\n"
"/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp\n"
"/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr\n"
"/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1878
msgid ""
"After each boot, any encrypted file systems must be manually re-attached to "
"the kernel, checked for errors, and mounted, before the file systems can be "
"used.  To configure these steps, add the following lines to [.filename]#/etc/"
"rc.conf#:"
msgstr ""
"부팅할 때마다 암호화된 파일 시스템을 커널에 수동으로 다시 연결하고 오류를 확"
"인한 후 마운트해야 파일 시스템을 사용할 수 있습니다.  이러한 단계를 구성하려"
"면 [.filename]#/etc/rc.conf# 에 다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1884
#, no-wrap
msgid ""
"gbde_autoattach_all=\"YES\"\n"
"gbde_devices=\"ad4s1c\"\n"
"gbde_lockdir=\"/etc/gbde\"\n"
msgstr ""
"gbde_autoattach_all=\"YES\"\n"
"gbde_devices=\"ad4s1c\"\n"
"gbde_lockdir=\"/etc/gbde\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1889
msgid ""
"This requires that the passphrase be entered at the console at boot time.  "
"After typing the correct passphrase, the encrypted partition will be mounted "
"automatically.  Additional gbde boot options are available and listed in man:"
"rc.conf[5]."
msgstr ""
"이를 위해서는 부팅 시 콘솔에서 암호 구문을 입력해야 합니다.  올바른 암호 구문"
"을 입력하면 암호화된 파티션이 자동으로 마운트됩니다.  추가 gbde 부팅 옵션을 "
"사용할 수 있으며 man:rc.conf[5]에 나열되어 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1895
msgid ""
"sysinstall is incompatible with gbde-encrypted devices.  All [.filename]#*."
"bde# devices must be detached from the kernel before starting sysinstall or "
"it will crash during its initial probing for devices.  To detach the "
"encrypted device used in the example, use the following command:"
msgstr ""
"sysinstall은 gbde-암호화 장치와 호환되지 않습니다.  모든 [.filename]#*.bde# "
"디바이스를 커널에서 분리한 후 sysinstall을 시작해야 하며, 그렇지 않으면 디바"
"이스를 처음 검색하는 동안 충돌이 발생합니다.  예제에서 사용된 암호화된 장치"
"를 분리하려면 다음 명령을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1899
#, no-wrap
msgid "# gbde detach /dev/ad4s1c\n"
msgstr "# gbde detach /dev/ad4s1c\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1903
#, no-wrap
msgid "Disk Encryption with `geli`"
msgstr "`geli` 를 사용한 디스크 암호화"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1908
msgid ""
"An alternative cryptographic GEOM class is available using `geli`.  This "
"control utility adds some features and uses a different scheme for doing "
"cryptographic work.  It provides the following features:"
msgstr ""
"`geli` 를 사용하면 대체 암호화 GEOM 클래스를 사용할 수 있습니다.  이 제어 유"
"틸리티는 몇 가지 기능을 추가하고 암호화 작업을 수행하기 위해 다른 체계를 사용"
"합니다.  다음과 같은 기능을 제공합니다:"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1910
msgid ""
"Utilizes the man:crypto[9] framework and automatically uses cryptographic "
"hardware when it is available."
msgstr ""
"man:crypto[9] 프레임워크를 활용하고 암호화 하드웨어를 사용할 수 있는 경우 자"
"동으로 사용합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1911
#, fuzzy
#| msgid ""
#| "Supports multiple cryptographic algorithms such as AES, Blowfish, and "
#| "3DES."
msgid ""
"Supports multiple cryptographic algorithms such as AES-XTS, AES-CBC, and "
"Camellia-CBCAES."
msgstr "AES, 블로우피시, 3DES 등 여러 암호화 알고리즘을 지원합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1912
msgid ""
"Allows the root partition to be encrypted. The passphrase used to access the "
"encrypted root partition will be requested during system boot."
msgstr ""
"루트 파티션을 암호화하도록 허용합니다. 암호화된 루트 파티션에 액세스하는 데 "
"사용되는 암호는 시스템 부팅 중에 요청됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1913
msgid "Allows the use of two independent keys."
msgstr "두 개의 독립적인 키를 사용할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1914
msgid "It is fast as it performs simple sector-to-sector encryption."
msgstr "간단한 섹터 간 암호화를 수행하기 때문에 빠릅니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1915
msgid ""
"Allows backup and restore of master keys. If a user destroys their keys, it "
"is still possible to get access to the data by restoring keys from the "
"backup."
msgstr ""
"마스터 키의 백업 및 복원을 허용합니다. 사용자가 키를 파기하더라도 백업에서 키"
"를 복원하여 데이터에 액세스할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1916
msgid ""
"Allows a disk to attach with a random, one-time key which is useful for swap "
"partitions and temporary file systems."
msgstr ""
"스왑 파티션 및 임시 파일 시스템에 유용한 임의의 일회용 키로 디스크를 연결할 "
"수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1918
msgid "More features and usage examples can be found in man:geli[8]."
msgstr "더 많은 기능과 사용 예제는 man:geli[8]에서 확인할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1924
msgid ""
"The following example describes how to generate a key file which will be "
"used as part of the master key for the encrypted provider mounted under [."
"filename]#/private#.  The key file will provide some random data used to "
"encrypt the master key.  The master key will also be protected by a "
"passphrase.  The provider's sector size will be 4kB.  The example describes "
"how to attach to the `geli` provider, create a file system on it, mount it, "
"work with it, and finally, how to detach it."
msgstr ""
"다음 예에서는 [.filename]#/private# 아래에 마운트된 암호화된 공급자의 마스터 "
"키의 일부로 사용되는 키 파일을 생성하는 방법을 설명합니다.  키 파일은 마스터 "
"키를 암호화하는 데 사용되는 임의의 데이터를 제공합니다.  마스터 키는 또한 암"
"호로 보호됩니다.  공급자의 섹터 크기는 4kB입니다.  이 예에서는 `geli` 공급자"
"에 연결하고, 파일 시스템을 생성하고, 마운트하고, 작업하고, 마지막으로 분리하"
"는 방법을 설명합니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1926
#, no-wrap
msgid "Procedure: Encrypting a Partition with `geli`"
msgstr "절차: `geli` 로 파티션 암호화하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1928
msgid "Load `geli` Support"
msgstr "`geli` 지원 로드"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1930
msgid ""
"Support for `geli` is available as a loadable kernel module. To configure "
"the system to automatically load the module at boot time, add the following "
"line to [.filename]#/boot/loader.conf#:"
msgstr ""
"`geli` 에 대한 지원은 로드 가능한 커널 모듈로 제공됩니다. 부팅 시 모듈을 자동"
"으로 로드하도록 시스템을 구성하려면 [.filename]#/boot/loader.conf# 에 다음 줄"
"을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1934
#, no-wrap
msgid "geom_eli_load=\"YES\"\n"
msgstr "geom_eli_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1937
msgid "To load the kernel module now:"
msgstr "지금 커널 모듈을 로드하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1941
#, no-wrap
msgid "# kldload geom_eli\n"
msgstr "# kldload geom_eli\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1944
msgid ""
"For a custom kernel, ensure the kernel configuration file contains these "
"lines:"
msgstr ""
"커스텀 커널의 경우 커널 구성 파일에 다음 줄이 포함되어 있는지 확인하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1949
#, no-wrap
msgid ""
"options GEOM_ELI\n"
"device crypto\n"
msgstr ""
"options GEOM_ELI\n"
"device crypto\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1952
msgid "Generate the Master Key"
msgstr "마스터 키 생성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1959
msgid ""
"The following commands generate a master key that all data will be encrypted "
"with.  This key can never be changed.  Rather than using it directly, it is "
"encrypted with one or more user keys.  The user keys are made up of an "
"optional combination of random bytes from a file, [.filename]#/root/da2."
"key#, and/or a passphrase.  In this case, the data source for the key file "
"is [.filename]#/dev/random#.  This command also configures the sector size "
"of the provider ([.filename]#/dev/da2.eli#) as 4kB, for better performance:"
msgstr ""
"다음 명령은 모든 데이터를 암호화할 마스터 키를 생성합니다.  이 키는 절대 변경"
"할 수 없습니다.  이 키를 직접 사용하는 대신 하나 이상의 사용자 키로 암호화됩"
"니다.  사용자 키는 파일에서 임의의 바이트, [.filename]#/root/da2.key# 및/또"
"는 암호 구문(선택 사항)의 조합으로 구성됩니다.  이 경우 키 파일의 데이터 소스"
"는 [.filename]#/dev/random# 입니다.  이 명령은 또한 성능 향상을 위해 공급자"
"( [.filename]#/dev/da2.eli# )의 섹터 크기를 4kB로 구성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1966
#, no-wrap
msgid ""
"# dd if=/dev/random of=/root/da2.key bs=64 count=1\n"
"# geli init -K /root/da2.key -s 4096 /dev/da2\n"
"Enter new passphrase:\n"
"Reenter new passphrase:\n"
msgstr ""
"# dd if=/dev/random of=/root/da2.key bs=64 count=1\n"
"# geli init -K /root/da2.key -s 4096 /dev/da2\n"
"Enter new passphrase:\n"
"Reenter new passphrase:\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1969
msgid ""
"It is not mandatory to use both a passphrase and a key file as either method "
"of securing the master key can be used in isolation."
msgstr ""
"마스터키를 보호하는 두 가지 방법 중 하나를 단독으로 사용할 수 있으므로 비밀번"
"호와 키 파일을 모두 사용해야 하는 것은 아닙니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1972
msgid ""
"If the key file is given as \"-\", standard input will be used.  For "
"example, this command generates three key files:"
msgstr ""
"키 파일을 \"-\"로 지정하면 표준 입력이 사용됩니다.  예를 들어, 이 명령은 3개"
"의 키 파일을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1976
#, no-wrap
msgid "# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2\n"
msgstr "# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1979
msgid "Attach the Provider with the Generated Key"
msgstr "생성된 키로 공급자를 연결"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1981
msgid ""
"To attach the provider, specify the key file, the name of the disk, and the "
"passphrase:"
msgstr "공급자를 연결하려면 키 파일, 디스크 이름 및 암호를 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1986
#, no-wrap
msgid ""
"# geli attach -k /root/da2.key /dev/da2\n"
"Enter passphrase:\n"
msgstr ""
"# geli attach -k /root/da2.key /dev/da2\n"
"Enter passphrase:\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1989
msgid "This creates a new device with an [.filename]#.eli# extension:"
msgstr "이렇게 하면 확장자가 [.filename]#.eli# 인 새 장치가 만들어집니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1994
#, no-wrap
msgid ""
"# ls /dev/da2*\n"
"/dev/da2  /dev/da2.eli\n"
msgstr ""
"# ls /dev/da2*\n"
"/dev/da2  /dev/da2.eli\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1997
msgid "Create the New File System"
msgstr "새 파일 시스템 생성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1999
msgid ""
"Next, format the device with the UFS file system and mount it on an existing "
"mount point:"
msgstr ""
"다음으로, UFS 파일 시스템으로 장치를 포맷하고 기존 마운트 지점에 마운트합니"
"다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2005
#, no-wrap
msgid ""
"# dd if=/dev/random of=/dev/da2.eli bs=1m\n"
"# newfs /dev/da2.eli\n"
"# mount /dev/da2.eli /private\n"
msgstr ""
"# dd if=/dev/random of=/dev/da2.eli bs=1m\n"
"# newfs /dev/da2.eli\n"
"# mount /dev/da2.eli /private\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2008
msgid "The encrypted file system should now be available for use:"
msgstr "이제 암호화된 파일 시스템을 사용할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2019
#, no-wrap
msgid ""
"# df -H\n"
"Filesystem     Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a    248M    89M   139M    38%    /\n"
"/devfs         1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr\n"
"/dev/ad0s1d    989M   1.5M   909M     0%    /tmp\n"
"/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var\n"
"/dev/da2.eli   150G   4.1K   138G     0%    /private\n"
msgstr ""
"# df -H\n"
"Filesystem     Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a    248M    89M   139M    38%    /\n"
"/devfs         1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr\n"
"/dev/ad0s1d    989M   1.5M   909M     0%    /tmp\n"
"/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var\n"
"/dev/da2.eli   150G   4.1K   138G     0%    /private\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2022
msgid ""
"Once the work on the encrypted partition is done, and the [.filename]#/"
"private# partition is no longer needed, it is prudent to put the device into "
"cold storage by unmounting and detaching the `geli` encrypted partition from "
"the kernel:"
msgstr ""
"암호화된 파티션에 대한 작업이 완료되고 [.filename]#/private# 파티션이 더 이"
"상 필요하지 않게 되면, 커널에서 `geli` 암호화된 파티션을 마운트 해제하고 분리"
"하여 장치를 콜드 스토리지에 넣는 것이 현명합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2027
#, no-wrap
msgid ""
"# umount /private\n"
"# geli detach da2.eli\n"
msgstr ""
"# umount /private\n"
"# geli detach da2.eli\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2030
msgid ""
"An [.filename]#rc.d# script is provided to simplify the mounting of `geli`-"
"encrypted devices at boot time. For this example, add these lines to [."
"filename]#/etc/rc.conf#:"
msgstr ""
"부팅 시 `geli` 로 암호화된 디바이스의 마운팅을 간소화하기 위해 [."
"filename]#rc.d# 스크립트가 제공됩니다. 이 예제에서는 [.filename]#/etc/rc."
"conf# 에 다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2035
#, no-wrap
msgid ""
"geli_devices=\"da2\"\n"
"geli_da2_flags=\"-k /root/da2.key\"\n"
msgstr ""
"geli_devices=\"da2\"\n"
"geli_da2_flags=\"-k /root/da2.key\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2045
msgid ""
"This configures [.filename]#/dev/da2# as a `geli` provider with a master key "
"of [.filename]#/root/da2.key#.  The system will automatically detach the "
"provider from the kernel before the system shuts down.  During the startup "
"process, the script will prompt for the passphrase before attaching the "
"provider.  Other kernel messages might be shown before and after the "
"password prompt.  If the boot process seems to stall, look carefully for the "
"password prompt among the other messages.  Once the correct passphrase is "
"entered, the provider is attached.  The file system is then mounted, "
"typically by an entry in [.filename]#/etc/fstab#.  Refer to crossref:"
"basics[mount-unmount,“Mounting and Unmounting File Systems”] for "
"instructions on how to configure a file system to mount at boot time."
msgstr ""
"이렇게 하면 [.filename]#/dev/da2# 의 마스터 키가 [.filename]#/root/da2.key# "
"인 `geli` 공급자로 구성됩니다.  시스템이 종료되기 전에 커널에서 프로바이더가 "
"자동으로 분리됩니다.  시작 프로세스 중에 스크립트는 공급자를 연결하기 전에 암"
"호를 입력하라는 메시지를 표시합니다.  비밀번호 프롬프트 전후에 다른 커널 메시"
"지가 표시될 수도 있습니다.  부팅 프로세스가 멈추는 것 같으면 다른 메시지 중에"
"서 비밀번호 프롬프트가 있는지 주의 깊게 살펴보세요.  올바른 암호를 입력하면 "
"공급자가 연결됩니다.  그런 다음 파일 시스템이 마운트되며, 일반적으로 [."
"filename]#/etc/fstab# 의 항목에 의해 마운트됩니다.  부팅 시 마운트하도록 파"
"일 시스템을 구성하는 방법에 대한 지침은 crossref:basics[mount-"
"unmount,“Mounting and Unmounting File Systems”]를 참조하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:2047
#, no-wrap
msgid "Encrypting Swap"
msgstr "스왑 암호화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2054
msgid ""
"Like the encryption of disk partitions, encryption of swap space is used to "
"protect sensitive information.  Consider an application that deals with "
"passwords.  As long as these passwords stay in physical memory, they are not "
"written to disk and will be cleared after a reboot.  However, if FreeBSD "
"starts swapping out memory pages to free space, the passwords may be written "
"to the disk unencrypted.  Encrypting swap space can be a solution for this "
"scenario."
msgstr ""
"디스크 파티션 암호화와 마찬가지로 스왑 공간 암호화는 중요한 정보를 보호하는 "
"데 사용됩니다.  비밀번호를 다루는 애플리케이션을 생각해 보세요.  이러한 암호"
"가 물리적 메모리에 남아 있는 한, 암호는 디스크에 기록되지 않으며 재부팅 후 지"
"워집니다.  그러나 FreeBSD가 메모리 페이지를 여유 공간으로 스왑하기 시작하면 "
"암호가 암호화되지 않은 상태로 디스크에 기록될 수 있습니다.  스왑 공간을 암호"
"화하는 것이 이 시나리오에 대한 해결책이 될 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2057
msgid ""
"This section demonstrates how to configure an encrypted swap partition using "
"man:gbde[8] or man:geli[8] encryption.  It assumes that [.filename]#/dev/"
"ada0s1b# is the swap partition."
msgstr ""
"이 섹션에서는 man:gbde[8] 또는 man:geli[8] 암호화를 사용하여 암호화된 스왑 파"
"티션을 구성하는 방법을 설명합니다.  여기서는 [.filename]#/dev/ada0s1b# 이 스"
"왑 파티션이라고 가정합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2058
#, no-wrap
msgid "Configuring Encrypted Swap"
msgstr "암호화된 스왑 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2062
msgid ""
"Swap partitions are not encrypted by default and should be cleared of any "
"sensitive data before continuing.  To overwrite the current swap partition "
"with random garbage, execute the following command:"
msgstr ""
"스왑 파티션은 기본적으로 암호화되지 않으므로 계속하기 전에 중요한 데이터를 모"
"두 지워야 합니다.  현재 스왑 파티션을 임의의 가비지로 덮어쓰려면 다음 명령을 "
"실행하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2066
#, no-wrap
msgid "# dd if=/dev/random of=/dev/ada0s1b bs=1m\n"
msgstr "# dd if=/dev/random of=/dev/ada0s1b bs=1m\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2069
msgid ""
"To encrypt the swap partition using man:gbde[8], add the `.bde` suffix to "
"the swap line in [.filename]#/etc/fstab#:"
msgstr ""
"man:gbde[8]를 사용하여 스왑 파티션을 암호화하려면 [.filename]#/etc/fstab# 의 "
"스왑 줄에 접미사 '.bde' 를 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2074
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.bde\tnone\t\tswap\tsw\t\t0\t0\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.bde\tnone\t\tswap\tsw\t\t0\t0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2077
msgid ""
"To instead encrypt the swap partition using man:geli[8], use the `.eli` "
"suffix:"
msgstr ""
"대신 man:geli[8]를 사용하여 스왑 파티션을 암호화하려면 `.eli` 접미사를 사용합"
"니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2082
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw\t\t0\t0\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw\t\t0\t0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2087
msgid ""
"By default, man:geli[8] uses the AES algorithm with a key length of 128 "
"bits.  Normally the default settings will suffice.  If desired, these "
"defaults can be altered in the options field in [.filename]#/etc/fstab#. The "
"possible flags are:"
msgstr ""
"기본적으로 man:geli[8]는 키 길이가 128비트인 AES 알고리즘을 사용합니다.  보통"
"은 기본 설정으로 충분합니다.  원하는 경우 [.filename]#/etc/fstab# 의 옵션 필"
"드에서 이러한 기본값을 변경할 수 있습니다. 가능한 플래그는 다음과 같습니다:"

#. type: Labeled list
#: documentation/content/en/books/handbook/disks/_index.adoc:2088
#, no-wrap
msgid "aalgo"
msgstr "aalgo"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2091
msgid ""
"Data integrity verification algorithm used to ensure that the encrypted data "
"has not been tampered with.  See man:geli[8] for a list of supported "
"algorithms."
msgstr ""
"암호화된 데이터가 변조되지 않았는지 확인하는 데 사용되는 데이터 무결성 검증 "
"알고리즘입니다.  지원되는 알고리즘 목록은 man:geli[8]를 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/disks/_index.adoc:2092
#, no-wrap
msgid "ealgo"
msgstr "ealgo"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2095
msgid ""
"Encryption algorithm used to protect the data.  See man:geli[8] for a list "
"of supported algorithms."
msgstr ""
"데이터를 보호하는 데 사용되는 암호화 알고리즘입니다.  지원되는 알고리즘 목록"
"은 man:geli[8]를 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/disks/_index.adoc:2096
#, no-wrap
msgid "keylen"
msgstr "keylen"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2099
msgid ""
"The length of the key used for the encryption algorithm.  See man:geli[8] "
"for the key lengths that are supported by each encryption algorithm."
msgstr ""
"암호화 알고리즘에 사용되는 키의 길이입니다.  각 암호화 알고리즘에서 지원하는 "
"키 길이는 man:geli[8]를 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/disks/_index.adoc:2100
#, no-wrap
msgid "sectorsize"
msgstr "sectorsize"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2104
msgid ""
"The size of the blocks data is broken into before it is encrypted.  Larger "
"sector sizes increase performance at the cost of higher storage overhead.  "
"The recommended size is 4096 bytes."
msgstr ""
"블록의 크기는 데이터가 암호화되기 전에 분할되는 크기입니다.  섹터 크기가 클수"
"록 스토리지 오버헤드가 증가하지만 성능이 향상됩니다.  권장 크기는 4096바이트"
"입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2106
#, fuzzy
#| msgid ""
#| "This example configures an encrypted swap partition using the Blowfish "
#| "algorithm with a key length of 128 bits and a sectorsize of 4 kilobytes:"
msgid ""
"This example configures an encrypted swap partition using the AES-XTS "
"algorithm with a key length of 128 bits and a sectorsize of 4 kilobytes:"
msgstr ""
"이 예에서는 키 길이가 128비트이고 섹터 크기가 4KB인 Blowfish 알고리즘을 사용"
"하여 암호화된 스왑 파티션을 구성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2111
#, fuzzy, no-wrap
#| msgid ""
#| "# Device\t\tMountpoint\tFStype\tOptions\t\t\t\tDump\tPass#\n"
#| "/dev/ada0s1b.eli\tnone\t\tswap\tsw,ealgo=blowfish,keylen=128,sectorsize=4096\t0\t0\n"
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\t\t\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw,ealgo=AES-XTS,keylen=128,sectorsize=4096\t0\t0\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\t\t\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw,ealgo=blowfish,keylen=128,sectorsize=4096\t0\t0\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2113
#, no-wrap
msgid "Encrypted Swap Verification"
msgstr "암호화된 스왑 확인"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2116
msgid ""
"Once the system has rebooted, proper operation of the encrypted swap can be "
"verified using `swapinfo`."
msgstr ""
"시스템이 재부팅되면 `swapinfo` 를 사용하여 암호화된 스왑이 제대로 작동하는지 "
"확인할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2118
msgid "If man:gbde[8] is being used:"
msgstr "man:gbde[8]가 사용 중인 경우:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2124
#, no-wrap
msgid ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.bde   542720        0   542720     0\n"
msgstr ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.bde   542720        0   542720     0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2127
msgid "If man:geli[8] is being used:"
msgstr "man:geli[8]가 사용 중인 경우:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2133
#, no-wrap
msgid ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.eli   542720        0   542720     0\n"
msgstr ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.eli   542720        0   542720     0\n"

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:2136
#, no-wrap
msgid "Highly Available Storage (HAST)"
msgstr "고가용성 스토리지(HAST)"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2142
msgid ""
"High availability is one of the main requirements in serious business "
"applications and highly-available storage is a key component in such "
"environments.  In FreeBSD, the Highly Available STorage (HAST) framework "
"allows transparent storage of the same data across several physically "
"separated machines connected by a TCP/IP network.  HAST can be understood as "
"a network-based RAID1 (mirror), and is similar to the DRBD(R) storage system "
"used in the GNU/Linux(R) platform.  In combination with other high-"
"availability features of FreeBSD like CARP, HAST makes it possible to build "
"a highly-available storage cluster that is resistant to hardware failures."
msgstr ""
"고가용성은 중요한 비즈니스 애플리케이션의 주요 요구 사항 중 하나이며, 고가용"
"성 스토리지는 이러한 환경에서 핵심 구성 요소입니다.  FreeBSD의 고가용성 스토"
"리지(HAST) 프레임워크는 물리적으로 분리된 여러 머신에 동일한 데이터를 TCP/IP "
"네트워크로 연결하여 투명하게 저장할 수 있습니다.  HAST는 네트워크 기반 "
"RAID1(미러)로 이해할 수 있으며, GNU/Linux(R) 플랫폼에서 사용되는 DRBD(R) 스토"
"리지 시스템과 유사합니다.  CARP와 같은 FreeBSD의 다른 고가용성 기능과 결합하"
"면 하드웨어 장애에 강한 고가용성 스토리지 클러스터를 구축할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2144
msgid "The following are the main features of HAST:"
msgstr "다음은 HAST의 주요 기능입니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2146
msgid "Can be used to mask I/O errors on local hard drives."
msgstr "로컬 하드 드라이브의 I/O 오류를 마스킹하는 데 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2147
msgid ""
"File system agnostic as it works with any file system supported by FreeBSD."
msgstr ""
"파일 시스템에 구애받지 않으므로 FreeBSD에서 지원하는 모든 파일 시스템에서 작"
"동합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2148
msgid ""
"Efficient and quick resynchronization as only the blocks that were modified "
"during the downtime of a node are synchronized."
msgstr ""
"노드의 다운타임 동안 수정된 블록만 동기화되므로 효율적이고 빠르게 재동기화할 "
"수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2149
msgid ""
"Can be used in an already deployed environment to add additional redundancy."
msgstr "이미 배포된 환경에서 여분의 중복성을 추가하는 데 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2150
msgid ""
"Together with CARP, Heartbeat, or other tools, it can be used to build a "
"robust and durable storage system."
msgstr ""
"CARP, Heartbeat 또는 기타 도구와 함께 사용하면 견고하고 내구성 있는 스토리지 "
"시스템을 구축할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2152
msgid "After reading this section, you will know:"
msgstr "이 섹션을 읽고 나면 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2154
msgid "What HAST is, how it works, and which features it provides."
msgstr "HAST가 무엇인지, 어떻게 작동하는지, 어떤 기능을 제공하는지."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2155
msgid "How to set up and use HAST on FreeBSD."
msgstr "FreeBSD에서 HAST를 설정하고 사용하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2156
msgid "How to integrate CARP and man:devd[8] to build a robust storage system."
msgstr ""
"강력한 스토리지 시스템을 구축하기 위해 CARP와 man:devd[8]를 통합하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2158
msgid "Before reading this section, you should:"
msgstr "이 섹션을 읽기 전에 다음을 알아야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2160
msgid ""
"Understand UNIX(R) and FreeBSD basics (crossref:basics[basics,FreeBSD "
"Basics])."
msgstr ""
"UNIX(R) 및 FreeBSD 기본 사항을 이해합니다(crossref:basics[basics,FreeBSD "
"Basics])."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2161
msgid ""
"Know how to configure network interfaces and other core FreeBSD subsystems "
"(crossref:config[config-tuning,Configuration and Tuning])."
msgstr ""
"네트워크 인터페이스 및 기타 핵심 FreeBSD 하위 시스템을 구성하는 방법을 알아"
"야 합니다(crossref:config[config-tuning,Configuration and Tuning])."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2162
msgid ""
"Have a good understanding of FreeBSD networking (crossref:partiv[network-"
"communication,\"Network Communication\"])."
msgstr ""
"FreeBSD 네트워킹을 잘 이해해야 합니다(crossref:partiv[network-communication,"
"\"Network Communication\"])."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2164
msgid ""
"The HAST project was sponsored by The FreeBSD Foundation with support from "
"http://www.omc.net/[http://www.omc.net/] and http://www.transip.nl/[http://"
"www.transip.nl/]."
msgstr ""
"HAST 프로젝트는 http://www.omc.net/[http://www.omc.net/] 및 http://www."
"transip.nl/[http://www.transip.nl/]의 지원으로 FreeBSD 재단의 후원을 받았습니"
"다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2165
#, no-wrap
msgid "HAST Operation"
msgstr "HAST 작업"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2169
msgid ""
"HAST provides synchronous block-level replication between two physical "
"machines: the _primary_ node and the _secondary_ node.  These two machines "
"together are referred to as a cluster."
msgstr ""
"HAST는 두 개의 물리적 머신, 즉 _primary_ 노드와 _secondary_ 노드 간에 동기식 "
"블록 레벨 복제를 제공합니다.  이 두 시스템을 함께 클러스터라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2173
msgid ""
"Since HAST works in a primary-secondary configuration, it allows only one of "
"the cluster nodes to be active at any given time.  The primary node, also "
"called _active_, is the one which will handle all the I/O requests to HAST-"
"managed devices.  The secondary node is automatically synchronized from the "
"primary node."
msgstr ""
"HAST는 일차-이차 구성으로 작동하기 때문에, 클러스터 노드 중 하나만 언제든지 "
"활성화됩니다.  _액티브_ 라고도 하는 일차 노드는 HAST 관리 장치에 대한 모든 I/"
"O 요청을 처리하는 노드입니다.  이차 노드는 일차 노드에서 자동으로 동기화됩니"
"다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2175
msgid ""
"The physical components of the HAST system are the local disk on primary "
"node, and the disk on the remote, secondary node."
msgstr ""
"HAST 시스템의 물리적 구성 요소는 일차 노드의 로컬 디스크와 원격의 이차 노드"
"에 있는 디스크입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2179
msgid ""
"HAST operates synchronously on a block level, making it transparent to file "
"systems and applications.  HAST provides regular GEOM providers in [."
"filename]#/dev/hast/# for use by other tools or applications.  There is no "
"difference between using HAST-provided devices and raw disks or partitions."
msgstr ""
"HAST는 블록 수준에서 동기적으로 작동하므로 파일 시스템과 애플리케이션에 투명"
"합니다.  HAST는 다른 도구나 애플리케이션에서 사용할 수 있도록 [.filename]#/"
"dev/hast/# 에 일반 GEOM 공급자를 제공합니다.  HAST 제공 장치와 원시 디스크 또"
"는 파티션을 사용하는 것 사이에는 차이가 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2183
msgid ""
"Each write, delete, or flush operation is sent to both the local disk and to "
"the remote disk over TCP/IP.  Each read operation is served from the local "
"disk, unless the local disk is not up-to-date or an I/O error occurs.  In "
"such cases, the read operation is sent to the secondary node."
msgstr ""
"각각의 쓰기, 삭제 또는 플러시 작업은 TCP/IP를 통해 로컬 디스크와 원격 디스크 "
"모두에 전송됩니다.  로컬 디스크가 최신 상태가 아니거나 I/O 오류가 발생하지 않"
"는 한, 각 읽기 작업은 로컬 디스크에서 제공됩니다.  문제가 발생한 경우, 읽기 "
"작업은 이차 노드로 전송됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2187
msgid ""
"HAST tries to provide fast failure recovery.  For this reason, it is "
"important to reduce synchronization time after a node's outage.  To provide "
"fast synchronization, HAST manages an on-disk bitmap of dirty extents and "
"only synchronizes those during a regular synchronization, with an exception "
"of the initial sync."
msgstr ""
"HAST는 빠른 장애 복구를 제공하기 위해 노력합니다.  따라서 노드 중단 후 동기"
"화 시간을 줄이는 것이 중요합니다.  빠른 동기화를 제공하기 위해 HAST는 더티 익"
"스텐트의 온디스크 비트맵을 관리하고 초기 동기화를 제외한 정기 동기화 중에만 "
"동기화합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2190
msgid ""
"There are many ways to handle synchronization.  HAST implements several "
"replication modes to handle different synchronization methods:"
msgstr ""
"동기화를 처리하는 방법에는 여러 가지가 있습니다.  HAST는 다양한 동기화 방법"
"을 처리하기 위해 여러 가지 복제 모드를 구현합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2192
msgid ""
"_memsync_: This mode reports a write operation as completed when the local "
"write operation is finished and when the remote node acknowledges data "
"arrival, but before actually storing the data. The data on the remote node "
"will be stored directly after sending the acknowledgement. This mode is "
"intended to reduce latency, but still provides good reliability. This mode "
"is the default."
msgstr ""
"_memsync_ : 이 모드는 로컬 쓰기 작업이 완료되고 원격 노드가 데이터 도착을 확"
"인하지만 실제로 데이터를 저장하기 전일 때 쓰기 작업이 완료된 것으로 보고합니"
"다. 원격 노드(이차 노드)의 데이터는 승인 전송 후 바로 저장됩니다. 이 모드는 "
"지연 시간을 줄이기 위한 것이지만 여전히 우수한 안정성을 제공합니다. 이 모드"
"가 기본값입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2193
msgid ""
"_fullsync_: This mode reports a write operation as completed when both the "
"local write and the remote write complete. This is the safest and the "
"slowest replication mode."
msgstr ""
"_fullsync_ : 이 모드는 로컬 쓰기와 원격 쓰기가 모두 완료되면 쓰기 작업이 완료"
"된 것으로 보고합니다. 가장 안전하면서도 가장 느린 복제 모드입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2194
msgid ""
"_async_: This mode reports a write operation as completed when the local "
"write completes. This is the fastest and the most dangerous replication "
"mode. It should only be used when replicating to a distant node where "
"latency is too high for other modes."
msgstr ""
"_async_ : 이 모드는 로컬 쓰기가 완료되면 쓰기 작업이 완료된 것으로 보고합니"
"다. 가장 빠르지만 가장 위험한 복제 모드입니다. 다른 모드를 사용하기에는 지연 "
"시간이 너무 길어 멀리 떨어진 노드로 복제할 때만 사용해야 합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2195
#, no-wrap
msgid "HAST Configuration"
msgstr "HAST 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2198
msgid "The HAST framework consists of several components:"
msgstr "HAST 프레임워크는 여러 구성 요소로 이루어져 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2200
msgid ""
"The man:hastd[8] daemon which provides data synchronization. When this "
"daemon is started, it will automatically load `geom_gate.ko`."
msgstr ""
"데이터 동기화를 제공하는 man:hastd[8] 데몬입니다. 이 데몬이 시작되면 "
"`geom_gate.ko` 를 자동으로 로드합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2201
msgid "The userland management utility, man:hastctl[8]."
msgstr "사용자 공간 관리 유틸리티, man:hastctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2202
msgid ""
"The man:hast.conf[5] configuration file. This file must exist before "
"starting hastd."
msgstr ""
"man:hast.conf[5] 구성 파일. 이 파일은 hastd를 시작하기 전에 존재해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2204
msgid ""
"Users who prefer to statically build `GEOM_GATE` support into the kernel "
"should add this line to the custom kernel configuration file, then rebuild "
"the kernel using the instructions in crossref:kernelconfig[kernelconfig,"
"Configuring the FreeBSD Kernel]:"
msgstr ""
"커널에 `GEOM_GATE` 지원을 정적으로 빌드하고 싶은 사용자는 커스텀 커널 구성 파"
"일에 이 줄을 추가한 다음 crossref:kernelconfig[kernelconfig,Configuring the "
"FreeBSD Kernel]의 지침에 따라 커널을 다시 빌드해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2208
#, no-wrap
msgid "options\tGEOM_GATE\n"
msgstr "options\tGEOM_GATE\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2214
msgid ""
"The following example describes how to configure two nodes in primary-"
"secondary operation using HAST to replicate the data between the two.  The "
"nodes will be called `hasta`, with an IP address of `172.16.0.1`, and "
"`hastb`, with an IP address of `172.16.0.2`.  Both nodes will have a "
"dedicated hard drive [.filename]#/dev/ad6# of the same size for HAST "
"operation.  The HAST pool, sometimes referred to as a resource or the GEOM "
"provider in [.filename]#/dev/hast/#, will be called `test`."
msgstr ""
"다음 예제는 HAST를 사용하여 두 노드 간 데이터를 복제하는 일차-이차 작업에서 "
"두 노드를 구성하는 방법을 설명합니다.  노드는 `172.16.0.1` 의 IP 주소를 가진 "
"`hasta` 와 `172.16.0.2` 의 IP 주소를 가진 `hastb` 로 불립니다.  두 노드 모두 "
"HAST 작동을 위해 동일한 크기의 전용 하드 드라이브 [.filename]#/dev/ad6# 을 갖"
"게 됩니다.  HAST 풀은 리소스 또는 [.filename]#/dev/hast/# 의 GEOM 제공자라고"
"도 하며, `test` 라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2218
msgid ""
"Configuration of HAST is done using [.filename]#/etc/hast.conf#.  This file "
"should be identical on both nodes.  The simplest configuration is:"
msgstr ""
"HAST의 구성은 [.filename]#/etc/hast.conf# 를 사용하여 수행됩니다.  이 파일은 "
"두 노드에서 동일해야 합니다.  가장 간단한 구성은:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2231
#, no-wrap
msgid ""
"resource test {\n"
"\ton hasta {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.2\n"
"\t}\n"
"\ton hastb {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.1\n"
"\t}\n"
"}\n"
msgstr ""
"resource test {\n"
"\ton hasta {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.2\n"
"\t}\n"
"\ton hastb {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.1\n"
"\t}\n"
"}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2234
msgid "For more advanced configuration, refer to man:hast.conf[5]."
msgstr "고급 구성은 man:hast.conf[5]를 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2238
msgid ""
"It is also possible to use host names in the `remote` statements if the "
"hosts are resolvable and defined either in [.filename]#/etc/hosts# or in the "
"local DNS."
msgstr ""
"호스트가 [.filename]#/etc/hosts# 또는 로컬 DNS에 정의되어 있고 확인 가능한 경"
"우 `remote` 문에 호스트 이름을 사용할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2242
msgid ""
"Once the configuration exists on both nodes, the HAST pool can be created.  "
"Run these commands on both nodes to place the initial metadata onto the "
"local disk and to start man:hastd[8]:"
msgstr ""
"구성파일이 두 노드에 모두 존재하면 HAST 풀을 생성할 수 있습니다.  두 노드에"
"서 다음 명령을 실행하여 초기 메타데이터를 로컬 디스크에 배치하고 man:hastd[8]"
"를 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2247
#, no-wrap
msgid ""
"# hastctl create test\n"
"# service hastd onestart\n"
msgstr ""
"# hastctl create test\n"
"# service hastd onestart\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2253
msgid ""
"It is _not_ possible to use GEOM providers with an existing file system or "
"to convert an existing storage to a HAST-managed pool.  This procedure needs "
"to store some metadata on the provider and there will not be enough required "
"space available on an existing provider."
msgstr ""
"기존 파일 시스템과 함께 GEOM 공급자를 사용하거나 기존 저장소를 HAST 관리 풀"
"로 변환하는 것은 _불가능_ 합니다.  이 절차는 일부 메타데이터를 제공자에 저장"
"해야 하며 기존 제공자에는 필요한 공간이 충분하지 않을 것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2257
msgid ""
"A HAST node's `primary` or `secondary` role is selected by an administrator, "
"or software like Heartbeat, using man:hastctl[8].  On the primary node, "
"`hasta`, issue this command:"
msgstr ""
"HAST 노드의 `일차` 또는 `이차` 역할은 관리자 또는 Heartbeat와 같은 소프트웨어"
"가 man:hastctl[8]을 사용하여 선택합니다.  일차 노드인 `hasta` 에서 이 명령을 "
"실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2261
#, no-wrap
msgid "# hastctl role primary test\n"
msgstr "# hastctl role primary test\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2264
msgid "Run this command on the secondary node, `hastb`:"
msgstr "이차 노드인 `hastb` 에서 이 명령을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2268
#, no-wrap
msgid "# hastctl role secondary test\n"
msgstr "# hastctl role secondary test\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2271
msgid "Verify the result by running `hastctl` on each node:"
msgstr "각 노드에서 `hastctl` 을 실행하여 결과를 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2275
#, no-wrap
msgid "# hastctl status test\n"
msgstr "# hastctl status test\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2281
msgid ""
"Check the `status` line in the output.  If it says `degraded`, something is "
"wrong with the configuration file.  It should say `complete` on each node, "
"meaning that the synchronization between the nodes has started.  The "
"synchronization completes when `hastctl status` reports 0 bytes of `dirty` "
"extents."
msgstr ""
"출력에서 `status` 줄을 확인하세요.  `degraded` 이라고 표시되면 구성 파일에 문"
"제가 있는 것입니다.  각 노드에 `complete` 라고 표시되어야 하며, 이는 노드 간 "
"동기화가 시작되었음을 의미합니다.  `hastctl status` 가 0바이트의 `dirty` 익스"
"텐트를 보고하면 동기화가 완료됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2286
msgid ""
"The next step is to create a file system on the GEOM provider and mount it.  "
"This must be done on the `primary` node.  Creating the file system can take "
"a few minutes, depending on the size of the hard drive.  This example "
"creates a UFS file system on [.filename]#/dev/hast/test#:"
msgstr ""
"다음 단계는 GEOM 공급자에 파일 시스템을 생성하고 마운트하는 것입니다.  이 작"
"업은 '일차' 노드에서 수행해야 합니다.  파일 시스템을 생성하는 데에는 하드 드"
"라이브의 크기에 따라 몇 분 정도 걸릴 수 있습니다.  이 예제에서는 [."
"filename]#/dev/hast/test# 에 UFS 파일 시스템을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2292
#, no-wrap
msgid ""
"# newfs -U /dev/hast/test\n"
"# mkdir /hast/test\n"
"# mount /dev/hast/test /hast/test\n"
msgstr ""
"# newfs -U /dev/hast/test\n"
"# mkdir /hast/test\n"
"# mount /dev/hast/test /hast/test\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2296
msgid ""
"Once the HAST framework is configured properly, the final step is to make "
"sure that HAST is started automatically during system boot.  Add this line "
"to [.filename]#/etc/rc.conf#:"
msgstr ""
"HAST 프레임워크가 올바르게 구성되면, 마지막 단계는 시스템 부팅 중에 HAST가 자"
"동으로 시작되도록 하는 것입니다.  이 줄을 [.filename]#/etc/rc.conf# 에 추가합"
"니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2300
#, no-wrap
msgid "hastd_enable=\"YES\"\n"
msgstr "hastd_enable=\"YES\"\n"

#. type: Title ====
#: documentation/content/en/books/handbook/disks/_index.adoc:2302
#, no-wrap
msgid "Failover Configuration"
msgstr "장애 조치 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2306
msgid ""
"The goal of this example is to build a robust storage system which is "
"resistant to the failure of any given node.  If the primary node fails, the "
"secondary node is there to take over seamlessly, check and mount the file "
"system, and continue to work without missing a single bit of data."
msgstr ""
"이 예제의 목표는 특정 노드의 장애에 견딜 수 있는 강력한 스토리지 시스템을 구"
"축하는 것입니다.  일차 노드에 장애가 발생하면 이차 노드가 원활하게 인계받아 "
"파일 시스템을 확인하고 마운트하여 단 하나의 비트 데이터도 놓치지 않고 계속 작"
"업할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2312
msgid ""
"To accomplish this task, the Common Address Redundancy Protocol (CARP) is "
"used to provide for automatic failover at the IP layer.  CARP allows "
"multiple hosts on the same network segment to share an IP address.  Set up "
"CARP on both nodes of the cluster according to the documentation available "
"in crossref:advanced-networking[carp,“Common Address Redundancy Protocol "
"(CARP)”].  In this example, each node will have its own management IP "
"address and a shared IP address of _172.16.0.254_.  The primary HAST node of "
"the cluster must be the primary CARP node."
msgstr ""
"이 작업을 수행하기 위해 공통 주소 중복 프로토콜(Common Address Redundancy "
"Protocol, CARP)을 사용하여 IP 계층에서 자동 장애조치를 제공합니다.  CARP를 사"
"용하면 동일한 네트워크 세그먼트에 있는 여러 호스트가 하나의 IP 주소를 공유할 "
"수 있습니다.  crossref:advanced-networking[carp,“Common Address Redundancy "
"Protocol (CARP)”] 문서에 나와 있는 설명서에 따라 클러스터의 두 노드에서 CARP"
"를 설정합니다.  이 예제에서 각 노드는 자체 관리 IP 주소와 _172.16.0.254_ 의 "
"공유 IP 주소를 갖습니다.  클러스터의 일차 HAST 노드는 일차 CARP 노드여야 합니"
"다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2316
msgid ""
"The HAST pool created in the previous section is now ready to be exported to "
"the other hosts on the network.  This can be accomplished by exporting it "
"through NFS or Samba, using the shared IP address _172.16.0.254_.  The only "
"problem which remains unresolved is an automatic failover should the primary "
"node fail."
msgstr ""
"이제 이전 섹션에서 생성한 HAST 풀을 네트워크의 다른 호스트로 내보낼 준비가 되"
"었습니다.  공유 IP 주소 _172.16.0.254_ 를 사용하여 NFS 또는 Samba를 통해 내보"
"내면 됩니다.  아직 해결되지 않은 유일한 문제는 기본 노드에 장애가 발생할 경"
"우 자동 장애조치입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2320
msgid ""
"In the event of CARP interfaces going up or down, the FreeBSD operating "
"system generates a man:devd[8] event, making it possible to watch for state "
"changes on the CARP interfaces.  A state change on the CARP interface is an "
"indication that one of the nodes failed or came back online.  These state "
"change events make it possible to run a script which will automatically "
"handle the HAST failover."
msgstr ""
"CARP 인터페이스가 올라가거나 내려가는 경우, FreeBSD 운영체제는 man:devd[8] 이"
"벤트를 생성하여 CARP 인터페이스의 상태 변화를 관찰할 수 있게 합니다.  CARP 인"
"터페이스의 상태 변경은 노드 중 하나가 실패했거나 다시 온라인 상태가 되었음을 "
"나타냅니다.  이러한 상태 변경 이벤트를 통해 HAST 장애 조치를 자동으로 처리하"
"는 스크립트를 실행할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2322
#, fuzzy
#| msgid ""
#| "To catch state changes on the CARP interfaces, add this configuration to "
#| "[.filename]#/etc/devd.conf# on each node:"
msgid ""
"To catch state changes on the CARP interfaces, add this configuration to [."
"filename]#/etc/devd.conf# on each node, while replacing `<vhid>` with the "
"virtual host id and `<ifname>` with the associated interface name:"
msgstr ""
"CARP 인터페이스의 상태 변경을 포착하려면 각 노드의 [.filename]#/etc/devd."
"conf# 에 다음 구성을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2331
#, fuzzy, no-wrap
#| msgid ""
#| "notify 30 {\n"
#| "\tmatch \"system\" \"IFNET\";\n"
#| "\tmatch \"subsystem\" \"carp0\";\n"
#| "\tmatch \"type\" \"LINK_UP\";\n"
#| "\taction \"/usr/local/sbin/carp-hast-switch primary\";\n"
#| "};\n"
msgid ""
"notify 30 {\n"
"\tmatch \"system\" \"CARP\";\n"
"\tmatch \"subsystem\" \"<vhid>@<ifname>\";\n"
"\tmatch \"type\" \"MASTER\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch primary\";\n"
"};\n"
msgstr ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_UP\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch primary\";\n"
"};\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2338
#, fuzzy, no-wrap
#| msgid ""
#| "notify 30 {\n"
#| "\tmatch \"system\" \"IFNET\";\n"
#| "\tmatch \"subsystem\" \"carp0\";\n"
#| "\tmatch \"type\" \"LINK_DOWN\";\n"
#| "\taction \"/usr/local/sbin/carp-hast-switch secondary\";\n"
#| "};\n"
msgid ""
"notify 30 {\n"
"\tmatch \"system\" \"CARP\";\n"
"\tmatch \"subsystem\" \"<vhid>@<ifname>\";\n"
"\tmatch \"type\" \"BACKUP\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch secondary\";\n"
"};\n"
msgstr ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_DOWN\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch secondary\";\n"
"};\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2341
msgid ""
"Restart man:devd[8] on both nodes to put the new configuration into effect:"
msgstr "두 노드 모두에서 man:devd[8]를 재시작하여 새 구성을 적용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2345
#, no-wrap
msgid "# service devd restart\n"
msgstr "# service devd restart\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2349
msgid ""
"When the specified interface state changes by going up or down , the system "
"generates a notification, allowing the man:devd[8] subsystem to run the "
"specified automatic failover script, [.filename]#/usr/local/sbin/carp-hast-"
"switch#.  For further clarification about this configuration, refer to man:"
"devd.conf[5]."
msgstr ""
"지정된 인터페이스 상태가 위 또는 아래로 이동하여 변경되면 시스템은 알림을 생"
"성하여 man:devd[8] 서브시스템이 지정된 자동 장애조치 스크립트인 [.filename]#/"
"usr/local/sbin/carp-hast-switch# 를 실행할 수 있도록 합니다.  이 구성에 대한 "
"자세한 설명은 man:devd.conf[5]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2351
msgid "Here is an example of an automated failover script:"
msgstr "다음은 자동화된 장애 조치 스크립트의 예입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2355
#, no-wrap
msgid "#!/bin/sh\n"
msgstr "#!/bin/sh\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2359
#, no-wrap
msgid ""
"# Original script by Freddie Cash <fjwcash@gmail.com>\n"
"# Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>\n"
"# and Viktor Petersson <vpetersson@wireload.net>\n"
msgstr ""
"# Original script by Freddie Cash <fjwcash@gmail.com>\n"
"# Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>\n"
"# and Viktor Petersson <vpetersson@wireload.net>\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2362
#, no-wrap
msgid ""
"# The names of the HAST resources, as listed in /etc/hast.conf\n"
"resources=\"test\"\n"
msgstr ""
"# The names of the HAST resources, as listed in /etc/hast.conf\n"
"resources=\"test\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2366
#, no-wrap
msgid ""
"# delay in mounting HAST resource after becoming primary\n"
"# make your best guess\n"
"delay=3\n"
msgstr ""
"# delay in mounting HAST resource after becoming primary\n"
"# make your best guess\n"
"delay=3\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2370
#, no-wrap
msgid ""
"# logging\n"
"log=\"local0.debug\"\n"
"name=\"carp-hast\"\n"
msgstr ""
"# logging\n"
"log=\"local0.debug\"\n"
"name=\"carp-hast\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2372
#, no-wrap
msgid "# end of user configurable stuff\n"
msgstr "# end of user configurable stuff\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2377
#, no-wrap
msgid ""
"case \"$1\" in\n"
"\tprimary)\n"
"\t\tlogger -p $log -t $name \"Switching to primary provider for ${resources}.\"\n"
"\t\tsleep ${delay}\n"
msgstr ""
"case \"$1\" in\n"
"\tprimary)\n"
"\t\tlogger -p $log -t $name \"Switching to primary provider for ${resources}.\"\n"
"\t\tsleep ${delay}\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2383
#, no-wrap
msgid ""
"\t\t# Wait for any \"hastd secondary\" processes to stop\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\twhile $( pgrep -lf \"hastd: ${disk} \\(secondary\\)\" > /dev/null 2>&1 ); do\n"
"\t\t\t\tsleep 1\n"
"\t\t\tdone\n"
msgstr ""
"\t\t# Wait for any \"hastd secondary\" processes to stop\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\twhile $( pgrep -lf \"hastd: ${disk} \\(secondary\\)\" > /dev/null 2>&1 ); do\n"
"\t\t\t\tsleep 1\n"
"\t\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2391
#, no-wrap
msgid ""
"\t\t\t# Switch role for each disk\n"
"\t\t\thastctl role primary ${disk}\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to change role to primary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"
msgstr ""
"\t\t\t# Switch role for each disk\n"
"\t\t\thastctl role primary ${disk}\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to change role to primary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2398
#, no-wrap
msgid ""
"\t\t# Wait for the /dev/hast/* devices to appear\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tfor I in $( jot 60 ); do\n"
"\t\t\t\t[ -c \"/dev/hast/${disk}\" ] && break\n"
"\t\t\t\tsleep 0.5\n"
"\t\t\tdone\n"
msgstr ""
"\t\t# Wait for the /dev/hast/* devices to appear\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tfor I in $( jot 60 ); do\n"
"\t\t\t\t[ -c \"/dev/hast/${disk}\" ] && break\n"
"\t\t\t\tsleep 0.5\n"
"\t\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2404
#, no-wrap
msgid ""
"\t\t\tif [ ! -c \"/dev/hast/${disk}\" ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"GEOM provider /dev/hast/${disk} did not appear.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"
msgstr ""
"\t\t\tif [ ! -c \"/dev/hast/${disk}\" ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"GEOM provider /dev/hast/${disk} did not appear.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2406
#, no-wrap
msgid "\t\tlogger -p $log -t $name \"Role for HAST resources ${resources} switched to primary.\"\n"
msgstr "\t\tlogger -p $log -t $name \"Role for HAST resources ${resources} switched to primary.\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2413
#, no-wrap
msgid ""
"\t\tlogger -p $log -t $name \"Mounting disks.\"\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tmkdir -p /hast/${disk}\n"
"\t\t\tfsck -p -y -t ufs /dev/hast/${disk}\n"
"\t\t\tmount /dev/hast/${disk} /hast/${disk}\n"
"\t\tdone\n"
msgstr ""
"\t\tlogger -p $log -t $name \"Mounting disks.\"\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tmkdir -p /hast/${disk}\n"
"\t\t\tfsck -p -y -t ufs /dev/hast/${disk}\n"
"\t\t\tmount /dev/hast/${disk} /hast/${disk}\n"
"\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2415
#, no-wrap
msgid "\t;;\n"
msgstr "\t;;\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2418
#, no-wrap
msgid ""
"\tsecondary)\n"
"\t\tlogger -p $log -t $name \"Switching to secondary provider for ${resources}.\"\n"
msgstr ""
"\tsecondary)\n"
"\t\tlogger -p $log -t $name \"Switching to secondary provider for ${resources}.\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2436
#, no-wrap
msgid ""
"\t\t# Switch roles for the HAST resources\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tif ! mount | grep -q \"^/dev/hast/${disk} on \"\n"
"\t\t\tthen\n"
"\t\t\telse\n"
"\t\t\t\tumount -f /hast/${disk}\n"
"\t\t\tfi\n"
"\t\t\tsleep $delay\n"
"\t\t\thastctl role secondary ${disk} 2>&1\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to switch role to secondary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\t\tlogger -p $log -t $name \"Role switched to secondary for resource ${disk}.\"\n"
"\t\tdone\n"
"\t;;\n"
"esac\n"
msgstr ""
"\t\t# Switch roles for the HAST resources\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tif ! mount | grep -q \"^/dev/hast/${disk} on \"\n"
"\t\t\tthen\n"
"\t\t\telse\n"
"\t\t\t\tumount -f /hast/${disk}\n"
"\t\t\tfi\n"
"\t\t\tsleep $delay\n"
"\t\t\thastctl role secondary ${disk} 2>&1\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to switch role to secondary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\t\tlogger -p $log -t $name \"Role switched to secondary for resource ${disk}.\"\n"
"\t\tdone\n"
"\t;;\n"
"esac\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2439
msgid ""
"In a nutshell, the script takes these actions when a node becomes primary:"
msgstr ""
"간단히 말해, 스크립트는 노드가 일차 노드가 될 때 이러한 작업을 수행합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2441
msgid "Promotes the HAST pool to primary on the other node."
msgstr "다른 노드에서 HAST 풀을 일차 노드(Primary)로 승격합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2442
msgid "Checks the file system under the HAST pool."
msgstr "HAST 풀 아래의 파일 시스템을 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2443
msgid "Mounts the pool."
msgstr "풀을 마운트합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2445
msgid "When a node becomes secondary:"
msgstr "노드가 이차 노드(Secondary Node)가 되는 경우:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2447
msgid "Unmounts the HAST pool."
msgstr "HAST 풀을 마운트 해제합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2448
msgid "Degrades the HAST pool to secondary."
msgstr "HAST 풀을 이차 노드로 강등합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2453
msgid ""
"This is just an example script which serves as a proof of concept.  It does "
"not handle all the possible scenarios and can be extended or altered in any "
"way, for example, to start or stop required services."
msgstr ""
"이것은 개념 증명을 위한 예시 스크립트일 뿐입니다.  가능한 모든 시나리오를 처"
"리하는 것은 아니며 필요한 서비스를 시작하거나 중지하는 등 어떤 방식으로든 확"
"장하거나 변경할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2459
msgid ""
"For this example, a standard UFS file system was used.  To reduce the time "
"needed for recovery, a journal-enabled UFS or ZFS file system can be used "
"instead."
msgstr ""
"이 예에서는 표준 UFS 파일 시스템을 사용했습니다.  복구에 필요한 시간을 줄이려"
"면 저널이 활성화된 UFS 또는 ZFS 파일 시스템을 대신 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2462
msgid ""
"Instead of using the highly available storage locally, it can also be shared "
"to other computers on a network via crossref:network-servers[network-nfs,"
"NFS], crossref:network-servers[network-iscsi,iSCSI], man:sshfs[1], or "
"programs in ports (i.e. package:net/samba419[])."
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2464
msgid ""
"More detailed information with additional examples can be found at http://"
"wiki.FreeBSD.org/HAST[http://wiki.FreeBSD.org/HAST]."
msgstr ""
"추가 예시와 함께 더 자세한 정보는 http://wiki.FreeBSD.org/HAST[http://wiki."
"FreeBSD.org/HAST]에서 확인할 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2465
#, no-wrap
msgid "Troubleshooting"
msgstr "문제해결"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2470
msgid ""
"HAST should generally work without issues.  However, as with any other "
"software product, there may be times when it does not work as supposed.  The "
"sources of the problems may be different, but the rule of thumb is to ensure "
"that the time is synchronized between the nodes of the cluster."
msgstr ""
"HAST는 일반적으로 문제 없이 작동합니다.  그러나 다른 소프트웨어 제품과 마찬가"
"지로 예상대로 작동하지 않는 경우가 있을 수 있습니다.  문제의 원인은 다양할 "
"수 있지만, 일반적으로 클러스터의 노드 간에 시간이 동기화되어 있는지 확인하는 "
"것이 좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2474
msgid ""
"When troubleshooting HAST, the debugging level of man:hastd[8] should be "
"increased by starting `hastd` with `-d`.  This argument may be specified "
"multiple times to further increase the debugging level.  Consider also using "
"`-F`, which starts `hastd` in the foreground."
msgstr ""
"HAST 문제를 해결할 때, `hastd` 를 `-d` 로 시작하여 man:hastd[8]의 디버깅 레벨"
"을 높여야 합니다.  이 인자는 디버깅 수준을 더 높이기 위해 여러 번 지정할 수 "
"있습니다.  또한 `hastd` 를 포어 그라운드에서 시작하는 `-F` 를 사용하는 것도 "
"고려하십시오."

#. type: Title ====
#: documentation/content/en/books/handbook/disks/_index.adoc:2476
#, no-wrap
msgid "Recovering from the Split-brain Condition"
msgstr "Split-brain 상태에서 복구하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2481
msgid ""
"_Split-brain_ occurs when the nodes of the cluster are unable to communicate "
"with each other, and both are configured as primary.  This is a dangerous "
"condition because it allows both nodes to make incompatible changes to the "
"data.  This problem must be corrected manually by the system administrator."
msgstr ""
"_Split-brain_ 는 클러스터의 노드가 서로 통신할 수 없고 둘 다 일차 노드로 구성"
"되어 있을 때 발생합니다.  이 경우 두 노드 모두 데이터를 호환되지 않는 방식으"
"로 변경할 수 있으므로 위험한 상태입니다.  이 문제는 시스템 관리자가 수동으로 "
"수정해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2485
msgid ""
"The administrator must either decide which node has more important changes, "
"or perform the merge manually.  Then, let HAST perform full synchronization "
"of the node which has the broken data.  To do this, issue these commands on "
"the node which needs to be resynchronized:"
msgstr ""
"관리자는 어느 노드에 더 중요한 변경 사항이 있는지 결정하거나 수동으로 병합을 "
"수행해야 합니다.  그런 다음 HAST가 손상된 데이터가 있는 노드에 대해 전체 동기"
"화를 수행하도록 합니다.  이렇게 하려면 다시 동기화해야 하는 노드에서 다음 명"
"령을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2491
#, no-wrap
msgid ""
"# hastctl role init test\n"
"# hastctl create test\n"
"# hastctl role secondary test\n"
msgstr ""
"# hastctl role init test\n"
"# hastctl create test\n"
"# hastctl role secondary test\n"

#, no-wrap
#~ msgid "Using NTFS Disks"
#~ msgstr "NTFS 디스크 사용하기"

#~ msgid "This section explains how to mount NTFS disks in FreeBSD."
#~ msgstr ""
#~ "이 섹션에서는 FreeBSD에서 NTFS 디스크를 마운트하는 방법을 설명합니다."

#~ msgid ""
#~ "NTFS (New Technology File System) is a proprietary journaling file system "
#~ "developed by Microsoft(R).  It has been the default file system in "
#~ "Microsoft Windows(R) for many years.  FreeBSD can mount NTFS volumes "
#~ "using a FUSE file system.  These file systems are implemented as user "
#~ "space programs which interact with the man:fusefs[5] kernel module via a "
#~ "well defined interface."
#~ msgstr ""
#~ "NTFS (New Technology File System)는 Microsoft(R)에서 개발한 독점적인 저널"
#~ "링 파일 시스템입니다.  수년 동안 마이크로소프트 윈도우(R)의 기본 파일 시스"
#~ "템으로 사용되어 왔습니다.  FreeBSD는 FUSE 파일 시스템을 사용하여 NTFS 볼륨"
#~ "을 마운트할 수 있습니다.  이 파일 시스템은 잘 정의된 인터페이스를 통해 "
#~ "man:fusefs[5] 커널 모듈과 상호 작용하는 사용자 공간 프로그램으로 구현됩니"
#~ "다."

#, no-wrap
#~ msgid "*Procedure: Steps to Mount a NTFS Disk*\n"
#~ msgstr "*절차: NTFS 디스크를 마운트하는 단계*\n"

#~ msgid ""
#~ "Before using a FUSE file system we need to load the man:fusefs[5] kernel "
#~ "module:"
#~ msgstr ""
#~ "FUSE 파일 시스템을 사용하기 전에 man:fusefs[5] 커널 모듈을 로드해야 합니"
#~ "다:"

#, no-wrap
#~ msgid "# kldload fusefs\n"
#~ msgstr "# kldload fusefs\n"

#~ msgid "Use man:sysrc[8] to load the module at startup:"
#~ msgstr "시작 시 모듈을 로드하려면 man:sysrc[8]를 사용하세요:"

#, no-wrap
#~ msgid "# sysrc kld_list+=fusefs\n"
#~ msgstr "# sysrc kld_list+=fusefs\n"

#~ msgid ""
#~ "Install the actual NTFS file system from packages as in the example (see "
#~ "crossref:ports[pkgng-intro,Using pkg for Binary Package Management]) or "
#~ "from ports (see crossref:ports[ports-using,Using the Ports Collection]):"
#~ msgstr ""
#~ "예제에서와 같이 패키지(crossref:ports[pkgng-intro,Using pkg for Binary "
#~ "Package Management] 참조) 또는 포트(crossref:ports[ports-using,Using the "
#~ "Ports Collection] 참조)에서 실제 NTFS 파일 시스템을 설치합니다:"

#, no-wrap
#~ msgid "# pkg install fusefs-ntfs\n"
#~ msgstr "# pkg install fusefs-ntfs\n"

#~ msgid ""
#~ "Last we need to create a directory where the file system will be mounted:"
#~ msgstr "마지막으로 파일 시스템을 마운트할 디렉터리를 만들어야 합니다:"

#, no-wrap
#~ msgid "# mkdir /mnt/usb\n"
#~ msgstr "# mkdir /mnt/usb\n"

#~ msgid ""
#~ "Suppose a USB disk is plugged in.  The disk partition information can be "
#~ "viewed with man:gpart[8]:"
#~ msgstr ""
#~ "USB 디스크가 연결되어 있다고 가정합니다.  디스크 파티션 정보는 man:"
#~ "gpart[8]로 볼 수 있습니다:"

#, no-wrap
#~ msgid ""
#~ "# gpart show da0\n"
#~ "=>\t  63  1953525105  da0 MBR   (932G)\n"
#~ "\t  63  1953525105    1 ntfs  (932G)\n"
#~ msgstr ""
#~ "# gpart show da0\n"
#~ "=>\t  63  1953525105  da0 MBR   (932G)\n"
#~ "\t  63  1953525105    1 ntfs  (932G)\n"

#~ msgid "We can mount the disk using the following command:"
#~ msgstr "다음 명령을 사용하여 디스크를 마운트할 수 있습니다:"

#, no-wrap
#~ msgid "# ntfs-3g /dev/da0s1 /mnt/usb/\n"
#~ msgstr "# ntfs-3g /dev/da0s1 /mnt/usb/\n"

#~ msgid "The disk is now ready to use."
#~ msgstr "이제 디스크를 사용할 준비가 되었습니다."

#~ msgid "Additionally, an entry can be added to /etc/fstab:"
#~ msgstr "또한 /etc/fstab에 항목을 추가할 수도 있습니다:"

#, no-wrap
#~ msgid "/dev/da0s1  /mnt/usb\tntfs mountprog=/usr/local/bin/ntfs-3g,noauto,rw  0 0\n"
#~ msgstr "/dev/da0s1  /mnt/usb\tntfs mountprog=/usr/local/bin/ntfs-3g,noauto,rw  0 0\n"

#~ msgid "Now the disk can be now mounted with:"
#~ msgstr "이제 디스크를 마운트할 수 있습니다:"

#, no-wrap
#~ msgid "# mount /mnt/usb\n"
#~ msgstr "# mount /mnt/usb\n"

#~ msgid "The disk can be unmounted with:"
#~ msgstr "디스크를 마운트 해제할 수 있습니다:"

#, no-wrap
#~ msgid "# umount /mnt/usb/\n"
#~ msgstr "# umount /mnt/usb/\n"

#~ msgid "Popular utilities include Amanda, Bacula, rsync, and duplicity."
#~ msgstr ""
#~ "인기 있는 유틸리티로는 Amanda, Bacula, rsync, duplicity 등이 있습니다."

#~ msgid ""
#~ "If the systems are running FreeBSD 10 or higher, replace [."
#~ "filename]#carp0# with the name of the CARP-configured interface."
#~ msgstr ""
#~ "시스템이 FreeBSD 10 이상을 실행하는 경우 [.filename]#carp0# 을 CARP로 구성"
#~ "된 인터페이스의 이름으로 바꿉니다."

#~ msgid ""
#~ "The installation media for FreeBSD/i386 {rel112-current}-RELEASE does not "
#~ "include a rescue shell.  For this version, instead download and burn a "
#~ "Livefs CD image from link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/"
#~ "ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs."
#~ "iso[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-"
#~ "current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso]."
#~ msgstr ""
#~ "FreeBSD/i386 {rel112-current}-RELEASE용 설치 미디어에는 복구 셸이 포함되"
#~ "어 있지 않습니다.  이 버전의 경우, 대신 ftp://ftp.FreeBSD.org/pub/FreeBSD/"
#~ "releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-"
#~ "RELEASE-i386-livefs.iso[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/"
#~ "ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs."
#~ "iso] 링크에서 Livefs CD 이미지를 다운로드하여 구우세요."
