# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Kyung-tak, Yoo <stonegaze@me.com>, 2023.
# "Kyung-tak, Yoo" <stonegaze@me.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2025-05-01 19:56-0300\n"
"PO-Revision-Date: 2023-08-26 02:56+0000\n"
"Last-Translator: \"Kyung-tak, Yoo\" <stonegaze@me.com>\n"
"Language-Team: Korean <https://translate-dev.freebsd.org/projects/"
"documentation/bookshandbookfirewalls_index/ko/>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.17\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1
#, no-wrap
msgid "FreeBSD has three firewalls built into the base system: PF, IPFW, and IPFILTER. This chapter covers how to define packet filtering rules, the differences between the firewalls built into FreeBSD and how to use them"
msgstr "FreeBSD에는 기본 시스템에 세 가지 방화벽이 내장되어 있습니다: PF, IPFW, 그리고 IPFILTER입니다. 이 장에서는 패킷 필터링 규칙을 정의하는 방법, FreeBSD에 내장된 방화벽 간의 차이점 및 사용 방법을 다룹니다"

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1
#, no-wrap
msgid "IV. Network Communication"
msgstr "IV. 네트워크 통신"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1
#, no-wrap
msgid "Chapter 33. Firewalls"
msgstr "33장. 방화벽"

#. type: Title =
#: documentation/content/en/books/handbook/firewalls/_index.adoc:15
#, no-wrap
msgid "Firewalls"
msgstr "방화벽"

#. type: Title ==
#: documentation/content/en/books/handbook/firewalls/_index.adoc:53
#, no-wrap
msgid "Synopsis"
msgstr "요약"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:58
msgid ""
"Firewalls make it possible to filter the incoming and outgoing traffic that "
"flows through a system.  A firewall can use one or more sets of \"rules\" to "
"inspect network packets as they come in or go out of network connections and "
"either allows the traffic through or blocks it.  The rules of a firewall can "
"inspect one or more characteristics of the packets such as the protocol "
"type, source or destination host address, and source or destination port."
msgstr ""
"방화벽을 사용하면 시스템을 통해 들어오고 나가는 트래픽을 필터링할 수 있습니"
"다.  방화벽은 하나 이상의 “규칙” 세트를 사용하여 네트워크 연결에서 들어오고 "
"나가는 네트워크 패킷을 검사하고 트래픽을 통과시키거나 차단할 수 있습니다.  방"
"화벽의 규칙은 프로토콜 유형, 소스 또는 대상 호스트 주소, 소스 또는 대상 포트"
"와 같은 패킷의 하나 이상의 특성을 검사할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:61
msgid ""
"Firewalls can enhance the security of a host or a network.  They can be used "
"to do one or more of the following:"
msgstr ""
"방화벽은 호스트 또는 네트워크의 보안을 강화할 수 있습니다.  방화벽은 다음 중 "
"하나 이상의 작업을 수행하는 데 사용할 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:63
msgid ""
"Protect and insulate the applications, services, and machines of an internal "
"network from unwanted traffic from the public Internet."
msgstr ""
"공용 인터넷의 원치 않는 트래픽으로부터 내부 네트워크의 애플리케이션, 서비스, "
"머신을 보호하고 격리합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:64
msgid ""
"Limit or disable access from hosts of the internal network to services of "
"the public Internet."
msgstr ""
"내부 네트워크 호스트의 공용 인터넷 서비스에 대한 액세스를 제한하거나 비활성화"
"합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:65
msgid ""
"Support network address translation (NAT), which allows an internal network "
"to use private IP addresses and share a single connection to the public "
"Internet using either a single IP address or a shared pool of automatically "
"assigned public addresses."
msgstr ""
"내부 네트워크에서 사설 IP 주소를 사용하고 단일 IP 주소 또는 자동으로 할당된 "
"공용 주소의 공유 풀을 사용하여 공용 인터넷에 대한 단일 연결을 공유할 수 있는 "
"네트워크 주소 변환(NAT)을 지원합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:70
msgid ""
"FreeBSD has three firewalls built into the base system: PF, IPFW, and "
"IPFILTER, also known as IPF.  FreeBSD also provides two traffic shapers for "
"controlling bandwidth usage: man:altq[4] and man:dummynet[4].  ALTQ has "
"traditionally been closely tied with PF and dummynet with IPFW.  Each "
"firewall uses rules to control the access of packets to and from a FreeBSD "
"system, although they go about it in different ways and each has a different "
"rule syntax."
msgstr ""
"FreeBSD에는 기본 시스템에 세 가지 방화벽이 내장되어 있습니다: PF, IPFW, 그리"
"고 IPF라고도 알려진 IPFILTER입니다.  FreeBSD는 또한 대역폭 사용량을 제어하기 "
"위한 두 가지 트래픽 셰이퍼인 man:altq[4]와 man:dummynet[4]을 제공합니다.  "
"ALTQ는 전통적으로 PF와 밀접하게 연관되어 있고, dummynet은 IPFW와 밀접하게 연"
"관되어 있습니다.  각 방화벽은 규칙을 사용하여 FreeBSD 시스템과 주고받는 패킷"
"의 액세스를 제어하지만, 그 방식이 다르고 규칙 구문도 각각 다릅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:73
msgid ""
"FreeBSD provides multiple firewalls in order to meet the different "
"requirements and preferences for a wide variety of users.  Each user should "
"evaluate which firewall best meets their needs."
msgstr ""
"FreeBSD는 다양한 사용자들의 다양한 요구사항과 선호도를 충족시키기 위해 여러 "
"방화벽을 제공합니다.  각 사용자는 자신의 필요에 가장 적합한 방화벽을 평가해"
"야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:75
msgid "After reading this chapter, you will know:"
msgstr "이 장을 읽고 나면 다음을 알 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:77
msgid "How to define packet filtering rules."
msgstr "패킷 필터링 규칙을 정의하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:78
msgid "The differences between the firewalls built into FreeBSD."
msgstr "FreeBSD에 내장된 방화벽들 간의 차이점."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:79
msgid "How to use and configure the PF firewall."
msgstr "PF 방화벽 사용 및 구성 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:80
msgid "How to use and configure the IPFW firewall."
msgstr "IPFW 방화벽 사용 및 구성 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:81
msgid "How to use and configure the IPFILTER firewall."
msgstr "IPFILTER 방화벽을 사용하고 구성하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:83
msgid "Before reading this chapter, you should:"
msgstr "이 챕터를 읽기 전에 알아두어야 할 사항입니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:85
msgid "Understand basic FreeBSD and Internet concepts."
msgstr "기본적인 FreeBSD 사용법 및 인터넷의 개념."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:90
msgid ""
"Since all firewalls are based on inspecting the values of selected packet "
"control fields, the creator of the firewall ruleset must have an "
"understanding of how TCP/IP works, what the different values in the packet "
"control fields are, and how these values are used in a normal session "
"conversation.  For a good introduction, refer to http://www.ipprimer."
"com[Daryl's TCP/IP Primer]."
msgstr ""
"모든 방화벽은 선택된 패킷 제어 필드의 값을 검사하는 것을 기반으로 하기 때문"
"에 방화벽 규칙 집합을 만드는 사람은 TCP/IP의 작동 방식, 패킷 제어 필드의 다양"
"한 값, 일반 세션 통신에서 이러한 값이 어떻게 사용되는지에 대해 이해해야 합니"
"다.  이에 대한 자료로 http://www.ipprimer.com[Daryl's TCP/IP Primer]를 참고하"
"세요."

#. type: Title ==
#: documentation/content/en/books/handbook/firewalls/_index.adoc:93
#, no-wrap
msgid "Firewall Concepts"
msgstr "방화벽 개념"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:101
msgid ""
"A ruleset contains a group of rules which pass or block packets based on the "
"values contained in the packet.  The bi-directional exchange of packets "
"between hosts comprises a session conversation.  The firewall ruleset "
"processes both the packets arriving from the public Internet, as well as the "
"packets produced by the system as a response to them.  Each TCP/IP service "
"is predefined by its protocol and listening port.  Packets destined for a "
"specific service originate from the source address using an unprivileged "
"port and target the specific service port on the destination address.  All "
"the above parameters can be used as selection criteria to create rules which "
"will pass or block services."
msgstr ""
"규칙 집합에는 패킷에 포함된 값에 따라 패킷을 통과시키거나 차단하는 규칙 그룹"
"이 포함되어 있습니다.  호스트 간 패킷의 양방향 교환은 세션 통신으로 구성됩니"
"다.  방화벽 룰셋은 공용 인터넷에서 도착하는 패킷과 이에 대한 응답으로 시스템"
"에서 생성되는 패킷을 모두 처리합니다.  각 TCP/IP 서비스는 해당 프로토콜과 수"
"신 포트로 미리 정의됩니다.  특정 서비스를 대상으로 하는 패킷은 권한이 없는 포"
"트를 사용하여 소스 주소에서 출발하여 대상 주소의 특정 서비스 포트를 대상으로 "
"합니다.  위의 모든 매개변수를 선택 기준으로 사용하여 서비스를 통과시키거나 차"
"단할 규칙을 만들 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:104
#, fuzzy
#| msgid ""
#| "To lookup unknown port numbers, refer to [.filename]#/etc/services#.  "
#| "Alternatively, visit http://en.wikipedia.org/wiki/"
#| "List_of_TCP_and_UDP_port_numbers[http://en.wikipedia.org/wiki/"
#| "List_of_TCP_and_UDP_port_numbers] and do a port number lookup to find the "
#| "purpose of a particular port number."
msgid ""
"To lookup unknown port numbers, refer to [.filename]#/etc/services#.  "
"Alternatively, visit https://en.wikipedia.org/wiki/"
"List_of_TCP_and_UDP_port_numbers[https://en.wikipedia.org/wiki/"
"List_of_TCP_and_UDP_port_numbers] and do a port number lookup to find the "
"purpose of a particular port number."
msgstr ""
"알 수 없는 포트 번호를 조회하려면 [.filename]#/etc/services# 를 참조하세요.  "
"또는 http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers[http://en."
"wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers]를 방문하여 포트 번호 조"
"회를 수행하여 특정 포트 번호의 용도를 찾을 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:106
msgid ""
"Check out this link for http://web.archive.org/web/20150803024617/http://www."
"sans.org/security-resources/idfaq/oddports.php[port numbers used by Trojans]."
msgstr ""
"http://web.archive.org/web/20150803024617/http://www.sans.org/security-"
"resources/idfaq/oddports.php[트로이 목마가 사용하는 포트 번호]는 이 링크에서 "
"확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:111
msgid ""
"FTP has two modes: active mode and passive mode.  The difference is in how "
"the data channel is acquired.  Passive mode is more secure as the data "
"channel is acquired by the ordinal ftp session requester.  For a good "
"explanation of FTP and the different modes, see http://www.slacksite.com/"
"other/ftp.html[http://www.slacksite.com/other/ftp.html]."
msgstr ""
"FTP에는 액티브 모드와 패시브 모드의 두 가지 모드가 있습니다.  데이터 채널을 "
"획득하는 방식에 차이가 있습니다.  패시브 모드는 서수(ordinal) FTP 세션 요청자"
"가 데이터 채널을 획득하므로 더 안전합니다.  FTP 및 다양한 모드에 대한 자세한 "
"설명은 http://www.slacksite.com/other/ftp.html[http://www.slacksite.com/"
"other/ftp.html]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:115
msgid ""
"A firewall ruleset can be either \"exclusive\" or \"inclusive\".  An "
"exclusive firewall allows all traffic through except for the traffic "
"matching the ruleset.  An inclusive firewall does the reverse as it only "
"allows traffic matching the rules through and blocks everything else."
msgstr ""
"방화벽 규칙 집합은 “배타적”이거나 “포괄적”일 수 있습니다.  배타적 방화벽은 규"
"칙 세트와 일치하는 트래픽을 제외한 모든 트래픽을 통과시킵니다.  포괄적 방화벽"
"은 반대로 규칙과 일치하는 트래픽만 통과시키고 그 외의 모든 트래픽을 차단합니"
"다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:120
msgid ""
"An inclusive firewall offers better control of the outgoing traffic, making "
"it a better choice for systems that offer services to the public Internet.  "
"It also controls the type of traffic originating from the public Internet "
"that can gain access to a private network.  All traffic that does not match "
"the rules is blocked and logged.  Inclusive firewalls are generally safer "
"than exclusive firewalls because they significantly reduce the risk of "
"allowing unwanted traffic."
msgstr ""
"포괄적인 방화벽은 아웃바운드 트래픽을 더 잘 제어할 수 있으므로 인터넷에 서비"
"스를 제공하는 시스템에서 더 적합합니다.  또한 공용 인터넷에서 시작하여 사설 "
"네트워크에 액세스할 수 있는 트래픽 유형도 제어합니다.  규칙과 일치하지 않는 "
"모든 트래픽은 차단되고 기록됩니다.  포괄적 방화벽은 일반적으로 원치 않는 트래"
"픽을 허용할 위험을 크게 줄이므로 배타적 방화벽보다 안전합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:124
msgid ""
"Unless noted otherwise, all configuration and example rulesets in this "
"chapter create inclusive firewall rulesets."
msgstr ""
"달리 명시되지 않는 한, 이 장의 모든 구성 및 예제 규칙 집합은 포괄적인 방화벽 "
"규칙 집합을 생성합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:128
msgid ""
"Security can be tightened further using a \"stateful firewall\".  This type "
"of firewall keeps track of open connections and only allows traffic which "
"either matches an existing connection or opens a new, allowed connection."
msgstr ""
"“상태분석형 방화벽(Stateful Firewall)”을 사용하여 보안을 더욱 강화할 수 있습"
"니다.  이 유형의 방화벽은 열려 있는 연결을 추적하고 기존 연결과 일치하거나 허"
"용된 새 연결을 여는 트래픽만 허용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:133
msgid ""
"Stateful filtering treats traffic as a bi-directional exchange of packets "
"comprising a session.  When state is specified on a matching rule the "
"firewall dynamically generates internal rules for each anticipated packet "
"being exchanged during the session.  It has sufficient matching capabilities "
"to determine if a packet is valid for a session.  Any packets that do not "
"properly fit the session template are automatically rejected."
msgstr ""
"상태분석형 필터링은 트래픽을, 세션을 구성하는 패킷의 양방향 교환으로 취급합니"
"다.  매칭 규칙에 상태가 지정되면 방화벽은 세션 중에 교환될 것으로 예상되는 "
"각 패킷에 대한 내부 규칙을 동적으로 생성합니다.  방화벽은 패킷이 세션에 유효"
"한지 판단할 수 있는 충분한 매칭 기능을 갖추고 있습니다.  세션 템플릿에 제대"
"로 맞지 않는 패킷은 자동으로 거부됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:135
msgid "When the session completes, it is removed from the dynamic state table."
msgstr "세션이 완료되면 동적 상태 테이블에서 세션이 제거됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:140
msgid ""
"Stateful filtering allows one to focus on blocking/passing new sessions.  If "
"the new session is passed, all its subsequent packets are allowed "
"automatically and any impostor packets are automatically rejected.  If a new "
"session is blocked, none of its subsequent packets are allowed.  Stateful "
"filtering provides advanced matching abilities capable of defending against "
"the flood of different attack methods employed by attackers."
msgstr ""
"상태분석형 필터링을 사용하면 새 세션을 차단/통과시키는 데 집중할 수 있습니"
"다.  새 세션이 통과되면 그 이후의 모든 패킷이 자동으로 허용되고 모든 가짜 패"
"킷은 자동으로 거부됩니다.  새 세션이 차단되면 그 이후의 패킷은 모두 허용되지 "
"않습니다.  상태분석형 필터링은 공격자가 사용하는 다양한 공격 방법의 홍수를 방"
"어할 수 있는 고급 매칭 기능을 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:144
msgid ""
"NAT stands for _Network Address Translation_.  NAT function enables the "
"private LAN behind the firewall to share a single ISP-assigned IP address, "
"even if that address is dynamically assigned.  NAT allows each computer in "
"the LAN to have Internet access, without having to pay the ISP for multiple "
"Internet accounts or IP addresses."
msgstr ""
"NAT는 _네트워크 주소 변환(Network Address Translation)_ 의 약자입니다.  NAT "
"기능을 사용하면 방화벽 뒤에 있는 개인 LAN이 동적으로 할당된 주소라도 ISP에서 "
"할당된 단일 IP 주소를 공유할 수 있습니다.  NAT를 사용하면 여러 인터넷 계정이"
"나 IP 주소에 대해 ISP에 비용을 지불하지 않고도 LAN의 각 컴퓨터가 인터넷에 액"
"세스할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:147
msgid ""
"NAT will automatically translate the private LAN IP address for each system "
"on the LAN to the single public IP address as packets exit the firewall "
"bound for the public Internet.  It also performs the reverse translation for "
"returning packets."
msgstr ""
"NAT는 패킷이 방화벽을 빠져나와 공용 인터넷으로 향할 때 LAN의 각 시스템에 대"
"한 개인 LAN IP 주소를 단일 공용 IP 주소로 자동 변환합니다.  또한 패킷을 반환"
"하기 위해 역변환도 수행합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:149
msgid ""
"According to RFC 1918, the following IP address ranges are reserved for "
"private networks which will never be routed directly to the public Internet, "
"and therefore are available for use with NAT:"
msgstr ""
"RFC 1918에 따르면 다음 IP 주소 범위는 공용 인터넷으로 직접 라우팅되지 않는 사"
"설 네트워크용으로 예약되어 있으며, 따라서 NAT와 함께 사용할 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:151
msgid "`10.0.0.0/8`."
msgstr "`10.0.0.0/8`."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:152
msgid "`172.16.0.0/12`."
msgstr "`172.16.0.0/12`."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:153
msgid "`192.168.0.0/16`."
msgstr "`192.168.0.0/16`."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:159
msgid ""
"When working with the firewall rules, be _very careful_.  Some "
"configurations _can lock the administrator out_ of the server.  To be on the "
"safe side, consider performing the initial firewall configuration from the "
"local console rather than doing it remotely over ssh."
msgstr ""
"방화벽 규칙으로 작업할 때는 _매우 주의하세요_ .  일부 구성은 관리자를 서버에"
"서 _차단 할 수_ 있습니다.  안전을 위해 초기 방화벽 구성은 ssh를 통해 원격으"
"로 수행하지 말고 로컬 콘솔에서 수행하는 것이 좋습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/firewalls/_index.adoc:162
#, no-wrap
msgid "PF"
msgstr "PF"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:166
msgid ""
"Since FreeBSD 5.3, a ported version of OpenBSD's PF firewall has been "
"included as an integrated part of the base system.  PF is a complete, full-"
"featured firewall that has optional support for ALTQ (Alternate Queuing), "
"which provides Quality of Service (QoS)."
msgstr ""
"FreeBSD 5.3부터, OpenBSD의 PF 방화벽의 포팅된 버전이 기본 시스템의 통합된 부"
"분으로 포함되었습니다.  PF는 완전한 기능을 갖춘 방화벽으로, 서비스 품질(QoS)"
"을 제공하는 ALTQ(대체 큐잉)를 선택적으로 지원합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:169
msgid ""
"The OpenBSD Project maintains the definitive reference for PF in the http://"
"www.openbsd.org/faq/pf/[PF FAQ].  Peter Hansteen maintains a thorough PF "
"tutorial at http://home.nuug.no/\\~peter/pf/[http://home.nuug.no/~peter/pf/]."
msgstr ""
"OpenBSD 프로젝트는 http://www.openbsd.org/faq/pf/[PF FAQ]에서 PF에 대한 완전"
"한 참고자료를 제공하고 있습니다.  피터 한스틴(Peter Hansteen)은 http://home."
"nuug.no/\\~peter/pf/[http://home.nuug.no/~peter/pf/]에서 PF에 대한 자세한 튜"
"토리얼을 관리하고 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:174
msgid ""
"When reading the http://www.openbsd.org/faq/pf/[PF FAQ], keep in mind that "
"FreeBSD's version of PF has diverged substantially from the upstream OpenBSD "
"version over the years.  Not all features work the same way on FreeBSD as "
"they do in OpenBSD and vice versa."
msgstr ""
"http://www.openbsd.org/faq/pf/[PF FAQ]를 읽을 때, FreeBSD의 PF 버전은 수년에 "
"걸쳐 업스트림 OpenBSD 버전과 상당히 달라졌다는 점을 염두에 두세요.  모든 기능"
"이 FreeBSD에서 OpenBSD와 동일한 방식으로 작동하는 것은 아니며 그 반대의 경우"
"도 마찬가지입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:178
msgid ""
"The {freebsd-pf} is a good place to ask questions about configuring and "
"running the PF firewall.  Check the mailing list archives before asking a "
"question as it may have already been answered."
msgstr ""
"{freebsd-pf}는 PF 방화벽 구성 및 실행에 관한 질문을 하기에 좋은 곳입니다.  이"
"미 답변이 있을 수 있으므로 질문하기 전에 메일링 리스트 아카이브를 확인하시기 "
"바랍니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:182
msgid ""
"This section of the Handbook focuses on PF as it pertains to FreeBSD.  It "
"demonstrates how to enable PF and ALTQ.  It also provides several examples "
"for creating rulesets on a FreeBSD system."
msgstr ""
"핸드북의 이 섹션은 FreeBSD와 관련된 PF에 초점을 맞추고 있습니다.  PF와 ALTQ"
"를 활성화하는 방법을 설명합니다.  또한 FreeBSD 시스템에서 규칙 집합을 생성하"
"기 위한 몇 가지 예제도 제공합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:183
#, no-wrap
msgid "Enabling PF"
msgstr "PF 활성화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:187
msgid ""
"To use PF, its kernel module must be first loaded.  This section describes "
"the entries that can be added to [.filename]#/etc/rc.conf# to enable PF."
msgstr ""
"PF를 사용하려면 먼저 해당 커널 모듈을 로드해야 합니다.  이 섹션에서는 PF를 활"
"성화하기 위해 [.filename]#/etc/rc.conf# 에 추가할 수 있는 항목에 대해 설명합"
"니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:189
msgid "Start by adding `pf_enable=yes` to [.filename]#/etc/rc.conf#:"
msgstr "[.filename]#/etc/rc.conf# 에 `pf_enable=yes` 를 추가하여 시작하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:193
#, no-wrap
msgid "# sysrc pf_enable=yes\n"
msgstr "# sysrc pf_enable=yes\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:197
msgid ""
"Additional options, described in man:pfctl[8], can be passed to PF when it "
"is started.  Add or change this entry in [.filename]#/etc/rc.conf# and "
"specify any required flags between the two quotes (`\"\"`):"
msgstr ""
"man:pfctl[8]에 설명된 추가 옵션은 PF가 시작될 때 PF에 전달할 수 있습니다.  "
"이 항목을 [.filename]#/etc/rc.conf# 에서 추가하거나 변경하고 두 따옴표"
"( `””` ) 사이에 필요한 플래그를 지정하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:201
#, no-wrap
msgid "pf_flags=\"\"                     # additional flags for pfctl startup\n"
msgstr "pf_flags=\"\"                     # additional flags for pfctl startup\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:207
msgid ""
"PF will not start if it cannot find its ruleset configuration file.  By "
"default, FreeBSD does not ship with a ruleset and there is no [.filename]#/"
"etc/pf.conf#.  Example rulesets can be found in [.filename]#/usr/share/"
"examples/pf/#.  If a custom ruleset has been saved somewhere else, add a "
"line to [.filename]#/etc/rc.conf# which specifies the full path to the file:"
msgstr ""
"규칙 집합 구성 파일을 찾을 수 없으면 PF가 시작되지 않습니다.  기본적으로 "
"FreeBSD는 규칙 집합을 함께 제공하지 않으며 [.filename]#/etc/pf.conf# 가 없습"
"니다.  규칙 집합의 예는 [.filename]#/usr/share/examples/pf/# 에서 찾을 수 있"
"습니다.  사용자 지정 규칙 집합이 다른 곳에 저장되어 있는 경우 [.filename]#/"
"etc/rc.conf# 에 파일의 전체 경로를 지정하는 한 줄을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:211
#, no-wrap
msgid "pf_rules=\"/path/to/pf.conf\"\n"
msgstr "pf_rules=\"/path/to/pf.conf\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:215
msgid ""
"Logging support for PF is provided by man:pflog[4].  To enable logging "
"support, add `pflog_enable=yes` to [.filename]#/etc/rc.conf#:"
msgstr ""
"PF에 대한 로깅 지원은 man:pflog[4]에서 제공합니다.  로깅 지원을 활성화하려면 "
"[.filename]#/etc/rc.conf# 에 `pflog_enable=yes` 를 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:219
#, no-wrap
msgid "# sysrc pflog_enable=yes\n"
msgstr "# sysrc pflog_enable=yes\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:222
msgid ""
"The following lines can also be added to change the default location of the "
"log file or to specify any additional flags to pass to man:pflog[4] when it "
"is started:"
msgstr ""
"다음 줄을 추가하여 로그 파일의 기본 위치를 변경하거나 로그 파일이 시작될 때 "
"man:pflog[4]에 전달할 추가 플래그를 지정할 수도 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:227
#, no-wrap
msgid ""
"pflog_logfile=\"/var/log/pflog\"  # where pflogd should store the logfile\n"
"pflog_flags=\"\"                  # additional flags for pflogd startup\n"
msgstr ""
"pflog_logfile=\"/var/log/pflog\"  # where pflogd should store the logfile\n"
"pflog_flags=\"\"                  # additional flags for pflogd startup\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:230
msgid ""
"Finally, if there is a LAN behind the firewall and packets need to be "
"forwarded for the computers on the LAN, or NAT is required, enable the "
"following option:"
msgstr ""
"마지막으로 방화벽 뒤에 LAN이 있고 LAN에 있는 컴퓨터에 대해 패킷을 전달해야 하"
"거나 NAT가 필요한 경우 다음 옵션을 사용하도록 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:234
#, no-wrap
msgid "gateway_enable=\"YES\"            # Enable as LAN gateway\n"
msgstr "gateway_enable=\"YES\"            # Enable as LAN gateway\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:237
msgid ""
"After saving the needed edits, PF can be started with logging support by "
"typing:"
msgstr ""
"필요한 편집 내용을 저장한 후 입력하면 로깅 지원을 통해 PF를 시작할 수 있습니"
"다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:242
#, no-wrap
msgid ""
"# service pf start\n"
"# service pflog start\n"
msgstr ""
"# service pf start\n"
"# service pflog start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:247
msgid ""
"By default, PF reads its configuration rules from [.filename]#/etc/pf.conf# "
"and modifies, drops, or passes packets according to the rules or definitions "
"specified in this file.  The FreeBSD installation includes several sample "
"files located in [.filename]#/usr/share/examples/pf/#.  Refer to the http://"
"www.openbsd.org/faq/pf/[PF FAQ] for complete coverage of PF rulesets."
msgstr ""
"기본적으로 PF는 [.filename]#/etc/pf.conf# 에서 구성 규칙을 읽고 이 파일에 지"
"정된 규칙이나 정의에 따라 패킷을 수정, 드롭 또는 전달합니다.  FreeBSD를 설치"
"하면 [.filename]#/usr/share/examples/pf/# 에 몇 가지 샘플 파일이 포함되어 있"
"습니다.  PF 규칙 집합에 대한 전체 내용은 http://www.openbsd.org/faq/pf/[PF "
"FAQ]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:251
#, fuzzy
#| msgid ""
#| "To control PF, use `pfctl`.  <<pfctl>> summarizes some useful options to "
#| "this command.  Refer to man:pfctl[8] for a description of all available "
#| "options:"
msgid ""
"To control PF, use `pfctl`.  crossref:firewalls[pfctl,Useful `pfctl` "
"Options] summarizes some useful options to this command.  Refer to man:"
"pfctl[8] for a description of all available options:"
msgstr ""
"PF를 제어하려면 `pfctl` 을 사용합니다.  <<pfctl>> 에는 이 명령에 대한 몇 가"
"지 유용한 옵션이 요약되어 있습니다.  사용 가능한 모든 옵션에 대한 설명은 man:"
"pfctl[8]을 참조하십시오:"

#. type: Block title
#: documentation/content/en/books/handbook/firewalls/_index.adoc:252
#, no-wrap
msgid "Useful `pfctl` Options"
msgstr "유용한 `pfctl` 옵션"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:256
#, no-wrap
msgid "Command"
msgstr "명령어"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:258
#, no-wrap
msgid "Purpose"
msgstr "목적"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:259
#, no-wrap
msgid "`pfctl -e`"
msgstr "`pfctl -e`"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:261
#, no-wrap
msgid "Enable PF."
msgstr "PF 활성화."

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:262
#, no-wrap
msgid "`pfctl -d`"
msgstr "`pfctl -d`"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:264
#, no-wrap
msgid "Disable PF."
msgstr "PF 비활성화."

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:265
#, no-wrap
msgid "`pfctl -F all -f /etc/pf.conf`"
msgstr "`pfctl -F all -f /etc/pf.conf`"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:267
#, no-wrap
msgid "Flush all NAT, filter, state, and table rules and reload [.filename]#/etc/pf.conf#."
msgstr "모든 NAT, 필터, 상태 및 테이블 규칙을 플러시하고 [.filename]#/etc/pf.conf# 를 다시 로드합니다."

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:267
#, no-wrap
msgid "`pfctl -s [ rules \\"
msgstr "`pfctl -s [ rules \\"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:267
#, no-wrap
msgid "nat \\"
msgstr "nat \\"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:268
#, no-wrap
msgid "states ]`"
msgstr "states ]`"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:270
#, no-wrap
msgid "Report on the filter rules, NAT rules, or state table."
msgstr "필터 규칙, NAT 규칙 또는 상태 테이블에 대한 보고서를 작성합니다."

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:271
#, no-wrap
msgid "`pfctl -vnf /etc/pf.conf`"
msgstr "`pfctl -vnf /etc/pf.conf`"

#. type: Table
#: documentation/content/en/books/handbook/firewalls/_index.adoc:272
#, no-wrap
msgid "Check [.filename]#/etc/pf.conf# for errors, but do not load ruleset."
msgstr "[.filename]#/etc/pf.conf# 에 오류가 있는지 확인하되, 규칙 집합을 로드하지 마세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:278
msgid ""
"package:security/sudo[] is useful for running commands like `pfctl` that "
"require elevated privileges.  It can be installed from the Ports Collection."
msgstr ""
"package:security/sudo[]는 권한 상승이 필요한 `pfctl` 과 같은 명령을 실행하는 "
"데 유용합니다.  포트 컬렉션에서 설치할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:282
msgid ""
"To keep an eye on the traffic that passes through the PF firewall, consider "
"installing the package:sysutils/pftop[] package or port.  Once installed, "
"pftop can be run to view a running snapshot of traffic in a format which is "
"similar to man:top[1]."
msgstr ""
"PF 방화벽을 통과하는 트래픽을 주시하려면 package:sysutils/pftop[] 패키지 또"
"는 포트를 설치하는 것이 좋습니다.  설치가 완료되면 pftop을 실행하여 man:"
"top[1]과 유사한 형식으로 트래픽의 실행 중인 스냅샷을 볼 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:284
#, no-wrap
msgid "PF Rulesets"
msgstr "PF 규칙 집합"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:288
msgid ""
"This section demonstrates how to create a customized ruleset.  It starts "
"with the simplest of rulesets and builds upon its concepts using several "
"examples to demonstrate real-world usage of PF's many features."
msgstr ""
"이 섹션에서는 사용자 정의 규칙 집합을 만드는 방법을 설명합니다.  가장 간단한 "
"규칙 집합부터 시작하여 몇 가지 예제를 사용하여 개념을 바탕으로 PF의 다양한 기"
"능을 실제로 사용하는 방법을 보여줍니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:291
msgid ""
"The simplest possible ruleset is for a single machine that does not run any "
"services and which needs access to one network, which may be the Internet.  "
"To create this minimal ruleset, edit [.filename]#/etc/pf.conf# so it looks "
"like this:"
msgstr ""
"가장 간단한 규칙 집합은 서비스를 실행하지 않고 하나의 네트워크(인터넷일 수 있"
"는)에 액세스해야 하는 단일 머신에 대한 것입니다.  이 최소한의 규칙 집합을 만"
"들려면 [.filename]#/etc/pf.conf# 을 다음과 같이 편집하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:296
#, no-wrap
msgid ""
"block in all\n"
"pass out all keep state\n"
msgstr ""
"block in all\n"
"pass out all keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:302
msgid ""
"The first rule denies all incoming traffic by default.  The second rule "
"allows connections created by this system to pass out, while retaining state "
"information on those connections.  This state information allows return "
"traffic for those connections to pass back and should only be used on "
"machines that can be trusted.  The ruleset can be loaded with:"
msgstr ""
"첫 번째 규칙은 기본적으로 들어오는 모든 트래픽을 거부합니다.  두 번째 규칙은 "
"이 시스템에서 생성된 연결은 해당 연결의 상태 정보를 유지하면서 전달할 수 있도"
"록 허용합니다.  이 상태 정보를 통해 해당 연결에 대한 리턴 트래픽이 다시 전달"
"될 수 있으며 신뢰할 수 있는 컴퓨터에서만 사용해야 합니다.  다음으로 규칙 집합"
"을 로드할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:306
#, no-wrap
msgid "# pfctl -e ; pfctl -f /etc/pf.conf\n"
msgstr "# pfctl -e ; pfctl -f /etc/pf.conf\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:311
msgid ""
"In addition to keeping state, PF provides _lists_ and _macros_ which can be "
"defined for use when creating rules.  Macros can include lists and need to "
"be defined before use.  As an example, insert these lines at the very top of "
"the ruleset:"
msgstr ""
"PF는 상태 유지 외에도 규칙을 만들 때 사용할 수 있도록 정의할 수 있는 _목록_ "
"과 _매크로_ 를 제공합니다.  매크로는 목록을 포함할 수 있으며 사용하기 전에 정"
"의해야 합니다.  예를 들어, 규칙 집합의 맨 위에 이 줄을 삽입하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:316
#, no-wrap
msgid ""
"tcp_services = \"{ ssh, smtp, domain, www, pop3, auth, pop3s }\"\n"
"udp_services = \"{ domain }\"\n"
msgstr ""
"tcp_services = \"{ ssh, smtp, domain, www, pop3, auth, pop3s }\"\n"
"udp_services = \"{ domain }\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:323
msgid ""
"PF understands port names as well as port numbers, as long as the names are "
"listed in [.filename]#/etc/services#.  This example creates two macros.  The "
"first is a list of seven TCP port names and the second is one UDP port "
"name.  Once defined, macros can be used in rules.  In this example, all "
"traffic is blocked except for the connections initiated by this system for "
"the seven specified TCP services and the one specified UDP service:"
msgstr ""
"PF는 포트 이름이 [.filename]#/etc/services# 에 나열되어 있는 한, 포트 번호뿐"
"만 아니라 포트 이름도 이해합니다.  이 예제에서는 두 개의 매크로를 생성합니"
"다.  첫 번째는 7개의 TCP 포트 이름 목록이고 두 번째는 하나의 UDP 포트 이름입"
"니다.  매크로를 정의하면 규칙에서 사용할 수 있습니다.  이 예제에서는 지정된 7"
"개의 TCP 서비스와 지정된 1개의 UDP 서비스에 대해 이 시스템에서 시작된 연결을 "
"제외한 모든 트래픽이 차단됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:331
#, no-wrap
msgid ""
"tcp_services = \"{ ssh, smtp, domain, www, pop3, auth, pop3s }\"\n"
"udp_services = \"{ domain }\"\n"
"block all\n"
"pass out proto tcp to any port $tcp_services keep state\n"
"pass proto udp to any port $udp_services keep state\n"
msgstr ""
"tcp_services = \"{ ssh, smtp, domain, www, pop3, auth, pop3s }\"\n"
"udp_services = \"{ domain }\"\n"
"block all\n"
"pass out proto tcp to any port $tcp_services keep state\n"
"pass proto udp to any port $udp_services keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:335
msgid ""
"Even though UDP is considered to be a stateless protocol, PF is able to "
"track some state information.  For example, when a UDP request is passed "
"which asks a name server about a domain name, PF will watch for the response "
"to pass it back."
msgstr ""
"UDP는 무상태 프로토콜로 간주되지만 PF는 일부 상태 정보를 추적할 수 있습니"
"다.  예를 들어, 네임 서버에 도메인 이름을 묻는 UDP 요청이 전달되면 PF는 응답"
"을 감시하여 이를 다시 전달합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:337
msgid ""
"Whenever an edit is made to a ruleset, the new rules must be loaded so they "
"can be used:"
msgstr "규칙 집합을 편집할 때마다 새 규칙을 로드해야 사용할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:341
#: documentation/content/en/books/handbook/firewalls/_index.adoc:559
#, no-wrap
msgid "# pfctl -f /etc/pf.conf\n"
msgstr "# pfctl -f /etc/pf.conf\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:345
msgid ""
"If there are no syntax errors, `pfctl` will not output any messages during "
"the rule load.  Rules can also be tested before attempting to load them:"
msgstr ""
"구문 오류가 없는 경우 `pfctl` 은 규칙 로드 중에 메시지를 출력하지 않습니다.  "
"규칙을 로드하기 전에 규칙을 테스트할 수도 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:349
#, no-wrap
msgid "# pfctl -nf /etc/pf.conf\n"
msgstr "# pfctl -nf /etc/pf.conf\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:354
msgid ""
"Including `-n` causes the rules to be interpreted only, but not loaded.  "
"This provides an opportunity to correct any errors.  At all times, the last "
"valid ruleset loaded will be enforced until either PF is disabled or a new "
"ruleset is loaded."
msgstr ""
"`-n` 을 포함하면 규칙이 해석만 되고 로드되지 않습니다.  이렇게 하면 오류를 수"
"정할 수 있습니다.  항상 PF가 비활성화되거나 새 규칙 집합이 로드될 때까지 PF"
"는 마지막으로 로드된 _유효한_ 규칙 집합을 적용합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:359
msgid ""
"Adding `-v` to a `pfctl` ruleset verify or load will display the fully "
"parsed rules exactly the way they will be loaded.  This is extremely useful "
"when debugging rules."
msgstr ""
"`pfctl` 에 `-v` 를 추가하면 규칙 집합을 확인하거나 완전히 구문 분석된 규칙이 "
"로드되는 방식 그대로 표시됩니다.  이 기능은 규칙을 디버깅할 때 매우 유용합니"
"다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:362
#, no-wrap
msgid "A Simple Gateway with NAT"
msgstr "NAT를 갖춘 간단한 게이트웨이"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:367
msgid ""
"This section demonstrates how to configure a FreeBSD system running PF to "
"act as a gateway for at least one other machine.  The gateway needs at least "
"two network interfaces, each connected to a separate network.  In this "
"example, [.filename]#xl0# is connected to the Internet and [.filename]#xl1# "
"is connected to the internal network."
msgstr ""
"이 섹션에서는 PF를 실행하는 FreeBSD 시스템이 적어도 하나 이상의 다른 머신에 "
"대한 게이트웨이 역할을 하도록 구성하는 방법을 보여줍니다.  게이트웨이에는 각"
"각 별도의 네트워크에 연결된 두 개 이상의 네트워크 인터페이스가 필요합니다.  "
"이 예제에서는 [.filename]#xl0# 이 인터넷에 연결되어 있고 [.filename]#xl1# 이 "
"내부 네트워크에 연결되어 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:370
msgid ""
"First, enable the gateway to let the machine forward the network traffic it "
"receives on one interface to another interface.  This sysctl setting will "
"forward IPv4 packets:"
msgstr ""
"먼저, 게이트웨이가 한 인터페이스에서 수신한 네트워크 트래픽을 다른 인터페이스"
"로 전달할 수 있도록 설정합니다.  이 sysctl 설정은 IPv4 패킷을 전달합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:374
#, no-wrap
msgid "# sysctl net.inet.ip.forwarding=1\n"
msgstr "# sysctl net.inet.ip.forwarding=1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:377
msgid "To forward IPv6 traffic, use:"
msgstr "IPv6 트래픽을 전달하려면 다음을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:381
#, no-wrap
msgid "# sysctl net.inet6.ip6.forwarding=1\n"
msgstr "# sysctl net.inet6.ip6.forwarding=1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:384
msgid ""
"To enable these settings at system boot, use man:sysrc[8] to add them to [."
"filename]#/etc/rc.conf#:"
msgstr ""
"시스템 부팅 시 이러한 설정을 활성화하려면 man:sysrc[8]을 사용하여 [."
"filename]#/etc/rc.conf# 에 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:389
#, no-wrap
msgid ""
"# sysrc gateway_enable=yes\n"
"# sysrc ipv6_gateway_enable=yes\n"
msgstr ""
"# sysrc gateway_enable=yes\n"
"# sysrc ipv6_gateway_enable=yes\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:392
msgid "Verify with `ifconfig` that both of the interfaces are up and running."
msgstr "`ifconfig` 를 사용하여 두 인터페이스가 모두 실행 중인지 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:395
msgid ""
"Next, create the PF rules to allow the gateway to pass traffic.  While the "
"following rule allows stateful traffic from hosts of the internal network to "
"pass to the gateway, the `to` keyword does not guarantee passage all the way "
"from source to destination:"
msgstr ""
"다음으로, 게이트웨이가 트래픽을 통과하도록 허용하는 PF 규칙을 생성합니다.  다"
"음 규칙은 내부 네트워크 호스트의 상태분석형 트래픽이 게이트웨이로 전달되는 것"
"을 허용하지만, `to` 키워드가 소스에서 목적지까지 모든 경로를 보장하지는 않습"
"니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:399
#, no-wrap
msgid "pass in on xl1 from xl1:network to xl0:network port $ports keep state\n"
msgstr "pass in on xl1 from xl1:network to xl0:network port $ports keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:403
msgid ""
"That rule only lets the traffic pass in to the gateway on the internal "
"interface.  To let the packets go further, a matching rule is needed:"
msgstr ""
"이 규칙은 트래픽이 내부 인터페이스의 게이트웨이로만 통과하도록 허용합니다.  "
"패킷을 더 멀리 보내려면 일치하는 규칙이 필요합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:407
#, no-wrap
msgid "pass out on xl0 from xl1:network to xl0:network port $ports keep state\n"
msgstr "pass out on xl0 from xl1:network to xl0:network port $ports keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:413
msgid ""
"While these two rules will work, rules this specific are rarely needed.  For "
"a busy network admin, a readable ruleset is a safer ruleset.  The remainder "
"of this section demonstrates how to keep the rules as simple as possible for "
"readability.  For example, those two rules could be replaced with one rule:"
msgstr ""
"위의 두 가지 규칙은 작동하지만, 이렇게 구체적인 규칙이 필요한 경우는 거의 없"
"습니다.  바쁜 네트워크 관리자에게는 읽기 쉬운 규칙 집합이 더 안전한 규칙 집합"
"입니다.  이 섹션의 나머지 부분에서는 가독성을 위해 규칙을 가능한 한 단순하게 "
"유지하는 방법을 설명합니다.  예를 들어 두 개의 규칙을 하나의 규칙으로 대체할 "
"수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:417
#, no-wrap
msgid "pass from xl1:network to any port $ports keep state\n"
msgstr "pass from xl1:network to any port $ports keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:422
msgid ""
"The `interface:network` notation can be replaced with a macro to make the "
"ruleset even more readable.  For example, a `$localnet` macro could be "
"defined as the network directly attached to the internal interface (`$xl1:"
"network`).  Alternatively, the definition of `$localnet` could be changed to "
"an _IP address/netmask_ notation to denote a network, such as "
"`192.168.100.1/24` for a subnet of private addresses."
msgstr ""
"`인터페이스:네트워크` 표기법을 매크로로 대체하여 규칙 집합을 더욱 읽기 쉽게 "
"만들 수 있습니다.  예를 들어, `$localnet` 매크로는 내부 인터페이스에 직접 연"
"결된 네트워크( `$xl1:network` )로 정의할 수 있습니다.  또는 `$localnet` 의 정"
"의를 _IP 주소/넷마스크_ 표기법으로 변경하여 사설 주소 서브넷의 경우 "
"`192.168.100.1/24` 와 같이 네트워크를 나타낼 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:425
msgid ""
"If required, `$localnet` could even be defined as a list of networks.  "
"Whatever the specific needs, a sensible `$localnet` definition could be used "
"in a typical pass rule as follows:"
msgstr ""
"필요한 경우 `$localnet` 을 네트워크 목록으로 정의할 수도 있습니다.  구체적인 "
"요구 사항이 무엇이든, 다음과 같이 일반적인 통과 규칙에 합리적인 `$localnet` "
"정의를 사용할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:429
#, no-wrap
msgid "pass from $localnet to any port $ports keep state\n"
msgstr "pass from $localnet to any port $ports keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:433
msgid ""
"The following sample ruleset allows all traffic initiated by machines on the "
"internal network.  It first defines two macros to represent the external and "
"internal 3COM interfaces of the gateway."
msgstr ""
"다음 샘플 규칙 세트는 내부 네트워크의 머신에서 시작된 모든 트래픽을 허용합니"
"다.  먼저 게이트웨이의 외부 및 내부 3COM 인터페이스를 나타내는 두 개의 매크로"
"를 정의합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:438
msgid ""
"For dialup users, the external interface will use [.filename]#tun0#.  For an "
"ADSL connection, specifically those using PPP over Ethernet (PPPoE), the "
"correct external interface is [.filename]#tun0#, not the physical Ethernet "
"interface."
msgstr ""
"전화 접속 사용자의 경우 외부 인터페이스는 [.filename]#tun0# 을 사용합니다.  "
"ADSL 연결, 특히 PPPoE(PPP를 통한 이더넷)를 사용하는 연결의 경우 올바른 외부 "
"인터페이스는 물리적 이더넷 인터페이스가 아닌 [.filename]#tun0# 입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:449
#, no-wrap
msgid ""
"ext_if = \"xl0\"\t# macro for external interface - use tun0 for PPPoE\n"
"int_if = \"xl1\"\t# macro for internal interface\n"
"localnet = $int_if:network\n"
"# ext_if IP address could be dynamic, hence ($ext_if)\n"
"nat on $ext_if from $localnet to any -> ($ext_if)\n"
"block all\n"
"pass from { lo0, $localnet } to any keep state\n"
msgstr ""
"ext_if = \"xl0\"\t# macro for external interface - use tun0 for PPPoE\n"
"int_if = \"xl1\"\t# macro for internal interface\n"
"localnet = $int_if:network\n"
"# ext_if IP address could be dynamic, hence ($ext_if)\n"
"nat on $ext_if from $localnet to any -> ($ext_if)\n"
"block all\n"
"pass from { lo0, $localnet } to any keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:454
msgid ""
"This ruleset introduces the `nat` rule which is used to handle the network "
"address translation from the non-routable addresses inside the internal "
"network to the IP address assigned to the external interface.  The "
"parentheses surrounding the last part of the nat rule `($ext_if)` is "
"included when the IP address of the external interface is dynamically "
"assigned.  It ensures that network traffic runs without serious "
"interruptions even if the external IP address changes."
msgstr ""
"이 규칙 집합은 내부 네트워크에서 내부 주소로 라우팅할 수 없는, 주소에서 외부 "
"인터페이스에 할당된 IP 주소로 네트워크 주소 변환을 처리하는 데 사용되는 "
"`nat` 규칙을 소개합니다.  nat 규칙의 마지막 부분인 `($ext_if)` 를 둘러싼 괄호"
"는 외부 인터페이스의 IP 주소가 동적으로 할당될 때 포함됩니다.  외부 IP 주소"
"가 변경되더라도 네트워크 트래픽이 심각한 중단 없이 실행되도록 보장합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:457
msgid ""
"Note that this ruleset probably allows more traffic to pass out of the "
"network than is needed.  One reasonable setup could create this macro:"
msgstr ""
"이 규칙 집합은 아마도 필요한 것보다 더 많은 트래픽이 네트워크 외부로 전달되도"
"록 허용할 수 있습니다.  합리적인 설정으로 이 매크로를 만들 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:462
#, no-wrap
msgid ""
"client_out = \"{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \\\n"
"    https, cvspserver, 2628, 5999, 8000, 8080 }\"\n"
msgstr ""
"client_out = \"{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \\\n"
"    https, cvspserver, 2628, 5999, 8000, 8080 }\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:465
msgid "to use in the main pass rule:"
msgstr "메인 패스 규칙에 사용하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:470
#, no-wrap
msgid ""
"pass inet proto tcp from $localnet to any port $client_out \\\n"
"    flags S/SA keep state\n"
msgstr ""
"pass inet proto tcp from $localnet to any port $client_out \\\n"
"    flags S/SA keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:474
msgid ""
"A few other pass rules may be needed.  This one enables SSH on the external "
"interface:"
msgstr ""
"몇 가지 다른 통과 규칙이 필요할 수 있습니다.  이 규칙은 외부 인터페이스에서 "
"SSH를 사용하도록 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:478
#, no-wrap
msgid "pass in inet proto tcp to $ext_if port ssh\n"
msgstr "pass in inet proto tcp to $ext_if port ssh\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:481
msgid "This macro definition and rule allows DNS and NTP for internal clients:"
msgstr ""
"이 매크로 정의 및 규칙은 내부 클라이언트에 대한 DNS 및 NTP를 허용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:486
#, no-wrap
msgid ""
"udp_services = \"{ domain, ntp }\"\n"
"pass quick inet proto { tcp, udp } to any port $udp_services keep state\n"
msgstr ""
"udp_services = \"{ domain, ntp }\"\n"
"pass quick inet proto { tcp, udp } to any port $udp_services keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:494
msgid ""
"Note the `quick` keyword in this rule.  Since the ruleset consists of "
"several rules, it is important to understand the relationships between the "
"rules in a ruleset.  Rules are evaluated from top to bottom, in the sequence "
"they are written.  For each packet or connection evaluated by PF, _the last "
"matching rule_ in the ruleset is the one which is applied.  However, when a "
"packet matches a rule which contains the `quick` keyword, the rule "
"processing stops and the packet is treated according to that rule.  This is "
"very useful when an exception to the general rules is needed."
msgstr ""
"이 규칙의 ‘quick’ 키워드에 주목하세요.  규칙 집합은 여러 규칙으로 구성되므로 "
"규칙 집합의 규칙 간의 관계를 이해하는 것이 중요합니다.  규칙은 작성된 순서대"
"로 위에서 아래로 평가됩니다.  PF가 평가하는 각 패킷 또는 연결에 대해, 규칙 세"
"트에서 _마지막으로 일치하는 규칙이 적용_ 됩니다.  그러나 패킷이 ‘quick’ 키워"
"드가 포함된 규칙과 일치하면 규칙 처리가 중지되고 해당 규칙에 따라 패킷이 처리"
"됩니다.  이 기능은 일반 규칙에 대한 예외가 필요할 때 매우 유용합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:496
#, no-wrap
msgid "Creating an FTP Proxy"
msgstr "FTP 프록시 생성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:501
msgid ""
"Configuring working FTP rules can be problematic due to the nature of the "
"FTP protocol.  FTP pre-dates firewalls by several decades and is insecure in "
"its design.  The most common points against using FTP include:"
msgstr ""
"FTP 프로토콜의 특성으로 인해 동작중인 FTP 규칙을 구성하는 것은 문제가 될 수 "
"있습니다.  FTP는 방화벽보다 수십 년 전의 것으로, 설계상 안전하지 않습니다.  "
"FTP 사용에 반대하는 가장 일반적인 이유는 다음과 같습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:503
msgid "Passwords are transferred in the clear."
msgstr "비밀번호가 투명하게 전송됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:504
msgid ""
"The protocol demands the use of at least two TCP connections (control and "
"data) on separate ports."
msgstr ""
"이 프로토콜은 별도의 포트에서 최소 두 개의 TCP 연결(제어 및 데이터)을 사용하"
"도록 요구합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:505
msgid ""
"When a session is established, data is communicated using randomly selected "
"ports."
msgstr "세션이 설정되면 무작위로 선택된 포트를 사용하여 데이터가 통신됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:508
msgid ""
"All of these points present security challenges, even before considering any "
"potential security weaknesses in client or server software.  More secure "
"alternatives for file transfer exist, such as man:sftp[1] or man:scp[1], "
"which both feature authentication and data transfer over encrypted "
"connections."
msgstr ""
"클라이언트 또는 서버 소프트웨어의 잠재적인 보안 취약점을 고려하기 전에도 이러"
"한 모든 점은 보안 문제를 야기합니다.  암호화된 연결을 통한 인증 및 데이터 전"
"송 기능을 모두 갖춘 man:sftp[1] 또는 man:scp[1]와 같은 보다 안전한 파일 전송 "
"대안이 존재합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:511
msgid ""
"For those situations when FTP is required, PF provides redirection of FTP "
"traffic to a small proxy program called man:ftp-proxy[8], which is included "
"in the base system of FreeBSD.  The role of the proxy is to dynamically "
"insert and delete rules in the ruleset, using a set of anchors, to correctly "
"handle FTP traffic."
msgstr ""
"FTP가 필요한 상황을 위해, PF는 FreeBSD의 기본 시스템에 포함되어 있는 man:ftp-"
"proxy[8]라는 작은 프록시 프로그램으로 FTP 트래픽을 리디렉션합니다.  프록시의 "
"역할은 일련의 앵커를 사용하여 규칙 집합에 규칙을 동적으로 삽입 및 삭제하여 "
"FTP 트래픽을 올바르게 처리하는 것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:513
msgid "To enable the FTP proxy, add this line to [.filename]#/etc/rc.conf#:"
msgstr ""
"FTP 프록시를 사용하려면 [.filename]#/etc/rc.conf# 에 이 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:517
#, no-wrap
msgid "ftpproxy_enable=\"YES\"\n"
msgstr "ftpproxy_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:520
msgid "Then start the proxy by running:"
msgstr "그런 다음 프록시를 실행하여 시작하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:524
#, no-wrap
msgid "# service ftp-proxy start\n"
msgstr "# service ftp-proxy start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:528
msgid ""
"For a basic configuration, three elements need to be added to [.filename]#/"
"etc/pf.conf#.  First, the anchors which the proxy will use to insert the "
"rules it generates for the FTP sessions:"
msgstr ""
"기본 구성의 경우 [.filename]#/etc/pf.conf# 에 세 가지 요소를 추가해야 합니"
"다.  첫째, 프록시가 FTP 세션에 대해 생성하는 규칙을 삽입하는 데 사용할 앵커입"
"니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:533
#, no-wrap
msgid ""
"nat-anchor \"ftp-proxy/*\"\n"
"rdr-anchor \"ftp-proxy/*\"\n"
msgstr ""
"nat-anchor \"ftp-proxy/*\"\n"
"rdr-anchor \"ftp-proxy/*\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:536
msgid "Second, a pass rule is needed to allow FTP traffic in to the proxy."
msgstr ""
"둘째, 프록시로 들어오는 FTP 트래픽을 허용하려면 통과 규칙이 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:539
msgid ""
"Third, redirection and NAT rules need to be defined before the filtering "
"rules.  Insert this `rdr` rule immediately after the `nat` rule:"
msgstr ""
"셋째, 리디렉션 및 NAT 규칙은 필터링 규칙보다 먼저 정의해야 합니다.  이 `rdr` "
"규칙을 `nat` 규칙 바로 뒤에 삽입하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:543
#, no-wrap
msgid "rdr pass on $int_if proto tcp from any to any port ftp -> 127.0.0.1 port 8021\n"
msgstr "rdr pass on $int_if proto tcp from any to any port ftp -> 127.0.0.1 port 8021\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:546
msgid "Finally, allow the redirected traffic to pass:"
msgstr "마지막으로 리디렉션된 트래픽이 통과할 수 있도록 허용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:550
#, no-wrap
msgid "pass out proto tcp from $proxy to any port ftp\n"
msgstr "pass out proto tcp from $proxy to any port ftp\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:553
msgid "where `$proxy` expands to the address the proxy daemon is bound to."
msgstr "여기서 `$proxy` 는 프록시 데몬이 바인딩된 주소로 확장됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:555
msgid ""
"Save [.filename]#/etc/pf.conf#, load the new rules, and verify from a client "
"that FTP connections are working:"
msgstr ""
"[.filename]#/etc/pf.conf# 을 저장하고 새 규칙을 로드한 다음 클라이언트에서 "
"FTP 연결이 작동하는지 확인합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:565
msgid ""
"This example covers a basic setup where the clients in the local network "
"need to contact FTP servers elsewhere.  This basic configuration should work "
"well with most combinations of FTP clients and servers.  As shown in man:ftp-"
"proxy[8], the proxy's behavior can be changed in various ways by adding "
"options to the `ftpproxy_flags=` line.  Some clients or servers may have "
"specific quirks that must be compensated for in the configuration, or there "
"may be a need to integrate the proxy in specific ways such as assigning FTP "
"traffic to a specific queue."
msgstr ""
"이 예에서는 로컬 네트워크의 클라이언트가 다른 곳의 FTP 서버에 연결해야 하는 "
"기본 설정에 대해 설명합니다.  이 기본 구성은 대부분의 FTP 클라이언트와 서버 "
"조합에서 잘 작동합니다.  man:ftp-proxy[8]에 표시된 것처럼 `ftpproxy_flags=` "
"줄에 옵션을 추가하여 프록시 동작을 다양한 방식으로 변경할 수 있습니다.  일부 "
"클라이언트 또는 서버에는 구성에서 보완해야 하는 몇가지 단점이 있거나 특정 대"
"기열에 FTP 트래픽을 할당하는 등, 특정 방식으로 프록시를 통합해야 할 필요가 있"
"을 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:567
msgid ""
"For ways to run an FTP server protected by PF and man:ftp-proxy[8], "
"configure a separate `ftp-proxy` in reverse mode, using `-R`, on a separate "
"port with its own redirecting pass rule."
msgstr ""
"PF 및 man:ftp-proxy[8]로 보호되는 FTP 서버를 실행하는 방법은 자체 리디렉션 통"
"과 규칙이 있는 별도의 포트에 `-R` 을 사용하여 역방향 모드에서 별도의 `ftp-"
"proxy` 를 구성합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:569
#, no-wrap
msgid "Managing ICMP"
msgstr "ICMP 관리하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:572
msgid ""
"Many of the tools used for debugging or troubleshooting a TCP/IP network "
"rely on the Internet Control Message Protocol (ICMP), which was designed "
"specifically with debugging in mind."
msgstr ""
"TCP/IP 네트워크의 디버깅 또는 문제 해결에 사용되는 많은 도구는 디버깅을 염두"
"에 두고 특별히 설계된 인터넷 제어 메시지 프로토콜(ICMP)에 의존합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:575
msgid ""
"The ICMP protocol sends and receives _control messages_ between hosts and "
"gateways, mainly to provide feedback to a sender about any unusual or "
"difficult conditions enroute to the target host.  Routers use ICMP to "
"negotiate packet sizes and other transmission parameters in a process often "
"referred to as _path MTU discovery_."
msgstr ""
"ICMP 프로토콜은 호스트와 게이트웨이 간에 _제어 메시지_ 를 송수신하며, 주로 대"
"상 호스트로 전송되는 도중 비정상적이거나 어려운 조건에 대한 피드백을 발신자에"
"게 제공하기 위해 사용됩니다.  라우터는 ICMP를 사용하여 패킷 크기 및 기타 전"
"송 매개변수를 협상하는데, 이를 흔히 _경로 MTU 검색 (Path MTU discorvery)_ 이"
"라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:579
msgid ""
"From a firewall perspective, some ICMP control messages are vulnerable to "
"known attack vectors.  Also, letting all diagnostic traffic pass "
"unconditionally makes debugging easier, but it also makes it easier for "
"others to extract information about the network.  For these reasons, the "
"following rule may not be optimal:"
msgstr ""
"방화벽 관점에서 볼 때, 일부 ICMP 제어 메시지는 알려진 공격 벡터에 취약합니"
"다.  또한 모든 진단 트래픽을 무조건 통과시키면 디버깅이 더 쉬워지지만 다른 사"
"람이 네트워크에 대한 정보를 더 쉽게 추출할 수 있습니다.  이러한 이유로 다음 "
"규칙은 최적이 아닐 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:583
#, no-wrap
msgid "pass inet proto icmp from any to any\n"
msgstr "pass inet proto icmp from any to any\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:586
msgid ""
"One solution is to let all ICMP traffic from the local network through while "
"stopping all probes from outside the network:"
msgstr ""
"한 가지 해결책은 로컬 네트워크의 모든 ICMP 트래픽을 통과시키면서 네트워크 외"
"부의 모든 프로브를 차단하는 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:591
#, no-wrap
msgid ""
"pass inet proto icmp from $localnet to any keep state\n"
"pass inet proto icmp from any to $ext_if keep state\n"
msgstr ""
"pass inet proto icmp from $localnet to any keep state\n"
"pass inet proto icmp from any to $ext_if keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:596
msgid ""
"Additional options are available which demonstrate some of PF's "
"flexibility.  For example, rather than allowing all ICMP messages, one can "
"specify the messages used by man:ping[8] and man:traceroute[8].  Start by "
"defining a macro for that type of message:"
msgstr ""
"PF의 유연성을 보여주는 추가 옵션을 사용할 수 있습니다.  예를 들어, 모든 ICMP "
"메시지를 허용하는 대신 man:ping[8] 및 man:traceroute[8]에서 사용하는 메시지"
"를 지정할 수 있습니다.  먼저 해당 메시지 유형에 대한 매크로를 정의합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:600
#, no-wrap
msgid "icmp_types = \"echoreq\"\n"
msgstr "icmp_types = \"echoreq\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:603
msgid "and a rule which uses the macro:"
msgstr "그리고 매크로를 사용할 규칙을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:607
#: documentation/content/en/books/handbook/firewalls/_index.adoc:647
#, no-wrap
msgid "pass inet proto icmp all icmp-type $icmp_types keep state\n"
msgstr "pass inet proto icmp all icmp-type $icmp_types keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:612
msgid ""
"If other types of ICMP packets are needed, expand `icmp_types` to a list of "
"those packet types.  Type `more /usr/src/sbin/pfctl/pfctl_parser.c` to see "
"the list of ICMP message types supported by PF.  Refer to http://www.iana."
"org/assignments/icmp-parameters/icmp-parameters.xhtml[http://www.iana.org/"
"assignments/icmp-parameters/icmp-parameters.xhtml] for an explanation of "
"each message type."
msgstr ""
"다른 유형의 ICMP 패킷이 필요한 경우 `icmp_types` 를 확장하여 해당 패킷 유형 "
"목록을 표시합니다.  `more /usr/src/sbin/pfctl/pfctl_parser.c` 를 입력하면 PF"
"에서 지원하는 ICMP 메시지 유형 목록을 볼 수 있습니다.  각 메시지 유형에 대한 "
"설명은 http://www.iana.org/assignments/icmp-parameters/icmp-parameters."
"xhtml[http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml]"
"를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:614
msgid ""
"Since Unix `traceroute` uses UDP by default, another rule is needed to allow "
"Unix `traceroute`:"
msgstr ""
"유닉스 `traceroute` 는 기본적으로 UDP를 사용하므로 유닉스 `traceroute` 를 허"
"용하려면 다른 규칙이 필요합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:619
#, no-wrap
msgid ""
"# allow out the default range for traceroute(8):\n"
"pass out on $ext_if inet proto udp from any to any port 33433 >< 33626 keep state\n"
msgstr ""
"# allow out the default range for traceroute(8):\n"
"pass out on $ext_if inet proto udp from any to any port 33433 >< 33626 keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:624
msgid ""
"Since `TRACERT.EXE` on Microsoft Windows systems uses ICMP echo request "
"messages, only the first rule is needed to allow network traces from those "
"systems.  Unix `traceroute` can be instructed to use other protocols as "
"well, and will use ICMP echo request messages if `-I` is used.  Check the "
"man:traceroute[8] man page for details."
msgstr ""
"Microsoft Windows 시스템의 `TRACERT.EXE` 는 ICMP 에코 요청 메시지를 사용하므"
"로, 해당 시스템에서 네트워크 추적을 허용하려면 첫 번째 규칙만 필요합니다.  유"
"닉스 `traceroute` 는 다른 프로토콜도 사용하도록 지시할 수 있으며, `-I` 가 사"
"용되는 경우 ICMP 에코 요청 메시지를 사용합니다.  자세한 내용은 man:"
"traceroute[8] 매뉴얼 페이지를 참조하세요."

#. type: Title =====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:626
#, no-wrap
msgid "Path MTU Discovery"
msgstr "경로 MTU 검색 (Path MTU Discovery)"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:631
msgid ""
"Internet protocols are designed to be device independent, and one "
"consequence of device independence is that the optimal packet size for a "
"given connection cannot always be predicted reliably.  The main constraint "
"on packet size is the _Maximum Transmission Unit_ (MTU) which sets the upper "
"limit on the packet size for an interface.  Type `ifconfig` to view the MTUs "
"for a system's network interfaces."
msgstr ""
"인터넷 프로토콜은 디바이스 독립적으로 설계되었으며, 디바이스 독립성의 결과는 "
"특정 연결에 대한 최적의 패킷 크기를 항상 안정적으로 예측할 수 없다는 것입니"
"다.  패킷 크기에 대한 주요 제약 조건은 인터페이스의 패킷 크기에 대한 상한을 "
"설정하는 _최대 전송 단위_ (Max Tranmission Unit, MTU)입니다.  시스템 네트워"
"크 인터페이스의 MTU를 보려면 `ifconfig` 를 입력하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:636
msgid ""
"TCP/IP uses a process known as path MTU discovery to determine the right "
"packet size for a connection.  This process sends packets of varying sizes "
"with the \"Do not fragment\" flag set, expecting an ICMP return packet of "
"\"type 3, code 4\" when the upper limit has been reached.  Type 3 means "
"\"destination unreachable\", and code 4 is short for \"fragmentation needed, "
"but the do-not-fragment flag is set\".  To allow path MTU discovery in order "
"to support connections to other MTUs, add the `destination unreachable` type "
"to the `icmp_types` macro:"
msgstr ""
"TCP/IP는 경로 MTU 검색이라는 프로세스를 사용하여 연결에 적합한 패킷 크기를 결"
"정합니다.  이 프로세스는 상한에 도달하면 “type 3, code 4”의 ICMP 반환 패킷을 "
"예상하여 “조각화 안 함(Do not fragment)” 플래그가 설정된 다양한 크기의 패킷"
"을 전송합니다.  Type 3는 “대상에 연결할 수 없음”을 의미하며 Code 4는 “조각화"
"가 필요하지만 조각화 금지 플래그가 설정되어 있음”의 줄임말입니다.  다른 MTU"
"에 대한 연결을 지원하기 위해 경로 MTU 검색을 허용하려면 `대상에 연결할 수 없"
"음(destination unreachable)` 유형을 `icmp_types` 매크로에 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:640
#, no-wrap
msgid "icmp_types = \"{ echoreq, unreach }\"\n"
msgstr "icmp_types = \"{ echoreq, unreach }\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:643
msgid ""
"Since the pass rule already uses that macro, it does not need to be modified "
"to support the new ICMP type:"
msgstr ""
"통과 규칙은 이미 해당 매크로를 사용하고 있으므로 새 ICMP 유형을 지원하기 위"
"해 수정할 필요가 없습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:651
msgid ""
"PF allows filtering on all variations of ICMP types and codes.  The list of "
"possible types and codes are documented in man:icmp[4] and man:icmp6[4]."
msgstr ""
"PF는 모든 변형 ICMP 유형과 코드에 대한 필터링을 허용합니다.  가능한 유형과 코"
"드 목록은 man:icmp[4] 및 man:icmp6[4]에 문서화되어 있습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:653
#, no-wrap
msgid "Using Tables"
msgstr "테이블 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:658
msgid ""
"Some types of data are relevant to filtering and redirection at a given "
"time, but their definition is too long to be included in the ruleset file.  "
"PF supports the use of tables, which are defined lists that can be "
"manipulated without needing to reload the entire ruleset, and which can "
"provide fast lookups.  Table names are always enclosed within `< >`, like "
"this:"
msgstr ""
"일부 데이터 유형은 특정 시점에 필터링 및 리디렉션과 관련이 있지만, 그 정의가 "
"너무 길어 규칙 집합 파일에 포함하기에는 무리가 있습니다.  PF는 전체 규칙 집합"
"을 다시 로드할 필요 없이, 변경 및 빠른 조회를 제공하는 테이블 사용을 지원합니"
"다.  테이블 이름은 항상 다음과 같이 `< >` 로 묶습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:662
#, no-wrap
msgid "table <clients> { 192.168.2.0/24, !192.168.2.5 }\n"
msgstr "table <clients> { 192.168.2.0/24, !192.168.2.5 }\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:666
msgid ""
"In this example, the `192.168.2.0/24` network is part of the table, except "
"for the address `192.168.2.5`, which is excluded using the `!` operator.  It "
"is also possible to load tables from files where each item is on a separate "
"line, as seen in this example [.filename]#/etc/clients#:"
msgstr ""
"이 예에서 `192.168.2.0/24` 네트워크는 `!` 연산자를 사용하여 제외된 주소 "
"`192.168.2.5` 를 제외하고는 테이블의 일부입니다.  이 예제 [.filename]#/etc/"
"clients# 에서 볼 수 있듯이 각 항목이 별도의 줄에 있는 파일에서 테이블을 로드"
"할 수도 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:671
#, no-wrap
msgid ""
"192.168.2.0/24\n"
"!192.168.2.5\n"
msgstr ""
"192.168.2.0/24\n"
"!192.168.2.5\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:674
msgid "To refer to the file, define the table like this:"
msgstr "파일을 참조하려면 다음과 같이 테이블을 정의합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:678
#, no-wrap
msgid "table <clients> persist file \"/etc/clients\"\n"
msgstr "table <clients> persist file \"/etc/clients\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:681
msgid "Once the table is defined, it can be referenced by a rule:"
msgstr "테이블이 정의되면 규칙에서 참조할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:685
#, no-wrap
msgid "pass inet proto tcp from <clients> to any port $client_out flags S/SA keep state\n"
msgstr "pass inet proto tcp from <clients> to any port $client_out flags S/SA keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:689
msgid ""
"A table's contents can be manipulated live, using `pfctl`.  This example "
"adds another network to the table:"
msgstr ""
"테이블의 내용은 `pfctl` 을 사용하여 실시간으로 조작할 수 있습니다.  이 예제"
"는 테이블에 다른 네트워크를 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:693
#, no-wrap
msgid "# pfctl -t clients -T add 192.168.1.0/16\n"
msgstr "# pfctl -t clients -T add 192.168.1.0/16\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:699
msgid ""
"Note that any changes made this way will take affect now, making them ideal "
"for testing, but will not survive a power failure or reboot.  To make the "
"changes permanent, modify the definition of the table in the ruleset or edit "
"the file that the table refers to.  One can maintain the on-disk copy of the "
"table using a man:cron[8] job which dumps the table's contents to disk at "
"regular intervals, using a command such as `pfctl -t clients -T show >/etc/"
"clients`.  Alternatively, [.filename]#/etc/clients# can be updated with the "
"in-memory table contents:"
msgstr ""
"이 방법으로 변경한 내용은 지금 바로 적용되므로 테스트에 적합하지만 정전이나 "
"재부팅 시에는 적용되지 않습니다.  변경 사항을 영구적으로 적용하려면 규칙 집합"
"에서 테이블의 정의를 수정하거나 테이블이 참조하는 파일을 편집하세요.  정기적"
"으로 테이블의 내용을 디스크에 덤프하는 man:cron[8] 작업을 사용하여 테이블의 "
"복사본을 유지 관리할 수 있으며, `pfctl -t clients -T show >/etc/clients` 와 "
"같은 명령을 사용할 수도 있습니다.  또는 [.filename]#/etc/clients# 를 인메모"
"리 테이블 내용으로 업데이트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:703
#, no-wrap
msgid "# pfctl -t clients -T replace -f /etc/clients\n"
msgstr "# pfctl -t clients -T replace -f /etc/clients\n"

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:706
#, no-wrap
msgid "Using Overload Tables to Protect SSH"
msgstr "과부하 테이블(Overload Table)을 사용하여 SSH 보호하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:709
msgid ""
"Those who run SSH on an external interface have probably seen something like "
"this in the authentication logs:"
msgstr ""
"외부 인터페이스에서 SSH를 실행하는 사용자는 인증 로그에서 이와 같은 내용을 "
"본 적이 있을 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:718
#, no-wrap
msgid ""
"Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2\n"
"Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2\n"
"Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye\n"
"Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31\n"
"Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin\n"
"Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2\n"
msgstr ""
"Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2\n"
"Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2\n"
"Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye\n"
"Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31\n"
"Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin\n"
"Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:721
msgid ""
"This is indicative of a brute force attack where somebody or some program is "
"trying to discover the user name and password which will let them into the "
"system."
msgstr ""
"이는 누군가 또는 어떤 프로그램이 사용자 이름과 비밀번호를 알아내어 시스템에 "
"침입하려는 무차별 대입 공격(Brute force attack)을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:726
msgid ""
"If external SSH access is needed for legitimate users, changing the default "
"port used by SSH can offer some protection.  However, PF provides a more "
"elegant solution.  Pass rules can contain limits on what connecting hosts "
"can do and violators can be banished to a table of addresses which are "
"denied some or all access.  It is even possible to drop all existing "
"connections from machines which overreach the limits."
msgstr ""
"합법적인 사용자를 위해 외부 SSH 액세스가 필요한 경우, SSH에서 사용하는 기본 "
"포트를 변경하면 어느 정도 보호할 수 있습니다.  하지만 PF는 보다 우아한 솔루션"
"을 제공합니다.  패스 규칙에는 연결 호스트가 수행할 수 있는 작업에 대한 제한"
"이 포함될 수 있으며, 이를 위반하는 호스트는 일부 또는 모든 액세스가 거부되는 "
"주소 테이블로 추방될 수 있습니다.  심지어 한도를 초과하는 컴퓨터에서 기존 연"
"결을 모두 끊을 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:728
msgid ""
"To configure this, create this table in the tables section of the ruleset:"
msgstr "이를 구성하려면 규칙 집합의 테이블 섹션에서 다음 테이블을 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:732
#, no-wrap
msgid "table <bruteforce> persist\n"
msgstr "table <bruteforce> persist\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:735
msgid ""
"Then, somewhere early in the ruleset, add rules to block brute access while "
"allowing legitimate access:"
msgstr ""
"그런 다음 규칙 집합의 앞부분 어딘가에 합법적인 액세스는 허용하면서 무차별 액"
"세스를 차단하는 규칙을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:743
#, no-wrap
msgid ""
"block quick from <bruteforce>\n"
"pass inet proto tcp from any to $localnet port $tcp_services \\\n"
"    flags S/SA keep state \\\n"
"    (max-src-conn 100, max-src-conn-rate 15/5, \\\n"
"    overload <bruteforce> flush global)\n"
msgstr ""
"block quick from <bruteforce>\n"
"pass inet proto tcp from any to $localnet port $tcp_services \\\n"
"    flags S/SA keep state \\\n"
"    (max-src-conn 100, max-src-conn-rate 15/5, \\\n"
"    overload <bruteforce> flush global)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:747
msgid ""
"The part in parentheses defines the limits and the numbers should be changed "
"to meet local requirements.  It can be read as follows:"
msgstr ""
"괄호 안의 부분은 한도를 정의하며 로컬 네트워크 요구사항에 맞게 숫자를 변경해"
"야 합니다.  다음과 같이 읽을 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:749
msgid ""
"`max-src-conn` is the number of simultaneous connections allowed from one "
"host."
msgstr "`max-src-conn` 은 한 호스트에서 허용되는 동시 연결 수입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:751
msgid ""
"`max-src-conn-rate` is the rate of new connections allowed from any single "
"host (_15_) per number of seconds (_5_)."
msgstr ""
"`max-src-conn-rate` 는 초( _5_ ) 당 단일 호스트( _15_ )에서 허용되는 새 연결"
"의 비율입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:754
msgid ""
"`overload <bruteforce>` means that any host which exceeds these limits gets "
"its address added to the `bruteforce` table.  The ruleset blocks all traffic "
"from addresses in the `bruteforce` table."
msgstr ""
"`overload <bruteforce>` 는 이 제한을 초과하는 모든 호스트의 주소가 "
"`bruteforce` 테이블에 추가됨을 의미합니다.  이 규칙 집합은 `bruteforce` 테이"
"블에 있는 주소로부터의 모든 트래픽을 차단합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:756
msgid ""
"Finally, `flush global` says that when a host reaches the limit, that all "
"(`global`) of that host's connections will be terminated (`flush`)."
msgstr ""
"마지막으로, `flush global` 은 호스트가 한도에 도달하면 해당 호스트의 모든"
"( `global` ) 연결이 종료( `flush` )되는 것을 말합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:760
msgid ""
"These rules will _not_ block slow bruteforcers, as described in http://home."
"nuug.no/\\~peter/hailmary2013/[http://home.nuug.no/~peter/hailmary2013/]."
msgstr ""
"이 규칙은 http://home.nuug.no/\\~peter/hailmary2013/[http://home.nuug.no/"
"~peter/hailmary2013/]에 설명된 것처럼 느린 bruteforce 공격을 _차단하지_ 않습"
"니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:764
msgid ""
"This example ruleset is intended mainly as an illustration.  For example, if "
"a generous number of connections in general are wanted, but the desire is to "
"be more restrictive when it comes to ssh, supplement the rule above with "
"something like the one below, early on in the rule set:"
msgstr ""
"이 예제 규칙 집합은 주로 설명을 위한 것입니다.  예를 들어, 일반적으로 많은 수"
"의 연결을 허용하고 싶지만 ssh에 대해서는 더 제한적으로 허용하고 싶은 경우 규"
"칙 집합 앞부분에 위 규칙을 아래와 같이 보완합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:771
#, no-wrap
msgid ""
"pass quick proto { tcp, udp } from any to any port ssh \\\n"
"    flags S/SA keep state \\\n"
"    (max-src-conn 15, max-src-conn-rate 5/3, \\\n"
"    overload <bruteforce> flush global)\n"
msgstr ""
"pass quick proto { tcp, udp } from any to any port ssh \\\n"
"    flags S/SA keep state \\\n"
"    (max-src-conn 15, max-src-conn-rate 5/3, \\\n"
"    overload <bruteforce> flush global)\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:776
#, no-wrap
msgid "*It May Not be Necessary to Block All Overloaders:* +\n"
msgstr "*모든 오버로드를 차단할 필요는 없을 수도 있습니다:* +\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:778
msgid ""
"It is worth noting that the overload mechanism is a general technique which "
"does not apply exclusively to SSH, and it is not always optimal to entirely "
"block all traffic from offenders."
msgstr ""
"과부하 메커니즘은 SSH에만 적용되는 것이 아닌 일반적인 기술이며, 공격자의 모"
"든 트래픽을 완전히 차단하는 것이 항상 최선은 아니라는 점에 유의할 필요가 있습"
"니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:780
msgid ""
"For example, an overload rule could be used to protect a mail service or a "
"web service, and the overload table could be used in a rule to assign "
"offenders to a queue with a minimal bandwidth allocation or to redirect to a "
"specific web page."
msgstr ""
"예를 들어, 과부하 규칙을 사용하여 메일 서비스 또는 웹 서비스를 보호하고, 과부"
"하 테이블을 규칙에 사용하여 최소 대역폭 할당으로 위반자를 대기열에 할당하거"
"나 특정 웹 페이지로 리디렉션하는 데 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:784
msgid ""
"Over time, tables will be filled by overload rules and their size will grow "
"incrementally, taking up more memory.  Sometimes an IP address that is "
"blocked is a dynamically assigned one, which has since been assigned to a "
"host who has a legitimate reason to communicate with hosts in the local "
"network."
msgstr ""
"시간이 지남에 따라 테이블은 과부하 규칙에 의해 채워지고 크기가 점점 커져 더 "
"많은 메모리를 차지하게 됩니다.  차단된 IP 주소는 로컬 네트워크의 호스트와 통"
"신할 정당한 이유가 있는 호스트에 할당된 동적으로 할당된 주소인 경우도 있습니"
"다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:787
msgid ""
"For situations like these, pfctl provides the ability to expire table "
"entries.  For example, this command will remove `<bruteforce>` table entries "
"which have not been referenced for `86400` seconds:"
msgstr ""
"이와 같은 상황에서 pfctl은 테이블 항목을 만료하는 기능을 제공합니다.  예를 들"
"어, 이 명령은 `86400` 초 동안 참조되지 않은 `<bruteforce>` 테이블 항목을 제거"
"합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:791
#, no-wrap
msgid "# pfctl -t bruteforce -T expire 86400\n"
msgstr "# pfctl -t bruteforce -T expire 86400\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:794
msgid ""
"Similar functionality is provided by package:security/expiretable[], which "
"removes table entries which have not been accessed for a specified period of "
"time."
msgstr ""
"지정된 기간 동안 액세스하지 않은 테이블 항목을 제거하는 package:security/"
"expiretable[]도 비슷한 기능을 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:797
msgid ""
"Once installed, expiretable can be run to remove `<bruteforce>` table "
"entries older than a specified age.  This example removes all entries older "
"than 24 hours:"
msgstr ""
"설치가 완료되면 expiretable을 실행하여 지정된 기간보다 오래된 `<bruteforce>` "
"테이블 항목을 제거할 수 있습니다.  이 예에서는 24시간이 지난 모든 항목을 제거"
"합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:801
#, no-wrap
msgid "/usr/local/sbin/expiretable -v -d -t 24h bruteforce\n"
msgstr "/usr/local/sbin/expiretable -v -d -t 24h bruteforce\n"

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:804
#, no-wrap
msgid "Protecting Against SPAM"
msgstr "스팸으로부터 보호하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:808
msgid ""
"Not to be confused with the spamd daemon which comes bundled with "
"spamassassin, package:mail/spamd[] can be configured with PF to provide an "
"outer defense against SPAM.  This spamd hooks into the PF configuration "
"using a set of redirections."
msgstr ""
"스팸어쌔신과 함께 번들로 제공되는 spamd 데몬과 혼동하지 않도록 패키지:mail/"
"spamd[]를 PF로 구성하여 스팸에 대한 외부 방어 기능을 제공할 수 있습니다.  이 "
"spamd는 일련의 리디렉션을 사용하여 PF 구성에 연결됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:810
msgid ""
"Spammers tend to send a large number of messages, and SPAM is mainly sent "
"from a few spammer friendly networks and a large number of hijacked "
"machines, both of which are reported to _blocklists_ fairly quickly."
msgstr ""
"스팸 발송자는 대량의 메시지를 보내는 경향이 있으며, 스팸은 주로 스팸 발송자에"
"게 우호적인 소수의 네트워크와 다수의 하이재킹된 컴퓨터에서 발송되기 때문에, "
"이 두 가지 모두 _차단 목록_ 에 상당히 빠르게 보고됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:814
msgid ""
"When an SMTP connection from an address in a blocklist is received, spamd "
"presents its banner and immediately switches to a mode where it answers SMTP "
"traffic one byte at a time.  This technique, which is intended to waste as "
"much time as possible on the spammer's end, is called _tarpitting_.  The "
"specific implementation which uses one byte SMTP replies is often referred "
"to as _stuttering_."
msgstr ""
"차단 목록에 있는 주소로부터 SMTP 연결이 수신되면 스팸 데몬(spamd)은 배너를 표"
"시하고 즉시 한 번에 한 바이트씩 SMTP 트래픽에 응답하는 모드로 전환합니다.  스"
"팸 발송자의 입장에서 최대한 많은 시간을 낭비하게 만드는 이 기법을 _타피팅"
"(tarpitting)_ 이라고 합니다.  1바이트 SMTP 회신을 사용하는 특정 구현을 종종 _"
"스터터링(stuttering)_ 이라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:817
msgid ""
"This example demonstrates the basic procedure for setting up spamd with "
"automatically updated blocklists.  Refer to the man pages which are "
"installed with package:mail/spamd[] for more information."
msgstr ""
"이 예는 자동으로 업데이트되는 차단 목록으로 스팸 차단을 설정하는 기본 절차를 "
"보여 줍니다.  자세한 내용은 package:mail/spamd[]와 함께 설치되어 있는 매뉴얼 "
"페이지를 참조하세요."

#. type: Block title
#: documentation/content/en/books/handbook/firewalls/_index.adoc:820
#, no-wrap
msgid "Procedure: Configuring spamd"
msgstr "절차: spamd 구성하기"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:822
msgid ""
"Install the package:mail/spamd[] package or port. To use spamd's greylisting "
"features, man:fdescfs[5] must be mounted at [.filename]#/dev/fd#. Add the "
"following line to [.filename]#/etc/fstab#:"
msgstr ""
"package:mail/spamd[] 패키지 또는 포트를 설치합니다. spamd의 그레이리스트 기능"
"을 사용하려면 man:fdescfs[5]를 [.filename]#/dev/fd# 에 마운트해야 합니다. 다"
"음 줄을 [.filename]#/etc/fstab# 에 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:826
#, no-wrap
msgid " fdescfs /dev/fd fdescfs rw 0 0\n"
msgstr " fdescfs /dev/fd fdescfs rw 0 0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:829
msgid "Then, mount the filesystem:"
msgstr "그리고 나서 파일 시스템을 마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:833
#, no-wrap
msgid "#  mount fdescfs\n"
msgstr "#  mount fdescfs\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:836
msgid "Next, edit the PF ruleset to include:"
msgstr "다음으로, PF 규칙세트에 아래의 내용을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:845
#, no-wrap
msgid ""
"table <spamd> persist\n"
"table <spamd-white> persist\n"
"rdr pass on $ext_if inet proto tcp from <spamd> to \\\n"
"    { $ext_if, $localnet } port smtp -> 127.0.0.1 port 8025\n"
"rdr pass on $ext_if inet proto tcp from !<spamd-white> to \\\n"
"    { $ext_if, $localnet } port smtp -> 127.0.0.1 port 8025\n"
msgstr ""
"table <spamd> persist\n"
"table <spamd-white> persist\n"
"rdr pass on $ext_if inet proto tcp from <spamd> to \\\n"
"    { $ext_if, $localnet } port smtp -> 127.0.0.1 port 8025\n"
"rdr pass on $ext_if inet proto tcp from !<spamd-white> to \\\n"
"    { $ext_if, $localnet } port smtp -> 127.0.0.1 port 8025\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:849
msgid ""
"The two tables `<spamd>` and `<spamd-white>` are essential.  SMTP traffic "
"from an address listed in `<spamd>` but not in `<spamd-white>` is redirected "
"to the spamd daemon listening at port 8025."
msgstr ""
"두 개의 테이블 `<spamd>` 와 `<spamd-white>` 는 필수입니다.  `<spamd>` 에 나열"
"되어 있지만 `<spamd-white>` 에 없는 주소로부터의 SMTP 트래픽은 포트 8025에서 "
"수신 대기 중인 spamd 데몬으로 리디렉션됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:850
msgid ""
"The next step is to configure spamd in [.filename]#/usr/local/etc/spamd."
"conf# and to add some [.filename]#rc.conf# parameters."
msgstr ""
"다음 단계는 [.filename]#/usr/local/etc/spamd.conf# 에서 spamd를 구성하고 [."
"filename]#rc.conf# 매개변수를 추가하는 것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:853
msgid ""
"The installation of package:mail/spamd[] includes a sample configuration "
"file ([.filename]#/usr/local/etc/spamd.conf.sample#) and a man page for [."
"filename]#spamd.conf#.  Refer to these for additional configuration options "
"beyond those shown in this example."
msgstr ""
"package:mail/spamd[] 설치에는 샘플 구성 파일( [.filename]#/usr/local/etc/"
"spamd.conf.sample# )과 [.filename]#spamd.conf# 에 대한 매뉴얼 페이지가 포함되"
"어 있습니다.  이 예제에 표시된 것 외에 추가 구성 옵션은 여기를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:855
msgid ""
"One of the first lines in the configuration file that does not begin with a `"
"+#+` comment sign contains the block which defines the `all` list, which "
"specifies the lists to use:"
msgstr ""
"구성 파일의 첫 번째 줄 중 `+#+` 주석 기호로 시작하지 않는 줄에는 사용할 목록"
"을 지정하는 `all` 목록을 정의하는 블록이 포함되어 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:860
#, no-wrap
msgid ""
"all:\\\n"
"    :traplist:allowlist:\n"
msgstr ""
"all:\\\n"
"    :traplist:allowlist:\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:863
msgid ""
"This entry adds the desired blocklists, separated by colons (`:`).  To use "
"an allowlist to subtract addresses from a blocklist, add the name of the "
"allowlist _immediately_ after the name of that blocklist. For example: `:"
"blocklist:allowlist:`."
msgstr ""
"이 항목은 콜론( `:` )으로 구분하여 원하는 차단 목록을 추가합니다.  허용 목록"
"을 사용하여 차단 목록에서 주소를 빼려면 해당 차단 목록의 이름 뒤에 허용 목록"
"의 이름을 _즉시_ 추가합니다. 예: `:차단목록:허용목록:`."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:865
msgid "This is followed by the specified blocklist's definition:"
msgstr "다음은 지정된 차단 목록의 정의입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:873
#, no-wrap
msgid ""
"traplist:\\\n"
"    :black:\\\n"
"    :msg=\"SPAM. Your address %A has sent spam within the last 24 hours\":\\\n"
"    :method=http:\\\n"
"    :file=www.openbsd.org/spamd/traplist.gz\n"
msgstr ""
"traplist:\\\n"
"    :black:\\\n"
"    :msg=\"SPAM. Your address %A has sent spam within the last 24 hours\":\\\n"
"    :method=http:\\\n"
"    :file=www.openbsd.org/spamd/traplist.gz\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:879
msgid ""
"where the first line is the name of the blocklist and the second line "
"specifies the list type.  The `msg` field contains the message to display to "
"blocklisted senders during the SMTP dialogue.  The `method` field specifies "
"how spamd-setup fetches the list data; supported methods are `http`, `ftp`, "
"from a `file` in a mounted file system, and via `exec` of an external "
"program.  Finally, the `file` field specifies the name of the file spamd "
"expects to receive."
msgstr ""
"여기서 첫 번째 줄은 차단 목록의 이름이고 두 번째 줄은 목록 유형을 지정합니"
"다.  `msg` 필드에는 SMTP 대화 중에 차단 목록에 있는 발신자에게 표시할 메시지"
"가 포함됩니다.  `method` 필드는 스팸 설정에서 목록 데이터를 가져오는 방법을 "
"지정합니다. 지원되는 메서드는 `http`, `ftp`, 마운트된 파일 시스템의 `file` 에"
"서, 외부 프로그램의 `exec` 을 통해 가져오는 방법이 있습니다.  마지막으로, "
"`file` 필드는 spamd가 수신할 것으로 예상되는 파일의 이름을 지정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:881
msgid ""
"The definition of the specified allowlist is similar, but omits the `msg` "
"field since a message is not needed:"
msgstr ""
"지정된 허용 목록의 정의는 비슷하지만 메시지가 필요하지 않으므로 `msg` 필드가 "
"생략됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:888
#, no-wrap
msgid ""
"allowlist:\\\n"
"    :white:\\\n"
"    :method=file:\\\n"
"    :file=/var/mail/allowlist.txt\n"
msgstr ""
"allowlist:\\\n"
"    :white:\\\n"
"    :method=file:\\\n"
"    :file=/var/mail/allowlist.txt\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:893
#, no-wrap
msgid "*Choose Data Sources with Care:* +\n"
msgstr "*주의해서 원 자료를 선택하세요:* +\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:896
msgid ""
"Using all the blocklists in the sample [.filename]#spamd.conf# will block "
"large blocks of the Internet.  Administrators need to edit the file to "
"create an optimal configuration which uses applicable data sources and, when "
"necessary, uses custom lists."
msgstr ""
"샘플 [.filename]#spamd.conf# 에 있는 모든 차단 목록을 사용하면 대량의 인터넷 "
"블록을 차단할 수 있습니다.  관리자는 파일을 편집하여 해당 데이터 소스를 사용"
"하고 필요한 경우 사용자 지정 목록을 사용하는 최적의 구성을 만들어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:900
msgid ""
"Next, add this entry to [.filename]#/etc/rc.conf#.  Additional flags are "
"described in the man page specified by the comment:"
msgstr ""
"그런 다음 [.filename]#/etc/rc.conf# 에 다음 항목을 추가합니다.  추가 플래그"
"는 주석으로 지정된 매뉴얼 페이지에 설명되어 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:904
#, no-wrap
msgid "spamd_flags=\"-v\" # use \"\" and see spamd-setup(8) for flags\n"
msgstr "spamd_flags=\"-v\" # use \"\" and see spamd-setup(8) for flags\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:908
msgid ""
"When finished, reload the ruleset, start spamd by typing `service obspamd "
"start`, and complete the configuration using `spamd-setup`.  Finally, create "
"a man:cron[8] job which calls `spamd-setup` to update the tables at "
"reasonable intervals."
msgstr ""
"완료되면 규칙 집합을 다시 로드하고, `service obspamd start` 를 입력하여 데몬"
"을 시작한 후, `spamd-setup` 을 사용하여 구성을 완료합니다.  마지막으로, "
"`spamd-setup` 을 호출하여 적절한 간격으로 테이블을 업데이트하는 man:cron[8] "
"작업을 생성합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:911
msgid ""
"On a typical gateway in front of a mail server, hosts will soon start "
"getting trapped within a few seconds to several minutes."
msgstr ""
"메일 서버 앞의 일반적인 게이트웨이에서는 호스트가 몇 초에서 몇 분 내에 걸리"
"기 시작합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:915
msgid ""
"PF also supports _greylisting_, which temporarily rejects messages from "
"unknown hosts with _45n_ codes.  Messages from greylisted hosts which try "
"again within a reasonable time are let through.  Traffic from senders which "
"are set up to behave within the limits set by RFC 1123 and RFC 2821 are "
"immediately let through."
msgstr ""
"PF는 _45n_ 코드가 포함된, 알 수 없는 호스트의 메시지를 일시적으로 거부하는 _"
"그레이 리스트_ 기능도 지원합니다.  그레이 리스트에 등록된 호스트가 합리적인 "
"시간 내에 다시 시도하는 메시지는 통과됩니다.  RFC 1123 및 RFC 2821에 설정된 "
"제한 내에서 동작하도록 설정된 발신자의 트래픽은 즉시 통과됩니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:919
msgid ""
"More information about greylisting as a technique can be found at the http://"
"www.greylisting.org/[greylisting.org] web site.  The most amazing thing "
"about greylisting, apart from its simplicity, is that it still works.  "
"Spammers and malware writers have been very slow to adapt to bypass this "
"technique."
msgstr ""
"그레이 리스팅 기법에 대한 자세한 내용은 http://www.greylisting.org/"
"[greylisting.org] 웹 사이트에서 확인할 수 있습니다.  그레이 리스팅의 가장 놀"
"라운 점은 단순함을 제외하면 여전히 작동한다는 것입니다.  스팸 발송자와 멀웨"
"어 작성자는 이 기법을 우회하는 데 매우 느리게 적응해 왔습니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:921
msgid "The basic procedure for configuring greylisting is as follows:"
msgstr "그레이 리스팅을 구성하는 기본 절차는 다음과 같습니다:"

#. type: Block title
#: documentation/content/en/books/handbook/firewalls/_index.adoc:923
#, no-wrap
msgid "Procedure: Configuring Greylisting"
msgstr "절차: 그레이리스트 구성하기"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:925
msgid ""
"Make sure that man:fdescfs[5] is mounted as described in Step 1 of the "
"previous Procedure."
msgstr ""
"이전 절차의 1단계에 설명된 대로 man:fdescfs[5]가 마운트되었는지 확인합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:926
msgid ""
"To run spamd in greylisting mode, add this line to [.filename]#/etc/rc.conf#:"
msgstr ""
"그레이리스트 모드에서 spamd를 실행하려면 [.filename]#/etc/rc.conf# 에 이 줄"
"을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:930
#, no-wrap
msgid "spamd_grey=\"YES\"  # use spamd greylisting if YES\n"
msgstr "spamd_grey=\"YES\"  # use spamd greylisting if YES\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:933
msgid ""
"Refer to the spamd man page for descriptions of additional related "
"parameters."
msgstr "기타 관련 매개변수에 대한 설명은 spamd 매뉴얼 페이지를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:934
msgid "To complete the greylisting setup:"
msgstr "그레이리스트 설정 완료하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:939
#, no-wrap
msgid ""
"#  service obspamd restart\n"
"#  service obspamlogd start\n"
msgstr ""
"#  service obspamd restart\n"
"#  service obspamlogd start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:943
msgid ""
"Behind the scenes, the spamdb database tool and the spamlogd whitelist "
"updater perform essential functions for the greylisting feature.  spamdb is "
"the administrator's main interface to managing the block, grey, and allow "
"lists via the contents of the [.filename]#/var/db/spamdb# database."
msgstr ""
"배후에서 spamdb 데이터베이스 도구와 spamlogd 화이트리스트 업데이터는 그레이리"
"스트 기능에 필수적인 기능을 수행합니다. spamdb는 [.filename]#/var/db/spamdb# "
"데이터베이스의 내용을 통해 차단, 그레이, 허용 목록을 관리하는 관리자의 기본 "
"인터페이스입니다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:945
#, no-wrap
msgid "Network Hygiene"
msgstr "네트워크 위생"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:948
msgid ""
"This section describes how `block-policy`, `scrub`, and `antispoof` can be "
"used to make the ruleset behave sanely."
msgstr ""
"이 섹션에서는 규칙 집합이 정상적으로 작동하도록 하기 위해 `block-policy`, "
"`scrub`, `antispoof` 를 사용하는 방법에 대해 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:952
msgid ""
"The `block-policy` is an option which can be set in the `options` part of "
"the ruleset, which precedes the redirection and filtering rules.  This "
"option determines which feedback, if any, PF sends to hosts that are blocked "
"by a rule.  The option has two possible values: `drop` drops blocked packets "
"with no feedback, and `return` returns a status code such as `Connection "
"refused`."
msgstr ""
"`block-policy` 은 리디렉션 및 필터링 규칙 앞에 있는 규칙 집합의 `options` 부"
"분에서 설정할 수 있습니다.  이 옵션은 PF가 규칙에 의해 차단된 호스트에 어떤 "
"피드백(있는 경우)을 보낼지 결정합니다.  이 옵션에는 두 가지 가능한 값이 있습"
"니다: `drop` 은 피드백 없이 차단된 패킷을 삭제하고 `return` 은 `Connection "
"refused` 와 같은 상태 코드를 반환합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:955
msgid ""
"If not set, the default policy is `drop`.  To change the `block-policy`, "
"specify the desired value:"
msgstr ""
"설정하지 않으면 기본 정책은 `drop` 입니다.  `block-policy` 을 변경하려면 원하"
"는 값을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:959
#, no-wrap
msgid "set block-policy return\n"
msgstr "set block-policy return\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:965
msgid ""
"In PF, `scrub` is a keyword which enables network packet normalization.  "
"This process reassembles fragmented packets and drops TCP packets that have "
"invalid flag combinations.  Enabling `scrub` provides a measure of "
"protection against certain kinds of attacks based on incorrect handling of "
"packet fragments.  A number of options are available, but the simplest form "
"is suitable for most configurations:"
msgstr ""
"PF에서 `scrub` 은 네트워크 패킷 정규화를 가능하게 하는 키워드입니다.  이 프로"
"세스는 조각난 패킷을 재조립하고 잘못된 플래그 조합을 가진 TCP 패킷을 삭제합니"
"다.  `scrub` 을 활성화하면 패킷 조각의 잘못된 처리를 기반으로 하는 특정 종류"
"의 공격에 대한 보호 수단을 제공합니다.  여러 가지 옵션을 사용할 수 있지만 가"
"장 간단한 형태가 대부분의 구성에 적합합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:969
#, no-wrap
msgid "scrub in all\n"
msgstr "scrub in all\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:973
msgid ""
"Some services, such as NFS, require specific fragment handling options.  "
"Refer to https://home.nuug.no/\\~peter/pf/en/scrub.html[https://home.nuug.no/"
"~peter/pf/en/scrub.html] for more information."
msgstr ""
"NFS와 같은 일부 서비스에는 특정 조각 처리 옵션이 필요합니다.  자세한 내용은 "
"https://home.nuug.no/\\~peter/pf/en/scrub.html[https://home.nuug.no/~peter/"
"pf/en/scrub.html]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:975
msgid ""
"This example reassembles fragments, clears the \"do not fragment\" bit, and "
"sets the maximum segment size to 1440 bytes:"
msgstr ""
"이 예제에서는 조각을 재조립하고 “do not fragment” 비트를 지운 다음 최대 세그"
"먼트 크기를 1440바이트로 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:979
#, no-wrap
msgid "scrub in all fragment reassemble no-df max-mss 1440\n"
msgstr "scrub in all fragment reassemble no-df max-mss 1440\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:982
msgid ""
"The `antispoof` mechanism protects against activity from spoofed or forged "
"IP addresses, mainly by blocking packets appearing on interfaces and in "
"directions which are logically not possible."
msgstr ""
"`antispoof` 메커니즘은 주로 논리적으로 불가능한 방향을 가리키는 패킷을 차단하"
"여 스푸핑 또는 위조된 IP 주소의 활동을 방지합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:984
msgid ""
"These rules weed out spoofed traffic coming in from the rest of the world as "
"well as any spoofed packets which originate in the local network:"
msgstr ""
"이러한 규칙은 로컬 네트워크에서 발생하는 스푸핑된 패킷뿐만 아니라 외부에서 들"
"어오는 스푸핑된 트래픽을 걸러냅니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:989
#, no-wrap
msgid ""
"antispoof for $ext_if\n"
"antispoof for $int_if\n"
msgstr ""
"antispoof for $ext_if\n"
"antispoof for $int_if\n"

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:992
#, no-wrap
msgid "Handling Non-Routable Addresses"
msgstr "라우팅할 수 없는 주소 처리하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:997
msgid ""
"Even with a properly configured gateway to handle network address "
"translation, one may have to compensate for other people's "
"misconfigurations.  A common misconfiguration is to let traffic with non-"
"routable addresses out to the Internet.  Since traffic from non-routeable "
"addresses can play a part in several DoS attack techniques, consider "
"explicitly blocking traffic from non-routeable addresses from entering the "
"network through the external interface."
msgstr ""
"네트워크 주소 변환을 처리하도록 게이트웨이를 올바르게 구성했더라도 사용자의 "
"잘못된 구성을 보완해야 할 수 있습니다.  일반적인 잘못된 구성은 라우팅할 수 없"
"는 주소를 가진 트래픽을 인터넷으로 내보내는 것입니다.  라우팅할 수 없는 주소"
"의 트래픽은 여러 DoS 공격 기법의 일부가 될 수 있으므로 라우팅할 수 없는 주소"
"의 트래픽이 외부 인터페이스를 통해 네트워크에 유입되지 않도록 명시적으로 차단"
"하는 것이 좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1000
msgid ""
"In this example, a macro containing non-routable addresses is defined, then "
"used in blocking rules.  Traffic to and from these addresses is quietly "
"dropped on the gateway's external interface."
msgstr ""
"이 예에서는 라우팅할 수 없는 주소가 포함된 매크로를 정의한 다음 차단 규칙에 "
"사용합니다.  이러한 주소로 들어오고 나가는 트래픽은 게이트웨이의 외부 인터페"
"이스에서 조용히 차단됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1006
#, no-wrap
msgid ""
"martians = \"{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \\\n"
"\t      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \\\n"
"\t      0.0.0.0/8, 240.0.0.0/4 }\"\n"
msgstr ""
"martians = \"{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \\\n"
"\t      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \\\n"
"\t      0.0.0.0/8, 240.0.0.0/4 }\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1009
#, no-wrap
msgid ""
"block drop in quick on $ext_if from $martians to any\n"
"block drop out quick on $ext_if from any to $martians\n"
msgstr ""
"block drop in quick on $ext_if from $martians to any\n"
"block drop out quick on $ext_if from any to $martians\n"

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1011
#, no-wrap
msgid "Enabling ALTQ"
msgstr "ALTQ 활성화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1015
msgid ""
"On FreeBSD, ALTQ can be used with PF to provide Quality of Service (QOS).  "
"Once ALTQ is enabled, queues can be defined in the ruleset which determine "
"the processing priority of outbound packets."
msgstr ""
"FreeBSD에서 ALTQ는 PF와 함께 사용되어 서비스 품질(QOS)을 향상시킬 수 있습니"
"다.  ALTQ가 활성화되면, 아웃바운드 패킷의 처리 우선순위를 결정하는 큐를 규칙 "
"집합에 정의할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1017
msgid ""
"Before enabling ALTQ, refer to man:altq[4] to determine if the drivers for "
"the network cards installed on the system support it."
msgstr ""
"ALTQ를 활성화하기 전에 man:altq[4]를 참조하여 시스템에 설치된 네트워크 카드"
"의 드라이버가 이를 지원하는지 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1023
msgid ""
"ALTQ is not available as a loadable kernel module.  If the system's "
"interfaces support ALTQ, create a custom kernel using the instructions in "
"crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel].  The "
"following kernel options are available.  The first is needed to enable "
"ALTQ.  At least one of the other options is necessary to specify the "
"queueing scheduler algorithm:"
msgstr ""
"ALTQ는 커널 모듈을 로드하는 방식으로 사용할 수 없습니다.  시스템 인터페이스"
"가 ALTQ를 지원하는 경우 crossref:kernelconfig[kernelconfig,FreeBSD 커널 구성]"
"의 지침을 사용하여 사용자 정의 커널을 생성하세요.  다음 커널 옵션을 사용할 "
"수 있습니다.  첫 번째는 ALTQ를 활성화하는 데 필요합니다.  그리고 큐잉 스케줄"
"러 알고리즘을 지정하려면 다른 옵션 중 하나 이상이 필요합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1032
#, no-wrap
msgid ""
"options         ALTQ\n"
"options         ALTQ_CBQ        # Class Based Queuing (CBQ)\n"
"options         ALTQ_RED        # Random Early Detection (RED)\n"
"options         ALTQ_RIO        # RED In/Out\n"
"options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)\n"
"options         ALTQ_PRIQ       # Priority Queuing (PRIQ)\n"
msgstr ""
"options         ALTQ\n"
"options         ALTQ_CBQ        # Class Based Queuing (CBQ)\n"
"options         ALTQ_RED        # Random Early Detection (RED)\n"
"options         ALTQ_RIO        # RED In/Out\n"
"options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)\n"
"options         ALTQ_PRIQ       # Priority Queuing (PRIQ)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1035
msgid "The following scheduler algorithms are available:"
msgstr "사용할 수 있는 스케줄러 알고리즘은 다음과 같습니다:"

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1036
#, no-wrap
msgid "CBQ"
msgstr "CBQ"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1038
msgid ""
"Class Based Queuing (CBQ) is used to divide a connection's bandwidth into "
"different classes or queues to prioritize traffic based on filter rules."
msgstr ""
"클래스 기반 큐(Class Based Queuing, CBQ)는 연결의 대역폭을 여러 클래스 또는 "
"큐로 나누어 필터 규칙에 따라 트래픽의 우선 순위를 지정하는 데 사용됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1039
#, no-wrap
msgid "RED"
msgstr "RED"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1042
msgid ""
"Random Early Detection (RED) is used to avoid network congestion by "
"measuring the length of the queue and comparing it to the minimum and "
"maximum thresholds for the queue.  When the queue is over the maximum, all "
"new packets are randomly dropped."
msgstr ""
"무작위 조기 감지(Random Early Detection, RED)는 대기열의 길이를 측정하고 대기"
"열의 최소 및 최대 임계값과 비교하여 네트워크 혼잡을 방지하는 데 사용됩니다.  "
"대기열이 최대 임계값을 초과하면 모든 새 패킷이 무작위로 삭제됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1043
#, no-wrap
msgid "RIO"
msgstr "RIO"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1045
msgid ""
"In Random Early Detection In and Out (RIO) mode, RED maintains multiple "
"average queue lengths and multiple threshold values, one for each QOS level."
msgstr ""
"무작위 조기 감지 입출력(Random Early Detection In and Out, RIO) 모드에서 RED"
"는 각 QOS 수준에 대해 하나씩 여러 개의 평균 대기열 길이와 여러 임계값을 유지"
"합니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1046
#, no-wrap
msgid "HFSC"
msgstr "HFSC"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1048
msgid ""
"Hierarchical Fair Service Curve Packet Scheduler (HFSC) is described in "
"http://www-2.cs.cmu.edu/\\~hzhang/HFSC/main.html[http://www-2.cs.cmu.edu/"
"~hzhang/HFSC/main.html]."
msgstr ""
"계층적 공정 서비스 곡선 패킷 스케줄러(Hierarchical Fair Service Curve Packet "
"Scheduler, HFSC)는 http://www-2.cs.cmu.edu/\\~hzhang/HFSC/main.html[http://"
"www-2.cs.cmu.edu/~hzhang/HFSC/main.html]에 설명되어 있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1049
#, no-wrap
msgid "PRIQ"
msgstr "PRIQ"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1051
msgid ""
"Priority Queuing (PRIQ) always passes traffic that is in a higher queue "
"first."
msgstr ""
"우선 순위 대기열(Priority Queuing, PRIQ)은 항상 대기열이 높은 트래픽을 먼저 "
"통과시킵니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1053
msgid ""
"More information about the scheduling algorithms and example rulesets are "
"available at the https://web.archive.org/web/20151109213426/http://www."
"openbsd.org/faq/pf/queueing.html[OpenBSD's web archive]."
msgstr ""
"스케줄링 알고리즘 및 예제 규칙 집합에 대한 자세한 내용은 https://web.archive."
"org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html[OpenBSD "
"웹 아카이브]에서 확인할 수 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1055
#, no-wrap
msgid "IPFW"
msgstr "IPFW"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1059
msgid ""
"IPFW is a stateful firewall written for FreeBSD which supports both IPv4 and "
"IPv6.  It is comprised of several components: the kernel firewall filter "
"rule processor and its integrated packet accounting facility, the logging "
"facility, NAT, the man:dummynet[4] traffic shaper, a forward facility, a "
"bridge facility, and an ipstealth facility."
msgstr ""
"IPFW는 FreeBSD용으로 작성된 상태분석형 방화벽으로, IPv4와 IPv6를 모두 지원합"
"니다.  커널 방화벽 필터 규칙 프로세서와 통합 패킷 어카운팅 기능, 로깅 기능, "
"NAT, man:dummynet[4] 트래픽 셰이퍼, 포워드 기능, 브리지 기능, ipstealth 기능 "
"등 여러 구성 요소로 이루어져 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1062
msgid ""
"FreeBSD provides a sample ruleset in [.filename]#/etc/rc.firewall# which "
"defines several firewall types for common scenarios to assist novice users "
"in generating an appropriate ruleset.  IPFW provides a powerful syntax which "
"advanced users can use to craft customized rulesets that meet the security "
"requirements of a given environment."
msgstr ""
"FreeBSD는 초보 사용자가 적절한 규칙 집합을 생성하는 데 도움이 되도록 일반적"
"인 시나리오에 대한 몇 가지 방화벽 유형을 정의하는 샘플 규칙 집합을 [."
"filename]#/etc/rc.firewall# 에 제공합니다.  IPFW는 고급 사용자가 특정 환경의 "
"보안 요구 사항을 충족하는 맞춤형 규칙 집합을 만드는 데 사용할 수 있는 강력한 "
"구문을 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1064
msgid ""
"This section describes how to enable IPFW, provides an overview of its rule "
"syntax, and demonstrates several rulesets for common configuration scenarios."
msgstr ""
"이 섹션에서는 IPFW를 사용 설정하는 방법을 설명하고, 규칙 구문에 대한 개요를 "
"제공하며, 일반적인 구성 시나리오에 대한 몇 가지 규칙 집합을 보여 줍니다."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1066
#, no-wrap
msgid "Enabling IPFW"
msgstr "IPFW 활성화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1069
msgid ""
"IPFW is included in the basic FreeBSD install as a kernel loadable module, "
"meaning that a custom kernel is not needed in order to enable IPFW."
msgstr ""
"IPFW는 커널 로딩이 가능한 모듈 형태로 기본 FreeBSD 설치에 포함되어 있으므로, "
"IPFW를 활성화하기 위해 커스텀 커널이 필요하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1072
#, fuzzy
#| msgid ""
#| "For those users who wish to statically compile IPFW support into a custom "
#| "kernel, see <<firewalls-ipfw-kernelconfig>>."
msgid ""
"For those users who wish to statically compile IPFW support into a custom "
"kernel, see crossref:firewalls[firewalls-ipfw-kernelconfig, IPFW Kernel "
"Options]."
msgstr ""
"IPFW 지원을 사용자 지정 커널에 정적으로 컴파일하려는 사용자의 경우 "
"<<firewalls-ipfw-kernelconfig>> 을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1074
msgid ""
"To configure the system to enable IPFW at boot time, add `firewall_enable="
"\"YES\"` to [.filename]#/etc/rc.conf#:"
msgstr ""
"부팅 시 IPFW를 사용하도록 시스템을 구성하려면 [.filename]#/etc/rc.conf# 에 "
"`firewall_enable=“YES”` 를 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1078
#, no-wrap
msgid "# sysrc firewall_enable=\"YES\"\n"
msgstr "# sysrc firewall_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1081
msgid ""
"To use one of the default firewall types provided by FreeBSD, add another "
"line which specifies the type:"
msgstr ""
"FreeBSD에서 제공하는 기본 방화벽 유형 중 하나를 사용하려면 유형을 지정하는 내"
"용을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1085
#, no-wrap
msgid "# sysrc firewall_type=\"open\"\n"
msgstr "# sysrc firewall_type=\"open\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1088
msgid "The available types are:"
msgstr "사용 가능한 유형은:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1090
msgid "`open`: passes all traffic."
msgstr "`open` : 모든 트래픽을 통과시킵니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1091
msgid "`client`: protects only this machine."
msgstr "`client` : 이 장비만 보호합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1092
msgid "`simple`: protects the whole network."
msgstr "`simple` : 전체 네트워크를 보호합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1093
msgid ""
"`closed`: entirely disables IP traffic except for the loopback interface."
msgstr ""
"`closed` : 루프백 인터페이스를 제외한 IP 트래픽을 완전히 비활성화합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1094
msgid "`workstation`: protects only this machine using stateful rules."
msgstr "`workstation` : 상태분석형 규칙을 이용해 이 장비만 보호합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1095
msgid "`UNKNOWN`: disables the loading of firewall rules."
msgstr "`UNKNOWN` : 방화벽 규칙의 로딩을 비활성화합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1096
msgid ""
"[.filename]#filename#: full path of the file containing the firewall ruleset."
msgstr ""
"[.filename]#filename# : 방화벽 규칙 집합이 포함된 파일의 전체 경로입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1098
msgid ""
"If `firewall_type` is set to either `client` or `simple`, modify the default "
"rules found in [.filename]#/etc/rc.firewall# to fit the configuration of the "
"system."
msgstr ""
"`firewall_type` 이 `client` 또는 `simple` 으로 설정된 경우, [.filename]#/etc/"
"rc.firewall# 에 있는 기본 규칙을 시스템 구성에 맞게 수정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1100
msgid "Note that the `filename` type is used to load a custom ruleset."
msgstr "`filename` 유형은 사용자 정의 규칙 집합을 로드하는 데 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1103
msgid ""
"An alternate way to load a custom ruleset is to set the `firewall_script` "
"variable to the absolute path of an _executable script_ that includes IPFW "
"commands.  The examples used in this section assume that the "
"`firewall_script` is set to [.filename]#/etc/ipfw.rules#:"
msgstr ""
"사용자 지정 규칙 집합을 로드하는 다른 방법은 `firewall_script` 변수를 IPFW 명"
"령이 포함된 _실행 가능한 스크립트_ 의 절대 경로로 설정하는 것입니다.  이 섹션"
"에 사용된 예제에서는 `firewall_script` 가 [.filename]#/etc/ipfw.rules# 로 설"
"정되어 있다고 가정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1107
#, no-wrap
msgid "# sysrc firewall_script=\"/etc/ipfw.rules\"\n"
msgstr "# sysrc firewall_script=\"/etc/ipfw.rules\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1110
msgid "To enable logging through man:syslogd[8], include this line:"
msgstr "man:syslogd[8]를 통해 로깅을 활성화하려면 다음을 포함시키세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1114
#, no-wrap
msgid "# sysrc firewall_logging=\"YES\"\n"
msgstr "# sysrc firewall_logging=\"YES\"\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1122
msgid ""
"Only firewall rules with the `log` option will be logged.  The default rules "
"do not include this option and it must be manually added.  Therefore it is "
"advisable that the default ruleset is edited for logging.  In addition, log "
"rotation may be desired if the logs are stored in a separate file."
msgstr ""
"`log` 옵션이 있는 방화벽 규칙만 기록됩니다.  기본 규칙에는 이 옵션이 포함되"
"어 있지 않으므로 수동으로 추가해야 합니다.  따라서 로깅을 위해 기본 규칙 집합"
"을 편집하는 것이 좋습니다.  또한 로그가 별도의 파일에 저장되는 경우 로그 로테"
"이션이 필요할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1126
msgid ""
"There is no [.filename]#/etc/rc.conf# variable to set logging limits.  To "
"limit the number of times a rule is logged per connection attempt, specify "
"the number using this line in [.filename]#/etc/sysctl.conf#:"
msgstr ""
"로깅 제한을 설정할 수 있는 [.filename]#/etc/rc.conf# 변수는 없습니다.  연결 "
"시도당 규칙이 기록되는 횟수를 제한하려면 [.filename]#/etc/sysctl.conf# 에서 "
"다음 내용을 사용하여 횟수를 지정하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1130
#, no-wrap
msgid "# echo \"net.inet.ip.fw.verbose_limit=5\" >> /etc/sysctl.conf\n"
msgstr "# echo \"net.inet.ip.fw.verbose_limit=5\" >> /etc/sysctl.conf\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1133
msgid ""
"To enable logging through a dedicated interface named `ipfw0`, add this line "
"to [.filename]#/etc/rc.conf# instead:"
msgstr ""
"`ipfw0` 이라는 전용 인터페이스를 통해 로깅을 사용하려면 [.filename]#/etc/rc."
"conf# 에 이 줄을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1137
#, no-wrap
msgid "# sysrc firewall_logif=\"YES\"\n"
msgstr "# sysrc firewall_logif=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1140
msgid "Then use tcpdump to see what is being logged:"
msgstr "그런 다음 tcpdump를 사용하여 기록되는 내용을 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1144
#, no-wrap
msgid "# tcpdump -t -n -i ipfw0\n"
msgstr "# tcpdump -t -n -i ipfw0\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1150
msgid "There is no overhead due to logging unless tcpdump is attached."
msgstr "tcpdump를 첨부하지 않는 한 로깅으로 인한 오버헤드는 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1154
msgid ""
"After saving the needed edits, start the firewall.  To enable logging limits "
"now, also set the `sysctl` value specified above:"
msgstr ""
"필요한 내용을 편집, 저장한 후 방화벽을 시작합니다.  지금 로깅 제한을 사용하려"
"면 위에 지정된 `sysctl` 값도 설정하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1159
#, no-wrap
msgid ""
"# service ipfw start\n"
"# sysctl net.inet.ip.fw.verbose_limit=5\n"
msgstr ""
"# service ipfw start\n"
"# sysctl net.inet.ip.fw.verbose_limit=5\n"

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1162
#, no-wrap
msgid "IPFW Rule Syntax"
msgstr "IPFW 규칙 문법"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1170
msgid ""
"When a packet enters the IPFW firewall, it is compared against the first "
"rule in the ruleset and progresses one rule at a time, moving from top to "
"bottom in sequence.  When the packet matches the selection parameters of a "
"rule, the rule's action is executed and the search of the ruleset terminates "
"for that packet.  This is referred to as \"first match wins\".  If the "
"packet does not match any of the rules, it gets caught by the mandatory IPFW "
"default rule number 65535, which denies all packets and silently discards "
"them.  However, if the packet matches a rule that contains the `count`, "
"`skipto`, or `tee` keywords, the search continues.  Refer to man:ipfw[8] for "
"details on how these keywords affect rule processing."
msgstr ""
"패킷이 IPFW 방화벽에 들어오면 규칙 세트의 첫 번째 규칙과 비교하여 한 번에 하"
"나의 규칙을 순서대로 위에서 아래로 이동하면서 확인합니다.  패킷이 규칙의 선"
"택 매개변수와 일치하면 규칙의 동작이 실행되고 해당 패킷에 대한 규칙 세트 검색"
"이 종료됩니다.  이를 “첫 번째 일치 승리”라고 합니다.  패킷이 어떤 규칙과도 일"
"치하지 않는 경우, 모든 패킷을 거부하고 자동으로 폐기하는 필수 IPFW 기본 규칙 "
"번호 65535에 의해 패킷이 포착됩니다.  그러나 패킷이 `count`, `skipto` 또는 "
"`tee` 키워드가 포함된 규칙과 일치하면 검색이 계속됩니다.  이러한 키워드가 규"
"칙 처리에 미치는 영향에 대한 자세한 내용은 man:ipfw[8]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1176
msgid ""
"When creating an IPFW rule, keywords must be written in the following "
"order.  Some keywords are mandatory while other keywords are optional.  The "
"words shown in uppercase represent a variable and the words shown in "
"lowercase must precede the variable that follows it.  The `+#+` symbol is "
"used to mark the start of a comment and may appear at the end of a rule or "
"on its own line.  Blank lines are ignored."
msgstr ""
"IPFW 규칙을 만들 때 키워드는 다음 순서로 작성해야 합니다.  일부 키워드는 필수"
"이고 다른 키워드는 선택 사항입니다.  대문자로 표시된 단어는 변수를 나타내며 "
"소문자로 표시된 단어는 그 뒤에 오는 변수 앞에 와야 합니다.  `+#+` 기호는 댓글"
"의 시작을 표시하는 데 사용되며 규칙의 끝이나 자체 줄에 표시할 수 있습니다.  "
"빈 줄은 무시됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1178
msgid ""
"`_CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC "
"SRC_PORT to DST DST_PORT OPTIONS_`"
msgstr ""
"`_CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC "
"SRC_PORT to DST DST_PORT OPTIONS_`"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1182
msgid ""
"This section provides an overview of these keywords and their options.  It "
"is not an exhaustive list of every possible option.  Refer to man:ipfw[8] "
"for a complete description of the rule syntax that can be used when creating "
"IPFW rules."
msgstr ""
"이 섹션에서는 이러한 키워드와 해당 옵션에 대한 개요를 제공합니다.  가능한 모"
"든 옵션의 전체 목록은 아닙니다.  IPFW 규칙을 만들 때 사용할 수 있는 규칙 구문"
"에 대한 전체 설명은 man:ipfw[8]를 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1183
#, no-wrap
msgid "CMD"
msgstr "CMD"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1185
msgid "Every rule must start with `ipfw add`."
msgstr "모든 규칙은 `ipfw add` 로 시작해야 합니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1186
#, no-wrap
msgid "RULE_NUMBER"
msgstr "RULE_NUMBER"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1190
msgid ""
"Each rule is associated with a number from `1` to `65534`.  The number is "
"used to indicate the order of rule processing.  Multiple rules can have the "
"same number, in which case they are applied according to the order in which "
"they have been added."
msgstr ""
"각 규칙은 `1` 에서 `65534` 사이의 숫자와 연관되어 있습니다.  이 번호는 규칙 "
"처리 순서를 나타내는 데 사용됩니다.  여러 규칙이 동일한 번호를 가질 수 있으"
"며, 이 경우 규칙이 추가된 순서에 따라 적용됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1191
#, no-wrap
msgid "SET_NUMBER"
msgstr "SET_NUMBER"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1195
msgid ""
"Each rule is associated with a set number from `0` to `31`.  Sets can be "
"individually disabled or enabled, making it possible to quickly add or "
"delete a set of rules.  If a SET_NUMBER is not specified, the rule will be "
"added to set `0`."
msgstr ""
"각 규칙은 `0` 에서 `31` 사이의 세트 번호와 연결됩니다.  세트는 개별적으로 비"
"활성화하거나 활성화할 수 있으므로 규칙 집합을 빠르게 추가하거나 삭제할 수 있"
"습니다.  SET_NUMBER를 지정하지 않으면 규칙이 `0` 세트에 추가됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1196
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1942
#, no-wrap
msgid "ACTION"
msgstr "ACTION"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1199
msgid ""
"A rule can be associated with one of the following actions.  The specified "
"action will be executed when the packet matches the selection criterion of "
"the rule."
msgstr ""
"규칙은 다음 작업 중 하나와 연결할 수 있습니다.  패킷이 규칙의 선택 기준과 일"
"치하면 지정된 작업이 실행됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1201
msgid ""
"`allow | accept | pass | permit`: these keywords are equivalent and allow "
"packets that match the rule."
msgstr ""
"`allow | accept | pass | permit` : 이 키워드는 동등한 키워드이며 규칙과 일치"
"하는 패킷을 허용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1206
msgid ""
"`check-state`: checks the packet against the dynamic state table.  If a "
"match is found, execute the action associated with the rule which generated "
"this dynamic rule, otherwise move to the next rule.  A `check-state` rule "
"does not have selection criterion.  If no `check-state` rule is present in "
"the ruleset, the dynamic rules table is checked at the first `keep-state` or "
"`limit` rule."
msgstr ""
"`check-state` : 동적 상태 테이블에 대해 패킷을 확인합니다.  일치하는 항목이 "
"발견되면 이 동적 규칙을 생성한 규칙과 관련된 작업을 실행하고, 그렇지 않으면 "
"다음 규칙으로 이동합니다.  `check-state` 규칙에는 선택 기준이 없습니다.  규"
"칙 집합에 `check-state` 규칙이 없는 경우 동적 규칙 테이블은 첫 번째 `keep-"
"state` 또는 `limit` 규칙에서 확인됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1209
msgid ""
"`count`: updates counters for all packets that match the rule.  The search "
"continues with the next rule."
msgstr ""
"`count` : 규칙과 일치하는 모든 패킷에 대한 카운터를 업데이트합니다.  검색은 "
"다음 규칙으로 계속됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1211
msgid ""
"`deny | drop`: either word silently discards packets that match this rule."
msgstr "`deny | drop` : 이 규칙과 일치하는 패킷은 조용히 폐기됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1214
msgid "Additional actions are available.  Refer to man:ipfw[8] for details."
msgstr ""
"추가 작업을 사용할 수 있습니다.  자세한 내용은 man:ipfw[8]을 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1215
#, no-wrap
msgid "LOG_AMOUNT"
msgstr "LOG_AMOUNT"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1221
msgid ""
"When a packet matches a rule with the `log` keyword, a message will be "
"logged to man:syslogd[8] with a facility name of `SECURITY`.  Logging only "
"occurs if the number of packets logged for that particular rule does not "
"exceed a specified LOG_AMOUNT.  If no LOG_AMOUNT is specified, the limit is "
"taken from the value of `net.inet.ip.fw.verbose_limit`.  A value of zero "
"removes the logging limit.  Once the limit is reached, logging can be re-"
"enabled by clearing the logging counter or the packet counter for that rule, "
"using `ipfw resetlog`."
msgstr ""
"패킷이 `log` 키워드가 있는 규칙과 일치하면, `SECURITY` 라는 이름으로 man:"
"syslogd[8]에 메시지가 기록됩니다.  로깅은 특정 규칙에 대해 기록된 패킷 수가 "
"지정된 LOG_AMOUNT를 초과하지 않는 경우에만 발생합니다.  LOG_AMOUNT를 지정하"
"지 않으면 `net.inet.ip.fw.verbose_limit` 의 값에서 제한을 가져옵니다.  값이 0"
"이면 로깅 제한이 제거됩니다.  제한에 도달하면 `ipfw resetlog` 를 사용하여 해"
"당 규칙에 대한 로깅 카운터 또는 패킷 카운터를 지우면 로깅을 다시 활성화할 수 "
"있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1226
msgid ""
"Logging is done after all other packet matching conditions have been met, "
"and before performing the final action on the packet.  The administrator "
"decides which rules to enable logging on."
msgstr ""
"로깅은 다른 모든 패킷 매칭 조건이 충족된 후 패킷에 대한 최종 작업을 수행하기 "
"전에 수행됩니다.  관리자는 로그온을 활성화할 규칙을 결정합니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1228
#, no-wrap
msgid "PROTO"
msgstr "PROTO"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1230
msgid ""
"This optional value can be used to specify any protocol name or number found "
"in [.filename]#/etc/protocols#."
msgstr ""
"이 옵션은 [.filename]#/etc/protocols# 에 있는 프로토콜 이름이나 번호를 지정하"
"는 데 사용할 수 있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1231
#, no-wrap
msgid "SRC"
msgstr "SRC"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1236
msgid ""
"The `from` keyword must be followed by the source address or a keyword that "
"represents the source address.  An address can be represented by `any`, `me` "
"(any address configured on an interface on this system), `me6`, (any IPv6 "
"address configured on an interface on this system), or `table` followed by "
"the number of a lookup table which contains a list of addresses.  When "
"specifying an IP address, it can be optionally followed by its CIDR mask or "
"subnet mask.  For example, `1.2.3.4/25` or `1.2.3.4:255.255.255.128`."
msgstr ""
"`from` 키워드 뒤에는 소스 주소 또는 소스 주소를 나타내는 키워드가 와야 합니"
"다.  주소는 `any`, `me` (이 시스템의 인터페이스에 구성된 모든 주소), `me6` "
"(이 시스템의 인터페이스에 구성된 모든 IPv6 주소) 또는 주소 목록이 포함된 조"
"회 테이블의 번호 뒤에 `table` 로 나타낼 수 있습니다.  IP 주소를 지정할 때 선"
"택적으로 그 뒤에 CIDR 마스크 또는 서브넷 마스크를 붙일 수 있습니다.  예를 들"
"어 `1.2.3.4/25` 또는 `1.2.3.4:255.255.255.128` 입니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1237
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2008
#, no-wrap
msgid "SRC_PORT"
msgstr "SRC_PORT"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1239
msgid ""
"An optional source port can be specified using the port number or name from "
"[.filename]#/etc/services#."
msgstr ""
"추가적인 소스 포트는 [.filename]#/etc/services# 의 포트 번호 또는 이름을 사용"
"하여 지정할 수 있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1240
#, no-wrap
msgid "DST"
msgstr "DST"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1243
msgid ""
"The `to` keyword must be followed by the destination address or a keyword "
"that represents the destination address.  The same keywords and addresses "
"described in the SRC section can be used to describe the destination."
msgstr ""
"‘to’ 키워드 뒤에는 목적지 주소 또는 목적지 주소를 나타내는 키워드가 와야 합니"
"다.  SRC 섹션에 설명된 것과 동일한 키워드와 주소를 사용하여 목적지를 설명할 "
"수 있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1244
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2021
#, no-wrap
msgid "DST_PORT"
msgstr "DST_PORT"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1246
msgid ""
"An optional destination port can be specified using the port number or name "
"from [.filename]#/etc/services#."
msgstr ""
"선택적 대상 포트는 [.filename]#/etc/services# 의 포트 번호 또는 이름을 사용하"
"여 지정할 수 있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1247
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1972
#, no-wrap
msgid "OPTIONS"
msgstr "OPTIONS"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1251
msgid ""
"Several keywords can follow the source and destination.  As the name "
"suggests, OPTIONS are optional.  Commonly used options include `in` or "
"`out`, which specify the direction of packet flow, `icmptypes` followed by "
"the type of ICMP message, and `keep-state`."
msgstr ""
"소스 및 목적지 뒤에 여러 키워드를 붙일 수 있습니다.  이름에서 알 수 있듯이 옵"
"션은 선택 사항입니다.  일반적으로 사용되는 옵션으로는 패킷 흐름의 방향을 지정"
"하는 `in` 또는 `out`, ICMP 메시지 유형이 뒤따르는 `icmptypes`, `keep-state` "
"가 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1253
msgid ""
"When a `keep-state` rule is matched, the firewall will create a dynamic rule "
"which matches bidirectional traffic between the source and destination "
"addresses and ports using the same protocol."
msgstr ""
"`keep-state` 규칙과 일치하면 방화벽은 동일한 프로토콜을 사용하는 원본과 대상 "
"주소 및 포트 간의 양방향 트래픽을 일치시키는 동적 규칙을 생성합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1258
msgid ""
"The dynamic rules facility is vulnerable to resource depletion from a SYN-"
"flood attack which would open a huge number of dynamic rules.  To counter "
"this type of attack with IPFW, use `limit`.  This option limits the number "
"of simultaneous sessions by checking the open dynamic rules, counting the "
"number of times this rule and IP address combination occurred.  If this "
"count is greater than the value specified by `limit`, the packet is "
"discarded."
msgstr ""
"동적 규칙 기능은 수많은 동적 규칙을 열어주는 SYN-flood 공격으로 인한 리소스 "
"고갈에 취약합니다.  IPFW로 이러한 유형의 공격에 대응하려면 `limit` 를 사용하"
"십시오.  이 옵션은 열려 있는 동적 규칙을 확인하여 이 규칙과 IP 주소 조합이 발"
"생한 횟수를 계산하여 동시 세션 수를 제한합니다.  이 횟수가 `limit` 에 지정된 "
"값보다 크면 패킷이 삭제됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1261
msgid ""
"Dozens of OPTIONS are available.  Refer to man:ipfw[8] for a description of "
"each available option."
msgstr ""
"수십 가지 옵션을 사용할 수 있습니다.  사용 가능한 각 옵션에 대한 설명은 man:"
"ipfw[8]을 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1262
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2049
#, no-wrap
msgid "Example Ruleset"
msgstr "규칙 집합 예시"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1267
msgid ""
"This section demonstrates how to create an example stateful firewall ruleset "
"script named [.filename]#/etc/ipfw.rules#.  In this example, all connection "
"rules use `in` or `out` to clarify the direction.  They also use `via` "
"_interface-name_ to specify the interface the packet is traveling over."
msgstr ""
"이 섹션에서는 [.filename]#/etc/ipfw.rules# 라는 이름의 상태분석형 방화벽 규칙"
"집합 스크립트를 만드는 방법을 설명합니다.  이 예제에서 모든 연결 규칙은 방향"
"을 명확히 하기 위해 `in` 또는 `out` 을 사용합니다.  또한 패킷이 이동하는 인터"
"페이스를 지정하기 위해 `via` _interface-name_ 을 사용합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1271
msgid ""
"When first creating or testing a firewall ruleset, consider temporarily "
"setting this tunable:"
msgstr ""
"방화벽 규칙 집합을 처음 만들거나 테스트할 때는 이 튜너블을 임시로 설정하는 것"
"이 좋습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1275
#, no-wrap
msgid "net.inet.ip.fw.default_to_accept=\"1\"\n"
msgstr "net.inet.ip.fw.default_to_accept=\"1\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1278
msgid ""
"This sets the default policy of man:ipfw[8] to be more permissive than the "
"default `deny ip from any to any`, making it slightly more difficult to get "
"locked out of the system right after a reboot."
msgstr ""
"이렇게 하면 man:ipfw[8]의 기본 정책이 기본값인 `deny ip from any to any` 보다"
"는 허용적으로 설정되어 재부팅 직후 접근이 차단될 가능성이 낮아집니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1283
msgid ""
"The firewall script begins by indicating that it is a Bourne shell script "
"and flushes any existing rules.  It then creates the `cmd` variable so that "
"`ipfw add` does not have to be typed at the beginning of every rule.  It "
"also defines the `pif` variable which represents the name of the interface "
"that is attached to the Internet."
msgstr ""
"방화벽 스크립트는 본 셸 스크립트(Bourne shell script)라는 것을 나타내는 선언"
"으로 시작하여 기존 규칙을 모두 플러시합니다.  그런 다음 `cmd` 변수를 생성하"
"여 모든 규칙의 시작 부분에 `ipfw add` 를 입력할 필요가 없도록 합니다.  또한 "
"인터넷에 연결된 인터페이스의 이름을 나타내는 `pif` 변수를 정의합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1289
#, no-wrap
msgid ""
"#!/bin/sh\n"
"# Flush out the list before we begin.\n"
"ipfw -q -f flush\n"
msgstr ""
"#!/bin/sh\n"
"# Flush out the list before we begin.\n"
"ipfw -q -f flush\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1293
#, no-wrap
msgid ""
"# Set rules command prefix\n"
"cmd=\"ipfw -q add\"\n"
"pif=\"dc0\"     # interface name of NIC attached to Internet\n"
msgstr ""
"# Set rules command prefix\n"
"cmd=\"ipfw -q add\"\n"
"pif=\"dc0\"     # interface name of NIC attached to Internet\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1296
msgid ""
"The first two rules allow all traffic on the trusted internal interface and "
"on the loopback interface:"
msgstr ""
"처음 두 규칙은 신뢰할 수 있는 내부 인터페이스와 루프백 인터페이스의 모든 트래"
"픽을 허용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1301
#, no-wrap
msgid ""
"# Change xl0 to LAN NIC interface name\n"
"$cmd 00005 allow all from any to any via xl0\n"
msgstr ""
"# Change xl0 to LAN NIC interface name\n"
"$cmd 00005 allow all from any to any via xl0\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1304
#, no-wrap
msgid ""
"# No restrictions on Loopback Interface\n"
"$cmd 00010 allow all from any to any via lo0\n"
msgstr ""
"# No restrictions on Loopback Interface\n"
"$cmd 00010 allow all from any to any via lo0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1307
msgid ""
"The next rule allows the packet through if it matches an existing entry in "
"the dynamic rules table:"
msgstr ""
"다음 규칙은 패킷이 동적 규칙 테이블의 기존 항목과 일치하는 경우 패킷의 통과"
"를 허용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1311
#, no-wrap
msgid "$cmd 00101 check-state\n"
msgstr "$cmd 00101 check-state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1314
msgid ""
"The next set of rules defines which stateful connections internal systems "
"can create to hosts on the Internet:"
msgstr ""
"다음 규칙 세트는 내부 시스템이 인터넷의 호스트에 만들 수 있는 상태분석형 연결"
"을 정의합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1322
#, no-wrap
msgid ""
"# Allow access to public DNS\n"
"# Replace x.x.x.x with the IP address of a public DNS server\n"
"# and repeat for each DNS server in /etc/resolv.conf\n"
"$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state\n"
"$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state\n"
msgstr ""
"# Allow access to public DNS\n"
"# Replace x.x.x.x with the IP address of a public DNS server\n"
"# and repeat for each DNS server in /etc/resolv.conf\n"
"$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state\n"
"$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1328
#, no-wrap
msgid ""
"# Allow access to ISP's DHCP server for cable/DSL configurations.\n"
"# Use the first rule and check log for IP address.\n"
"# Then, uncomment the second rule, input the IP address, and delete the first rule\n"
"$cmd 00120 allow log udp from any to any 67 out via $pif keep-state\n"
"#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state\n"
msgstr ""
"# Allow access to ISP's DHCP server for cable/DSL configurations.\n"
"# Use the first rule and check log for IP address.\n"
"# Then, uncomment the second rule, input the IP address, and delete the first rule\n"
"$cmd 00120 allow log udp from any to any 67 out via $pif keep-state\n"
"#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1332
#, no-wrap
msgid ""
"# Allow outbound HTTP and HTTPS connections\n"
"$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state\n"
"$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state\n"
msgstr ""
"# Allow outbound HTTP and HTTPS connections\n"
"$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state\n"
"$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1336
#, no-wrap
msgid ""
"# Allow outbound email connections\n"
"$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state\n"
"$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state\n"
msgstr ""
"# Allow outbound email connections\n"
"$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state\n"
"$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1339
#, no-wrap
msgid ""
"# Allow outbound ping\n"
"$cmd 00250 allow icmp from any to any out via $pif keep-state\n"
msgstr ""
"# Allow outbound ping\n"
"$cmd 00250 allow icmp from any to any out via $pif keep-state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1342
#, no-wrap
msgid ""
"# Allow outbound NTP\n"
"$cmd 00260 allow udp from any to any 123 out via $pif keep-state\n"
msgstr ""
"# Allow outbound NTP\n"
"$cmd 00260 allow udp from any to any 123 out via $pif keep-state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1345
#, no-wrap
msgid ""
"# Allow outbound SSH\n"
"$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state\n"
msgstr ""
"# Allow outbound SSH\n"
"$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1348
#, no-wrap
msgid ""
"# deny and log all other outbound connections\n"
"$cmd 00299 deny log all from any to any out via $pif\n"
msgstr ""
"# deny and log all other outbound connections\n"
"$cmd 00299 deny log all from any to any out via $pif\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1353
msgid ""
"The next set of rules controls connections from Internet hosts to the "
"internal network.  It starts by denying packets typically associated with "
"attacks and then explicitly allows specific types of connections.  All the "
"authorized services that originate from the Internet use `limit` to prevent "
"flooding."
msgstr ""
"다음 규칙 세트는 인터넷 호스트에서 내부 네트워크로의 연결을 제어합니다.  일반"
"적으로 공격과 관련된 패킷을 거부하는 것으로 시작한 다음 특정 유형의 연결을 명"
"시적으로 허용합니다.  인터넷에서 시작되는 모든 승인된 서비스는 플러딩을 방지"
"하기 위해 `limit` 를 사용합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1366
#, no-wrap
msgid ""
"# Deny all inbound traffic from non-routable reserved address spaces\n"
"$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP\n"
"$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP\n"
"$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP\n"
"$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback\n"
"$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback\n"
"$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config\n"
"$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs\n"
"$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect\n"
"$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D & E multicast\n"
msgstr ""
"# Deny all inbound traffic from non-routable reserved address spaces\n"
"$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP\n"
"$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP\n"
"$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP\n"
"$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback\n"
"$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback\n"
"$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config\n"
"$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs\n"
"$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect\n"
"$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D & E multicast\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1369
#, no-wrap
msgid ""
"# Deny public pings\n"
"$cmd 00310 deny icmp from any to any in via $pif\n"
msgstr ""
"# Deny public pings\n"
"$cmd 00310 deny icmp from any to any in via $pif\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1372
#, no-wrap
msgid ""
"# Deny ident\n"
"$cmd 00315 deny tcp from any to any 113 in via $pif\n"
msgstr ""
"# Deny ident\n"
"$cmd 00315 deny tcp from any to any 113 in via $pif\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1378
#, no-wrap
msgid ""
"# Deny all Netbios services.\n"
"$cmd 00320 deny tcp from any to any 137 in via $pif\n"
"$cmd 00321 deny tcp from any to any 138 in via $pif\n"
"$cmd 00322 deny tcp from any to any 139 in via $pif\n"
"$cmd 00323 deny tcp from any to any 81 in via $pif\n"
msgstr ""
"# Deny all Netbios services.\n"
"$cmd 00320 deny tcp from any to any 137 in via $pif\n"
"$cmd 00321 deny tcp from any to any 138 in via $pif\n"
"$cmd 00322 deny tcp from any to any 139 in via $pif\n"
"$cmd 00323 deny tcp from any to any 81 in via $pif\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1381
#, no-wrap
msgid ""
"# Deny fragments\n"
"$cmd 00330 deny all from any to any frag in via $pif\n"
msgstr ""
"# Deny fragments\n"
"$cmd 00330 deny all from any to any frag in via $pif\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1384
#, no-wrap
msgid ""
"# Deny ACK packets that did not match the dynamic rule table\n"
"$cmd 00332 deny tcp from any to any established in via $pif\n"
msgstr ""
"# Deny ACK packets that did not match the dynamic rule table\n"
"$cmd 00332 deny tcp from any to any established in via $pif\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1388
#, no-wrap
msgid ""
"# Allow traffic from ISP's DHCP server.\n"
"# Replace x.x.x.x with the same IP address used in rule 00120.\n"
"#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state\n"
msgstr ""
"# Allow traffic from ISP's DHCP server.\n"
"# Replace x.x.x.x with the same IP address used in rule 00120.\n"
"#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1391
#, no-wrap
msgid ""
"# Allow HTTP connections to internal web server\n"
"$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2\n"
msgstr ""
"# Allow HTTP connections to internal web server\n"
"$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1394
#, no-wrap
msgid ""
"# Allow inbound SSH connections\n"
"$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2\n"
msgstr ""
"# Allow inbound SSH connections\n"
"$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1397
#, no-wrap
msgid ""
"# Reject and log all other incoming connections\n"
"$cmd 00499 deny log all from any to any in via $pif\n"
msgstr ""
"# Reject and log all other incoming connections\n"
"$cmd 00499 deny log all from any to any in via $pif\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1400
msgid ""
"The last rule logs all packets that do not match any of the rules in the "
"ruleset:"
msgstr ""
"마지막 규칙은 규칙 집합의 규칙 중 어떤 규칙과도 일치하지 않는 모든 패킷을 기"
"록합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1405
#, no-wrap
msgid ""
"# Everything else is denied and logged\n"
"$cmd 00999 deny log all from any to any\n"
msgstr ""
"# Everything else is denied and logged\n"
"$cmd 00999 deny log all from any to any\n"

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1408
#, no-wrap
msgid "In-kernel NAT"
msgstr "In-Kernel NAT"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1413
msgid ""
"FreeBSD's IPFW firewall has two implementations of NAT: the userland "
"implementation man:natd[8], and the more recent in-kernel NAT "
"implementation.  Both work in conjunction with IPFW to provide network "
"address translation.  This can be used to provide an Internet Connection "
"Sharing solution so that several internal computers can connect to the "
"Internet using a single public IP address."
msgstr ""
"FreeBSD의 IPFW 방화벽에는 두 가지 NAT 구현이 있습니다: 사용자 공간 구현인 "
"man:natd[8]와 더 최근의 In-Kernel NAT 구현입니다.  둘 다 IPFW와 함께 작동하"
"여 네트워크 주소 변환을 제공합니다.  이는 인터넷 연결 공유 솔루션을 제공하는 "
"데 사용할 수 있으므로 여러 내부 컴퓨터가 단일 공용 IP 주소를 사용하여 인터넷"
"에 연결할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1417
msgid ""
"To do this, the FreeBSD machine connected to the Internet must act as a "
"gateway.  This system must have two NICs, where one is connected to the "
"Internet and the other is connected to the internal LAN.  Each machine "
"connected to the LAN should be assigned an IP address in the private network "
"space, as defined by https://www.ietf.org/rfc/rfc1918.txt[RFC 1918]."
msgstr ""
"이렇게 하려면 인터넷에 연결된 FreeBSD 머신이 게이트웨이 역할을 해야 합니다.  "
"이 시스템에는 두 개의 NIC가 있어야 하며, 하나는 인터넷에 연결되고 다른 하나"
"는 내부 LAN에 연결됩니다.  LAN에 연결된 각 머신은 https://www.ietf.org/rfc/"
"rfc1918.txt[RFC 1918]에 정의된 대로 개인 네트워크 공간에 IP 주소를 할당받아"
"야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1420
msgid ""
"Some additional configuration is needed in order to enable the in-kernel NAT "
"facility of IPFW.  To enable in-kernel NAT support at boot time, the "
"following must be set in [.filename]#/etc/rc.conf#:"
msgstr ""
"IPFW의 In-Kernel NAT 기능을 활성화하려면 몇 가지 추가 구성이 필요합니다.  부"
"팅 시 In-Kernel NAT 지원을 활성화하려면 [.filename]#/etc/rc.conf# 에서 다음"
"을 설정해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1426
#, no-wrap
msgid ""
"gateway_enable=\"YES\"\n"
"firewall_enable=\"YES\"\n"
"firewall_nat_enable=\"YES\"\n"
msgstr ""
"gateway_enable=\"YES\"\n"
"firewall_enable=\"YES\"\n"
"firewall_nat_enable=\"YES\"\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1432
msgid ""
"When `firewall_nat_enable` is set but `firewall_enable` is not, it will have "
"no effect and do nothing.  This is because the in-kernel NAT implementation "
"is only compatible with IPFW."
msgstr ""
"`firewall_nat_enable` 이 설정되어 있지만 `firewall_enable` 이 설정되어 있지 "
"않으면 아무 효과도 없고 아무 일도 하지 않습니다.  이는 커널 내 NAT 구현이 "
"IPFW와만 호환되기 때문입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1439
msgid ""
"When the ruleset contains stateful rules, the positioning of the NAT rule is "
"critical and the `skipto` action is used.  The `skipto` action requires a "
"rule number so that it knows which rule to jump to.  The example below "
"builds upon the firewall ruleset shown in the previous section.  It adds "
"some additional entries and modifies some existing rules in order to "
"configure the firewall for in-kernel NAT.  It starts by adding some "
"additional variables which represent the rule number to skip to, the `keep-"
"state` option, and a list of TCP ports which will be used to reduce the "
"number of rules."
msgstr ""
"규칙 집합에 상태 저장 규칙이 포함된 경우 NAT 규칙의 위치가 중요하며 `skipto` "
"액션이 사용됩니다.  `skipto` 액션에는 어떤 규칙으로 건너뛸지 알 수 있도록 규"
"칙 번호가 필요합니다.  아래 예제는 이전 섹션에 표시된 방화벽 규칙 집합을 기반"
"으로 합니다.  In-Kernel NAT에 대한 방화벽을 구성하기 위해 몇 가지 항목을 추가"
"하고 기존 규칙을 일부 수정합니다.  먼저 skipto 규칙 번호, `keep-state` 옵션, "
"규칙 수를 줄이는 데 사용되는 TCP 포트 목록을 나타내는 몇 가지 변수를 추가합니"
"다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1449
#, no-wrap
msgid ""
"#!/bin/sh\n"
"ipfw -q -f flush\n"
"cmd=\"ipfw -q add\"\n"
"skip=\"skipto 1000\"\n"
"pif=dc0\n"
"ks=\"keep-state\"\n"
"good_tcpo=\"22,25,37,53,80,443,110\"\n"
msgstr ""
"#!/bin/sh\n"
"ipfw -q -f flush\n"
"cmd=\"ipfw -q add\"\n"
"skip=\"skipto 1000\"\n"
"pif=dc0\n"
"ks=\"keep-state\"\n"
"good_tcpo=\"22,25,37,53,80,443,110\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1454
msgid ""
"With in-kernel NAT it is necessary to disable TCP segmentation offloading "
"(TSO) due to the architecture of man:libalias[3], a library implemented as a "
"kernel module to provide the in-kernel NAT facility of IPFW.  TSO can be "
"disabled on a per network interface basis using man:ifconfig[8] or on a "
"system wide basis using man:sysctl[8].  To disable TSO system wide, the "
"following must be set it [.filename]#/etc/sysctl.conf#:"
msgstr ""
"In-Kernel NAT를 사용하려면, IPFW에 In-Kernel NAT 기능을 제공하기 위해, 커널 "
"모듈로 구현된 라이브러리인 man:libalias[3]의 아키텍처로 인해 TCP 세그먼트 오"
"프로딩(TSO)을 비활성화해야 합니다.  TSO는 man:ifconfig[8]를 사용하여 네트워"
"크 인터페이스별로 비활성화하거나 man:sysctl[8]을 사용하여 시스템 전체에서 비"
"활성화할 수 있습니다.  시스템 전체에서 TSO를 비활성화하려면 [.filename]#/etc/"
"sysctl.conf# 에 다음과 같이 설정해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1458
#, no-wrap
msgid "net.inet.tcp.tso=\"0\"\n"
msgstr "net.inet.tcp.tso=\"0\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1467
msgid ""
"A NAT instance will also be configured.  It is possible to have multiple NAT "
"instances each with their own configuration.  For this example only one NAT "
"instance is needed, NAT instance number 1.  The configuration can take a few "
"options such as: `if` which indicates the public interface, `same_ports` "
"which takes care that aliased ports and local port numbers are mapped the "
"same, `unreg_only` will result in only unregistered (private) address spaces "
"to be processed by the NAT instance, and `reset` which will help to keep a "
"functioning NAT instance even when the public IP address of the IPFW machine "
"changes.  For all possible options that can be passed to a single NAT "
"instance configuration consult man:ipfw[8].  When configuring a stateful "
"NATing firewall, it is necessary to allow translated packets to be "
"reinjected in the firewall for further processing.  This can be achieved by "
"disabling `one_pass` behavior at the start of the firewall script."
msgstr ""
"NAT 인스턴스도 구성합니다.  각각 고유한 구성으로 여러 개의 NAT 인스턴스를 가"
"질 수 있습니다.  이 예제에서는 NAT 인스턴스 번호 1인 NAT 인스턴스 하나만 필요"
"합니다.  구성에는 다음과 같은 몇 가지 옵션을 사용할 수 있습니다: 공용 인터페"
"이스를 나타내는 `if`, 별칭 포트와 로컬 포트 번호가 동일하게 매핑되도록 하는 "
"`same_ports`, 등록되지 않은(개인) 주소 공간만 NAT 인스턴스에서 처리하도록 하"
"는 `unreg_only`, IPFW 머신의 공인 IP 주소가 변경되더라도 작동하는 NAT 인스턴"
"스를 유지하는 데 도움이 되는 `reset` 등이 있습니다.  단일 NAT 인스턴스 구성"
"에 전달할 수 있는 모든 가능한 옵션은 man:ipfw[8]을 참조하세요.  상태분석형 "
"NAT 방화벽을 구성할 때는 추가 처리를 위해 변환된 패킷을 방화벽에 재주입할 수 "
"있도록 허용해야 합니다.  이는 방화벽 스크립트 시작 시 `one_pass` 동작을 비활"
"성화하면 됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1472
#, no-wrap
msgid ""
"ipfw disable one_pass\n"
"ipfw -q nat 1 config if $pif same_ports unreg_only reset\n"
msgstr ""
"ipfw disable one_pass\n"
"ipfw -q nat 1 config if $pif same_ports unreg_only reset\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1478
msgid ""
"The inbound NAT rule is inserted _after_ the two rules which allow all "
"traffic on the trusted and loopback interfaces and after the reassemble rule "
"but _before_ the `check-state` rule.  It is important that the rule number "
"selected for this NAT rule, in this example `100`, is higher than the first "
"three rules and lower than the `check-state` rule.  Furthermore, because of "
"the behavior of in-kernel NAT it is advised to place a reassemble rule just "
"before the first NAT rule and after the rules that allow traffic on trusted "
"interface.  Normally, IP fragmentation should not happen, but when dealing "
"with IPSEC/ESP/GRE tunneling traffic it might and the reassembling of "
"fragments is necessary before handing the complete packet over to the in-"
"kernel NAT facility."
msgstr ""
"인바운드 NAT 규칙은 신뢰할 수 있는 인터페이스와 루프백 인터페이스의 모든 트래"
"픽을 허용하는 두 규칙의 _뒤에_ 삽입되지만 `check-state` 규칙의 _앞에_ 삽입됩"
"니다.  이 NAT 규칙에 대해 선택한 규칙 번호( 이 예제에서는 `100` )가 처음 세 "
"규칙보다 높고 `check-state` 규칙보다 낮은 것이 중요합니다.  또한, In-Kernel "
"NAT의 동작으로 인해 재조립 규칙은 첫 번째 NAT 규칙 바로 앞과 신뢰할 수 있는 "
"인터페이스의 트래픽을 허용하는 규칙 뒤에 배치하는 것이 좋습니다.  일반적으로 "
"IP 조각화는 발생하지 않아야 하지만 IPSEC/ESP/GRE 터널링 트래픽을 처리할 때는 "
"조각화가 발생할 수 있으며, 전체 패킷을 In-Kernel NAT 기능으로 넘기기 전에 조"
"각을 재조립해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1482
msgid ""
"The reassemble rule was not needed with userland man:natd[8] because the "
"internal workings of the IPFW `divert` action already takes care of "
"reassembling packets before delivery to the socket as also stated in man:"
"ipfw[8]."
msgstr ""
"재조립 규칙은 사용자 공간 man:natd[8]에서는 필요하지 않은데, 이는 man:ipfw[8]"
"에도 명시된 것처럼 IPFW `divert` 액션의 내부 동작이 이미 소켓으로 전달되기 전"
"에 패킷 재조립을 처리하기 때문입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1485
msgid ""
"The NAT instance and rule number used in this example does not match with "
"the default NAT instance and rule number created by [.filename]#rc."
"firewall#.  [.filename]#rc.firewall# is a script that sets up the default "
"firewall rules present in FreeBSD."
msgstr ""
"이 예제에서 사용된 NAT 인스턴스 및 규칙 번호가 [.filename]#rc.firewall# 에서 "
"만든 기본 NAT 인스턴스 및 규칙 번호와 일치하지 않습니다.  [.filename]#rc."
"firewall# 은 FreeBSD에 있는 기본 방화벽 규칙을 설정하는 스크립트입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1495
#, no-wrap
msgid ""
"$cmd 005 allow all from any to any via xl0  # exclude LAN traffic\n"
"$cmd 010 allow all from any to any via lo0  # exclude loopback traffic\n"
"$cmd 099 reass all from any to any in       # reassemble inbound packets\n"
"$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets\n"
"# Allow the packet through if it has an existing entry in the dynamic rules table\n"
"$cmd 101 check-state\n"
msgstr ""
"$cmd 005 allow all from any to any via xl0  # exclude LAN traffic\n"
"$cmd 010 allow all from any to any via lo0  # exclude loopback traffic\n"
"$cmd 099 reass all from any to any in       # reassemble inbound packets\n"
"$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets\n"
"# Allow the packet through if it has an existing entry in the dynamic rules table\n"
"$cmd 101 check-state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1499
msgid ""
"The outbound rules are modified to replace the `allow` action with the `"
"$skip` variable, indicating that rule processing will continue at rule "
"`1000`.  The seven `tcp` rules have been replaced by rule `125` as the `"
"$good_tcpo` variable contains the seven allowed outbound ports."
msgstr ""
"아웃바운드 규칙은 규칙 `1000` 에서 규칙 처리가 계속됨을 나타내는 `$skip` 변수"
"로 `allow` 동작을 대체하도록 수정되었습니다.  7개의 `tcp` 규칙은 `"
"$good_tcpo` 변수에 허용된 7개의 아웃바운드 포트가 포함되어 있으므로 규칙 "
"`125` 로 대체되었습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1503
msgid ""
"Remember that IPFW's performance is largely determined by the number of "
"rules present in the ruleset."
msgstr ""
"IPFW의 성능은 규칙 집합에 존재하는 규칙의 수에 따라 크게 결정된다는 점을 기억"
"하세요."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1512
#, no-wrap
msgid ""
"# Authorized outbound packets\n"
"$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks\n"
"$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks\n"
"$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks\n"
"$cmd 130 $skip icmp from any to any out via $pif $ks\n"
msgstr ""
"# Authorized outbound packets\n"
"$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks\n"
"$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks\n"
"$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks\n"
"$cmd 130 $skip icmp from any to any out via $pif $ks\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1518
msgid ""
"The inbound rules remain the same, except for the very last rule which "
"removes the `via $pif` in order to catch both inbound and outbound rules.  "
"The NAT rule must follow this last outbound rule, must have a higher number "
"than that last rule, and the rule number must be referenced by the `skipto` "
"action.  In this ruleset, rule number `1000` handles passing all packets to "
"our configured instance for NAT processing.  The next rule allows any packet "
"which has undergone NAT processing to pass."
msgstr ""
"인바운드 규칙은 인바운드 및 아웃바운드 규칙을 모두 잡기 위해 `via $pif` 를 제"
"거하는 맨 마지막 규칙을 제외하고는 동일하게 유지됩니다.  NAT 규칙은 이 마지"
"막 아웃바운드 규칙을 따라야 하며, 마지막 규칙보다 번호가 높아야 하고, 규칙 번"
"호는 `skipto` 액션에서 참조해야 합니다.  이 규칙 집합에서 규칙 번호 `1000` "
"은 NAT 처리를 위해 구성된 인스턴스로 모든 패킷을 전달하여 처리합니다.  다음 "
"규칙은 NAT 처리를 거친 모든 패킷을 통과하도록 허용합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1524
#, no-wrap
msgid ""
"$cmd 999 deny log all from any to any\n"
"$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules\n"
"$cmd 1001 allow ip from any to any\n"
msgstr ""
"$cmd 999 deny log all from any to any\n"
"$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules\n"
"$cmd 1001 allow ip from any to any\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1527
msgid ""
"In this example, rules `100`, `101`, `125`, `1000`, and `1001` control the "
"address translation of the outbound and inbound packets so that the entries "
"in the dynamic state table always register the private LANIP address."
msgstr ""
"이 예에서 규칙 `100`, `101`, `125`, `1000` 및 `1001` 은 아웃바운드 및 인바운"
"드 패킷의 주소 변환을 제어하여 동적 상태 테이블의 항목에 항상 개인 LANIP 주소"
"가 등록되도록 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1539
msgid ""
"Consider an internal web browser which initializes a new outbound HTTP "
"session over port 80.  When the first outbound packet enters the firewall, "
"it does not match rule `100` because it is headed out rather than in.  It "
"passes rule `101` because this is the first packet and it has not been "
"posted to the dynamic state table yet.  The packet finally matches rule "
"`125` as it is outbound on an allowed port and has a source IP address from "
"the internal LAN.  On matching this rule, two actions take place.  First, "
"the `keep-state` action adds an entry to the dynamic state table and the "
"specified action, `skipto rule 1000`, is executed.  Next, the packet "
"undergoes NAT and is sent out to the Internet.  This packet makes its way to "
"the destination web server, where a response packet is generated and sent "
"back.  This new packet enters the top of the ruleset.  It matches rule `100` "
"and has its destination IP address mapped back to the original internal "
"address.  It then is processed by the `check-state` rule, is found in the "
"table as an existing session, and is released to the LAN."
msgstr ""
"포트 80을 통해 새로운 아웃바운드 HTTP 세션을 초기화하는 내부 웹 브라우저를 생"
"각해 봅시다.  첫 번째 아웃바운드 패킷이 방화벽에 들어올 때, 이 패킷은 들어오"
"는 방향이 아니라 나가는 방향이기 때문에 규칙 `100` 과 일치하지 않습니다.  이 "
"패킷은 첫 번째 패킷이고 아직 동적 상태 테이블에 게시되지 않았기 때문에 규칙 "
"`101` 을 통과합니다.  패킷은 허용된 포트에서 아웃바운드되고 내부 LAN의 소스 "
"IP 주소를 가지고 있기 때문에 규칙 `125` 와 최종적으로 일치합니다.  이 규칙과 "
"일치하면 두 가지 작업이 수행됩니다.  먼저 `keep-state` 동작으로 동적 상태 테"
"이블에 항목이 추가되고 지정된 동작인 `skipto rule 1000` 이 실행됩니다.  다음"
"으로 패킷이 NAT를 거쳐 인터넷으로 전송됩니다.  이 패킷은 대상 웹 서버로 이동"
"하여 응답 패킷이 생성되어 다시 전송됩니다.  이 새 패킷은 규칙 세트의 맨 위에 "
"들어갑니다.  이 패킷은 규칙 `100` 과 일치하며 대상 IP 주소가 원래 내부 주소"
"로 다시 매핑됩니다.  그런 다음 `check-state` 규칙에 의해 처리되고 테이블에서 "
"기존 세션으로 발견되어 LAN으로 릴리스됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1544
msgid ""
"On the inbound side, the ruleset has to deny bad packets and allow only "
"authorized services.  A packet which matches an inbound rule is posted to "
"the dynamic state table and the packet is released to the LAN.  The packet "
"generated as a response is recognized by the `check-state` rule as belonging "
"to an existing session.  It is then sent to rule `1000` to undergo NAT "
"before being released to the outbound interface."
msgstr ""
"인바운드 측에서 규칙 집합은 잘못된 패킷을 거부하고 승인된 서비스만 허용해야 "
"합니다.  인바운드 규칙과 일치하는 패킷은 동적 상태 테이블에 게시되고 패킷은 "
"LAN으로 릴리스됩니다.  응답으로 생성된 패킷은 `check-state` 규칙에 의해 기존 "
"세션에 속한 것으로 인식됩니다.  그런 다음 `1000` 규칙으로 전송되어 NAT를 거"
"친 후 아웃바운드 인터페이스로 릴리스됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1552
msgid ""
"Transitioning from userland man:natd[8] to in-kernel NAT might appear "
"seamless at first but there is small catch.  When using the GENERIC kernel, "
"IPFW will load the [.filename]#libalias.ko# kernel module, when "
"`firewall_nat_enable` is enabled in [.filename]#/etc/rc.conf#.  The [."
"filename]#libalias.ko# kernel module only provides basic NAT functionality, "
"whereas the userland implementation man:natd[8] has all NAT functionality "
"available in its userland library without any extra configuration.  All "
"functionality refers to the following kernel modules that can additionally "
"be loaded when needed besides the standard [.filename]#libalias.ko# kernel "
"module: [.filename]#alias_ftp.ko#, [.filename]#alias_bbt.ko#, [."
"filename]#skinny.ko#, [.filename]#irc.ko#, [.filename]#alias_pptp.ko# and [."
"filename]#alias_smedia.ko# using the `kld_list` directive in [.filename]#/"
"etc/rc.conf#.  If a custom kernel is used, the full functionality of the "
"userland library can be compiled in, in the kernel, using the `options "
"LIBALIAS`."
msgstr ""
"사용자 공간의 man:natd[8]에서 in-Kernel NAT로 전환하는 것은 처음에는 매끄럽"
"게 보일 수 있지만 작은 문제가 있습니다.  기본 커널(GENERIC kernel)을 사용할 "
"때, [.filename]#/etc/rc.conf# 에서 `firewall_nat_enable` 이 활성화되면 IPFW"
"는 [.filename]#libalias.ko# 커널 모듈을 로드합니다.  [.filename]#libalias."
"ko# 커널 모듈은 기본 NAT 기능만 제공하는 반면, 사용자 공간 구현 man:natd[8]"
"는 추가 구성 없이 사용자 공간 라이브러리에서 모든 NAT 기능을 사용할 수 있습니"
"다.  모든 기능은 표준 [.filename]#libalias.ko# 커널 모듈 외에 필요할 때 추가"
"로 로드할 수 있는 다음 커널 모듈을 참조합니다: [.filename]#alias_ftp.ko#, [."
"filename]#alias_bbt.ko#, [.filename]#skinny.ko#, [.filename]#irc.ko#, [."
"filename]#alias_pptp.ko# 및 [.filename]#alias_smedia.ko# 를 [.filename]#/etc/"
"rc.conf# 에서 `kld_list` 지시어를 사용하여 로드합니다.  커스텀 커널을 사용하"
"는 경우 커널에서 `options LIBALIAS` 를 사용하여 사용자 공간 라이브러리의 전"
"체 기능을 컴파일할 수 있습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1554
#, no-wrap
msgid "Port Redirection"
msgstr "포트 리디렉션"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1560
msgid ""
"The drawback with NAT in general is that the LAN clients are not accessible "
"from the Internet.  Clients on the LAN can make outgoing connections to the "
"world but cannot receive incoming ones.  This presents a problem if trying "
"to run Internet services on one of the LAN client machines.  A simple way "
"around this is to redirect selected Internet ports on the NAT providing "
"machine to a LAN client."
msgstr ""
"일반적으로 NAT의 단점은 인터넷에서 LAN 클라이언트에 액세스할 수 없다는 것입니"
"다.  LAN의 클라이언트는 밖으로 나가는 연결은 할 수 있지만 들어오는 연결은 받"
"을 수 없습니다.  이는 LAN 클라이언트 컴퓨터 중 하나에서 인터넷 서비스를 실행"
"하려고 할 때 문제가 됩니다.  이 문제를 해결하는 간단한 방법은 NAT 제공 머신에"
"서 선택한 인터넷 포트를 LAN 클라이언트로 리디렉션하는 것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1563
msgid ""
"For example, an IRC server runs on client `A` and a web server runs on "
"client `B`.  For this to work properly, connections received on ports 6667 "
"(IRC) and 80 (HTTP) must be redirected to the respective machines."
msgstr ""
"예를 들어, IRC 서버는 클라이언트 `A` 에서 실행되고 웹 서버는 클라이언트 `B` "
"에서 실행됩니다.  이 기능이 제대로 작동하려면 포트 6667(IRC)과 80(HTTP)에서 "
"수신된 연결이 각 컴퓨터로 리디렉션되어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1567
msgid ""
"With in-kernel NAT all configuration is done in the NAT instance "
"configuration.  For a full list of options that an in-kernel NAT instance "
"can use, consult man:ipfw[8].  The IPFW syntax follows the syntax of natd. "
"The syntax for `redirect_port` is as follows:"
msgstr ""
"In-Kernel 를 사용하면 모든 구성이 NAT 인스턴스 구성에서 이루어집니다.  In-"
"Kernel NAT 인스턴스가 사용할 수 있는 전체 옵션 목록은 man:ipfw[8]를 참조하세"
"요.  IPFW 구문은 natd의 구문을 따릅니다. `redirect_port` 의 구문은 다음과 같"
"습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1573
#, no-wrap
msgid ""
"redirect_port proto targetIP:targetPORT[-targetPORT]\n"
"  [aliasIP:]aliasPORT[-aliasPORT]\n"
"  [remoteIP[:remotePORT[-remotePORT]]]\n"
msgstr ""
"redirect_port proto targetIP:targetPORT[-targetPORT]\n"
"  [aliasIP:]aliasPORT[-aliasPORT]\n"
"  [remoteIP[:remotePORT[-remotePORT]]]\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1576
msgid "To configure the above example setup, the arguments should be:"
msgstr "위의 예제의 설정을 구성하려면 인수는 다음과 같아야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1581
#, no-wrap
msgid ""
"redirect_port tcp 192.168.0.2:6667 6667\n"
"redirect_port tcp 192.168.0.3:80 80\n"
msgstr ""
"redirect_port tcp 192.168.0.2:6667 6667\n"
"redirect_port tcp 192.168.0.3:80 80\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1584
msgid ""
"After adding these arguments to the configuration of NAT instance 1 in the "
"above ruleset, the TCP ports will be port forwarded to the LAN client "
"machines running the IRC and HTTP services."
msgstr ""
"위의 규칙 집합에서 NAT 인스턴스 1의 구성에 이러한 인수를 추가하면 TCP 포트가 "
"IRC 및 HTTP 서비스를 실행하는 LAN 클라이언트 머신으로 포트 포워딩됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1590
#, no-wrap
msgid ""
"ipfw -q nat 1 config if $pif same_ports unreg_only reset \\\n"
"  redirect_port tcp 192.168.0.2:6667 6667 \\\n"
"  redirect_port tcp 192.168.0.3:80 80\n"
msgstr ""
"ipfw -q nat 1 config if $pif same_ports unreg_only reset \\\n"
"  redirect_port tcp 192.168.0.2:6667 6667 \\\n"
"  redirect_port tcp 192.168.0.3:80 80\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1594
msgid ""
"Port ranges over individual ports can be indicated with `redirect_port`.  "
"For example, _tcp 192.168.0.2:2000-3000 2000-3000_ would redirect all "
"connections received on ports 2000 to 3000 to ports 2000 to 3000 on client "
"`A`."
msgstr ""
"개별 포트에 대한 포트 범위는 `redirect_port` 로 표시할 수 있습니다.  예를 들"
"어 _tcp 192.168.0.2:2000-3000 2000-3000_ 은 포트 2000에서 3000으로 수신된 모"
"든 연결을 클라이언트 `A` 의 포트 2000에서 3000으로 리디렉션합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1595
#, no-wrap
msgid "Address Redirection"
msgstr "주소 리디렉션"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1601
msgid ""
"Address redirection is useful if more than one IP address is available.  "
"Each LAN client can be assigned its own external IP address by man:ipfw[8], "
"which will then rewrite outgoing packets from the LAN clients with the "
"proper external IP address and redirects all traffic incoming on that "
"particular IP address back to the specific LAN client.  This is also known "
"as static NAT.  For example, if IP addresses `128.1.1.1`, `128.1.1.2`, and "
"`128.1.1.3` are available, `128.1.1.1` can be used as the man:ipfw[8] "
"machine's external IP address, while `128.1.1.2` and `128.1.1.3` are "
"forwarded back to LAN clients `A` and `B`."
msgstr ""
"주소 리디렉션은 둘 이상의 IP 주소를 사용할 수 있는 경우에 유용합니다.  각 "
"LAN 클라이언트는 man:ipfw[8]를 통해 자체 외부 IP 주소를 할당할 수 있으며, 이"
"를 통해 LAN 클라이언트에서 보내는 패킷을 적절한 외부 IP 주소로 다시 작성하고 "
"특정 IP 주소로 들어오는 모든 트래픽을 특정 LAN 클라이언트로 리디렉션합니다.  "
"이를 정적 NAT(static NAT)라고도 합니다.  예를 들어, `128.1.1.1`, "
"`128.1.1.2`, `128.1.1.3` IP 주소를 사용할 수 있는 경우, `128.1.1.1` 은 man:"
"ipfw[8] 컴퓨터의 외부 IP 주소로 사용할 수 있고 `128.1.1.2` 와 `128.1.1.3` 은 "
"LAN 클라이언트 `A` 와 `B` 로 다시 포워딩합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1603
msgid ""
"The `redirect_addr` syntax is as below, where `localIP` is the internal IP "
"address of the LAN client, and `publicIP` the external IP address "
"corresponding to the LAN client."
msgstr ""
"`redirect_addr` 구문은 아래와 같으며, 여기서 `localIP` 는 LAN 클라이언트의 내"
"부 IP 주소, `publicIP` 는 LAN 클라이언트에 해당하는 외부 IP 주소입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1607
#, no-wrap
msgid "redirect_addr localIP publicIP\n"
msgstr "redirect_addr localIP publicIP\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1610
msgid "In the example, the arguments would read:"
msgstr "이 예제에서 인수는 다음과 같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1615
#, no-wrap
msgid ""
"redirect_addr 192.168.0.2 128.1.1.2\n"
"redirect_addr 192.168.0.3 128.1.1.3\n"
msgstr ""
"redirect_addr 192.168.0.2 128.1.1.2\n"
"redirect_addr 192.168.0.3 128.1.1.3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1619
msgid ""
"Like `redirect_port`, these arguments are placed in a NAT instance "
"configuration.  With address redirection, there is no need for port "
"redirection, as all data received on a particular IP address is redirected."
msgstr ""
"`redirect_port` 와 마찬가지로 이러한 인수는 NAT 인스턴스 구성에 위치합니다.  "
"주소 리디렉션을 사용하면 특정 IP 주소로 수신되는 모든 데이터가 리디렉션되므"
"로 포트 리디렉션이 필요하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1622
msgid ""
"The external IP addresses on the man:ipfw[8] machine must be active and "
"aliased to the external interface.  Refer to man:rc.conf[5] for details."
msgstr ""
"man:ipfw[8] 머신의 외부 IP 주소는 활성 상태여야 하며 외부 인터페이스에 앨리어"
"싱되어야 합니다.  자세한 내용은 man:rc.conf[5]를 참조하세요."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1623
#, no-wrap
msgid "Userspace NAT"
msgstr "사용자 공간 NAT"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1627
msgid ""
"Let us start with a statement: the userspace NAT implementation: man:"
"natd[8], has more overhead than in-kernel NAT.  For man:natd[8] to translate "
"packets, the packets have to be copied from the kernel to userspace and back "
"which brings in extra overhead that is not present with in-kernel NAT."
msgstr ""
"먼저 다음 문장부터 시작합시다: 사용자 공간 NAT 구현인 man:natd[8]는 In-"
"kernel NAT보다 오버헤드가 더 많습니다.  man:natd[8]가 패킷을 변환하려면 패킷"
"을 커널에서 복사하고 다시 사용자 공간으로 복사해야 하므로 In-kernel NAT에는 "
"없는 추가 오버헤드가 발생합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1631
#, fuzzy
#| msgid ""
#| "To enable the userpace NAT daemon man:natd[8] at boot time, the following "
#| "is a minimum configuration in [.filename]#/etc/rc.conf#.  Where "
#| "`natd_interface` is set to the name of the NIC attached to the Internet.  "
#| "The man:rc[8] script of man:natd[8] will automatically check if a dynamic "
#| "IP address is used and configure itself to handle that."
msgid ""
"To enable the userspace NAT daemon man:natd[8] at boot time, the following "
"is a minimum configuration in [.filename]#/etc/rc.conf#.  Where "
"`natd_interface` is set to the name of the NIC attached to the Internet.  "
"The man:rc[8] script of man:natd[8] will automatically check if a dynamic IP "
"address is used and configure itself to handle that."
msgstr ""
"부팅 시 사용자 공간 NAT 데몬 man:natd[8]를 활성화하려면 [.filename]#/etc/rc."
"conf# 에 최소 다음과 같은 구성을 지정해야 합니다.  여기서 `natd_interface` "
"는 인터넷에 연결된 NIC의 이름으로 설정됩니다.  man:natd[8]의 man:rc[8] 스크립"
"트는 동적 IP 주소가 사용되는지 자동으로 확인하고 이를 처리하도록 자체 구성합"
"니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1637
#, no-wrap
msgid ""
"gateway_enable=\"YES\"\n"
"natd_enable=\"YES\"\n"
"natd_interface=\"rl0\"\n"
msgstr ""
"gateway_enable=\"YES\"\n"
"natd_enable=\"YES\"\n"
"natd_interface=\"rl0\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1642
msgid ""
"In general, the above ruleset as explained for in-kernel NAT can also be "
"used together with man:natd[8].  The exceptions are the configuration of the "
"in-kernel NAT instance `(ipfw -q nat 1 config ...)` which is not needed "
"together with reassemble rule 99 because its functionality is included in "
"the `divert` action.  Rule number 100 and 1000 will have to change sligthly "
"as shown below."
msgstr ""
"일반적으로, In-kernel NAT에 대해 설명한 위의 규칙 집합은 man:natd[8]와 함께 "
"사용할 수도 있습니다.  예외는 In-kernel NAT 인스턴스 `(ipfw -q nat 1 config "
"…)` 의 구성인데, 이 기능은 `divert` 액션에 포함되어 있기 때문에 재조립 규칙 "
"99와 함께 사용할 필요가 없습니다.  규칙 번호 100과 1000은 아래와 같이 조금씩 "
"변경해야 합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1647
#, no-wrap
msgid ""
"$cmd 100 divert natd ip from any to any in via $pif\n"
"$cmd 1000 divert natd ip from any to any out via $pif\n"
msgstr ""
"$cmd 100 divert natd ip from any to any in via $pif\n"
"$cmd 1000 divert natd ip from any to any out via $pif\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1652
msgid ""
"To configure port or address redirection, a similar syntax as with in-kernel "
"NAT is used.  Although, now, instead of specifying the configuration in our "
"ruleset script like with in-kernel NAT, configuration of man:natd[8] is best "
"done in a configuration file.  To do this, an extra flag must be passed via "
"[.filename]#/etc/rc.conf# which specifies the path of the configuration file."
msgstr ""
"포트 또는 주소 리디렉션을 구성하려면 In-kernel NAT와 유사한 구문이 사용됩니"
"다.  하지만 이제는 In-kernel NAT처럼 규칙 집합 스크립트에서 구성을 지정하는 "
"대신 구성 파일에서 man:natd[8]를 구성하는 것이 가장 좋습니다.  이렇게 하려면 "
"구성 파일의 경로를 지정하는 [.filename]#/etc/rc.conf# 를 통해 추가 플래그를 "
"전달해야 합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1656
#, no-wrap
msgid "natd_flags=\"-f /etc/natd.conf\"\n"
msgstr "natd_flags=\"-f /etc/natd.conf\"\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1663
msgid ""
"The specified file must contain a list of configuration options, one per "
"line.  For more information about the configuration file and possible "
"variables, consult man:natd[8].  Below are two example entries, one per line:"
msgstr ""
"지정된 파일에는 한 줄에 하나씩 구성 옵션 목록이 포함되어야 합니다.  구성 파"
"일 및 사용 가능한 변수에 대한 자세한 내용은 man:natd[8]을 참조하세요.  다음"
"은 한 줄에 하나씩 두 개의 예제 항목입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1668
#, no-wrap
msgid ""
"redirect_port tcp 192.168.0.2:6667 6667\n"
"redirect_addr 192.168.0.3 128.1.1.3\n"
msgstr ""
"redirect_port tcp 192.168.0.2:6667 6667\n"
"redirect_addr 192.168.0.3 128.1.1.3\n"

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1673
#, no-wrap
msgid "The IPFW Command"
msgstr "IPFW 명령어"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1678
msgid ""
"`ipfw` can be used to make manual, single rule additions or deletions to the "
"active firewall while it is running.  The problem with using this method is "
"that all the changes are lost when the system reboots.  It is recommended to "
"instead write all the rules in a file and to use that file to load the rules "
"at boot time and to replace the currently running firewall rules whenever "
"that file changes."
msgstr ""
"`ipfw` 를 사용하여 활성 방화벽이 실행되는 동안 수동으로 단일 규칙을 추가하거"
"나 삭제할 수 있습니다.  이 방법을 사용하면 시스템이 재부팅될 때 모든 변경 사"
"항이 손실된다는 문제가 있습니다.  대신 모든 규칙을 파일에 작성하고 해당 파일"
"을 사용하여 부팅 시 규칙을 로드하고 해당 파일이 변경될 때마다 현재 실행 중인 "
"방화벽 규칙을 교체하는 것이 좋습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1682
msgid ""
"`ipfw` is a useful way to display the running firewall rules to the console "
"screen.  The IPFW accounting facility dynamically creates a counter for each "
"rule that counts each packet that matches the rule.  During the process of "
"testing a rule, listing the rule with its counter is one way to determine if "
"the rule is functioning as expected."
msgstr ""
"`ipfw` 는 실행 중인 방화벽 규칙을 콘솔 화면에 표시하는 유용한 방법입니다.  "
"IPFW 계정 기능은 각 규칙에 대한 카운터를 동적으로 생성하여 규칙과 일치하는 "
"각 패킷을 계산합니다.  규칙을 테스트하는 과정에서 카운터와 함께 규칙을 나열하"
"는 것은 규칙이 예상대로 작동하는지 확인하는 한 가지 방법입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1684
msgid "To list all the running rules in sequence:"
msgstr "실행 중인 모든 규칙을 순서대로 나열하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1688
#, no-wrap
msgid "# ipfw list\n"
msgstr "# ipfw list\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1691
msgid ""
"To list all the running rules with a time stamp of when the last time the "
"rule was matched:"
msgstr ""
"실행 중인 모든 규칙을 규칙이 마지막으로 일치한 시간의 타임스탬프와 함께 나열"
"하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1695
#, no-wrap
msgid "# ipfw -t list\n"
msgstr "# ipfw -t list\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1699
msgid ""
"The next example lists accounting information and the packet count for "
"matched rules along with the rules themselves.  The first column is the rule "
"number, followed by the number of matched packets and bytes, followed by the "
"rule itself."
msgstr ""
"다음 예제에는 일치하는 규칙에 대한 계정 정보 및 패킷 수가 규칙 자체와 함께 나"
"열되어 있습니다.  첫 번째 열은 규칙 번호이고, 그 다음에는 일치하는 패킷 수와 "
"바이트 수, 그 다음에는 규칙 자체입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1703
#, no-wrap
msgid "# ipfw -a list\n"
msgstr "# ipfw -a list\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1706
msgid "To list dynamic rules in addition to static rules:"
msgstr "정적 규칙과 함께 동적 규칙을 나열하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1710
#, no-wrap
msgid "# ipfw -d list\n"
msgstr "# ipfw -d list\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1713
msgid "To also show the expired dynamic rules:"
msgstr "만료된 동적 규칙도 표시하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1717
#, no-wrap
msgid "# ipfw -d -e list\n"
msgstr "# ipfw -d -e list\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1720
msgid "To zero the counters:"
msgstr "카운터를 초기화하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1724
#, no-wrap
msgid "# ipfw zero\n"
msgstr "# ipfw zero\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1727
msgid "To zero the counters for just the rule with number _NUM_:"
msgstr "숫자 _NUM_ 이 있는 규칙에 대해서만 카운터를 0으로 설정하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1731
#, no-wrap
msgid "# ipfw zero NUM\n"
msgstr "# ipfw zero NUM\n"

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1733
#, no-wrap
msgid "Logging Firewall Messages"
msgstr "방화벽 메시지 기록하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1740
msgid ""
"Even with the logging facility enabled, IPFW will not generate any rule "
"logging on its own.  The firewall administrator decides which rules in the "
"ruleset will be logged, and adds the `log` keyword to those rules.  Normally "
"only deny rules are logged.  It is customary to duplicate the \"ipfw default "
"deny everything\" rule with the `log` keyword included as the last rule in "
"the ruleset.  This way, it is possible to see all the packets that did not "
"match any of the rules in the ruleset."
msgstr ""
"로깅 기능이 활성화되어 있어도 IPFW는 자체적으로 규칙 로그를 생성하지 않습니"
"다.  방화벽 관리자는 규칙 집합에서 어떤 규칙을 기록할지 결정하고 해당 규칙에 "
"`log` 키워드를 추가합니다.  일반적으로 거부 규칙만 기록됩니다.  `log` 키워드"
"를 규칙 집합의 마지막 규칙으로 포함되는 `ipfw default deny everything` 규칙"
"에 복제하는 것이 일반적입니다.  이렇게 하면 규칙 집합의 규칙과 일치하지 않는 "
"모든 패킷을 볼 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1744
msgid ""
"Logging is a two edged sword.  If one is not careful, an over abundance of "
"log data or a DoS attack can fill the disk with log files.  Log messages are "
"not only written to syslogd, but also are displayed on the root console "
"screen and soon become annoying."
msgstr ""
"로깅은 양날의 검입니다.  주의하지 않으면 로그 데이터가 지나치게 많거나 DoS 공"
"격으로 인해 디스크가 로그 파일로 가득 찰 수 있습니다.  로그 메시지는 syslogd"
"에 기록될 뿐만 아니라 루트 콘솔 화면에도 표시되어 곧 성가신 일이 됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1749
msgid ""
"The `IPFIREWALL_VERBOSE_LIMIT=5` kernel option limits the number of "
"consecutive messages sent to man:syslogd[8], concerning the packet matching "
"of a given rule.  When this option is enabled in the kernel, the number of "
"consecutive messages concerning a particular rule is capped at the number "
"specified.  There is nothing to be gained from 200 identical log messages.  "
"With this option set to five, five consecutive messages concerning a "
"particular rule would be logged to syslogd and the remainder identical "
"consecutive messages would be counted and posted to syslogd with a phrase "
"like the following:"
msgstr ""
"`IPFIREWALL_VERBOSE_LIMIT=5` 커널 옵션은 지정된 규칙의 패킷 일치와 관련하여 "
"man:syslogd[8]로 전송되는 연속 메시지 수를 제한합니다.  커널에서 이 옵션을 활"
"성화하면 특정 규칙과 관련된 연속 메시지 수가 지정된 수로 제한됩니다.  200개"
"의 동일한 로그 메시지로는 얻을 수 있는 것이 없습니다.  이 옵션을 5개로 설정하"
"면 특정 규칙과 관련된 연속 메시지 5개가 syslogd에 기록되고 나머지 동일한 연"
"속 메시지가 카운트되어 다음과 같은 문구와 함께 syslogd에 게시됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1753
#, no-wrap
msgid "last message repeated 45 times\n"
msgstr "last message repeated 45 times\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1756
msgid ""
"All logged packets messages are written by default to [.filename]#/var/log/"
"security#, which is defined in [.filename]#/etc/syslog.conf#."
msgstr ""
"모든 로깅된 패킷 메시지는 기본적으로 [.filename]#/var/log/security# 에 기록되"
"며, 이는 [.filename]#/etc/syslog.conf# 에 정의되어 있습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1758
#, no-wrap
msgid "Building a Rule Script"
msgstr "규칙 스크립트 작성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1764
msgid ""
"Most experienced IPFW users create a file containing the rules and code them "
"in a manner compatible with running them as a script.  The major benefit of "
"doing this is the firewall rules can be refreshed in mass without the need "
"of rebooting the system to activate them.  This method is convenient in "
"testing new rules as the procedure can be executed as many times as needed.  "
"Being a script, symbolic substitution can be used for frequently used values "
"to be substituted into multiple rules."
msgstr ""
"대부분의 숙련된 IPFW 사용자는 규칙이 포함된 파일을 만들고 이를 스크립트로 실"
"행할 수 있는 방식으로 코딩합니다.  이렇게 하면 방화벽 규칙을 활성화하기 위해 "
"시스템을 재부팅할 필요 없이 방화벽 규칙을 대량으로 새로 고칠 수 있다는 것이 "
"가장 큰 장점입니다.  이 방법은 필요한 만큼 절차를 실행할 수 있으므로 새 규칙"
"을 테스트할 때 편리합니다.  스크립트이기 때문에 자주 사용하는 값을 변수로 치"
"환할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1769
msgid ""
"This example script is compatible with the syntax used by the man:sh[1], man:"
"csh[1], and man:tcsh[1] shells.  Symbolic substitution fields are prefixed "
"with a dollar sign ($).  Symbolic fields do not have the $ prefix.  The "
"value to populate the symbolic field must be enclosed in double quotes "
"(\"\")."
msgstr ""
"이 예제 스크립트는 man:sh[1], man:csh[1] 및 man:tcsh[1] 셸에서 사용하는 구문"
"과 호환됩니다.  변수 대체 필드 앞에는 달러 기호($)가 붙습니다.  변수 필드에"
"는 $ 접두사가 없습니다.  변수 필드를 채울 값은 큰따옴표(“”)로 묶어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1771
msgid "Start the rules file like this:"
msgstr "다음과 같이 규칙 파일을 시작하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1789
#, no-wrap
msgid ""
"############### start of example ipfw rules script #############\n"
"#\n"
"ipfw -q -f flush       # Delete all rules\n"
"# Set defaults\n"
"oif=\"tun0\"             # out interface\n"
"odns=\"192.0.2.11\"      # ISP's DNS server IP address\n"
"cmd=\"ipfw -q add \"     # build rule prefix\n"
"ks=\"keep-state\"        # just too lazy to key this each time\n"
"$cmd 00500 check-state\n"
"$cmd 00502 deny all from any to any frag\n"
"$cmd 00501 deny tcp from any to any established\n"
"$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks\n"
"$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks\n"
"$cmd 00611 allow udp from any to $odns 53 out via $oif $ks\n"
"################### End of example ipfw rules script ############\n"
msgstr ""
"############### start of example ipfw rules script #############\n"
"#\n"
"ipfw -q -f flush       # Delete all rules\n"
"# Set defaults\n"
"oif=\"tun0\"             # out interface\n"
"odns=\"192.0.2.11\"      # ISP's DNS server IP address\n"
"cmd=\"ipfw -q add \"     # build rule prefix\n"
"ks=\"keep-state\"        # just too lazy to key this each time\n"
"$cmd 00500 check-state\n"
"$cmd 00502 deny all from any to any frag\n"
"$cmd 00501 deny tcp from any to any established\n"
"$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks\n"
"$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks\n"
"$cmd 00611 allow udp from any to $odns 53 out via $oif $ks\n"
"################### End of example ipfw rules script ############\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1792
msgid ""
"The rules are not important as the focus of this example is how the symbolic "
"substitution fields are populated."
msgstr ""
"이 예제에서는 기호 대체 필드가 채워지는 방식에 중점을 두므로 내용 자체는 중요"
"하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1794
msgid ""
"If the above example was in [.filename]#/etc/ipfw.rules#, the rules could be "
"reloaded by the following command:"
msgstr ""
"위의 예가 [.filename]#/etc/ipfw.rules# 에 있었다면 다음 명령으로 규칙을 다시 "
"로드할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1798
#, no-wrap
msgid "# sh /etc/ipfw.rules\n"
msgstr "# sh /etc/ipfw.rules\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1801
msgid ""
"[.filename]#/etc/ipfw.rules# can be located anywhere and the file can have "
"any name."
msgstr ""
"[.filename]#/etc/ipfw.rules# 은 어디에나 위치할 수 있으며 파일 이름은 무엇이"
"든 상관없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1803
msgid "The same thing could be accomplished by running these commands by hand:"
msgstr "아래의 명령을 직접 실행해도 동일한 작업을 수행할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1813
#, no-wrap
msgid ""
"# ipfw -q -f flush\n"
"# ipfw -q add check-state\n"
"# ipfw -q add deny all from any to any frag\n"
"# ipfw -q add deny tcp from any to any established\n"
"# ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state\n"
"# ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state\n"
"# ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state\n"
msgstr ""
"# ipfw -q -f flush\n"
"# ipfw -q add check-state\n"
"# ipfw -q add deny all from any to any frag\n"
"# ipfw -q add deny tcp from any to any established\n"
"# ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state\n"
"# ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state\n"
"# ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state\n"

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1816
#, no-wrap
msgid "IPFW Kernel Options"
msgstr "IPFW 커널옵션"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1820
msgid ""
"In order to statically compile IPFW support into a custom kernel, refer to "
"the instructions in crossref:kernelconfig[kernelconfig,Configuring the "
"FreeBSD Kernel].  The following options are available for the custom kernel "
"configuration file:"
msgstr ""
"커스텀 커널에 정적으로 IPFW 지원을 컴파일하려면 crossref:"
"kernelconfig[kernelconfig,FreeBSD 커널 구성]의 지침을 참조하십시오.  커스텀 "
"커널 구성 파일에 사용할 수 있는 옵션은 다음과 같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1833
#, no-wrap
msgid ""
"options    IPFIREWALL\t\t\t# enables IPFW\n"
"options    IPFIREWALL_VERBOSE\t\t# enables logging for rules with log keyword to syslogd(8)\n"
"options    IPFIREWALL_VERBOSE_LIMIT=5\t# limits number of logged packets per-entry\n"
"options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied\n"
"options    IPFIREWALL_NAT\t\t# enables basic in-kernel NAT support\n"
"options    LIBALIAS\t\t\t# enables full in-kernel NAT support\n"
"options    IPFIREWALL_NAT64\t\t# enables in-kernel NAT64 support\n"
"options    IPFIREWALL_NPTV6\t\t# enables in-kernel IPv6 NPT support\n"
"options    IPFIREWALL_PMOD\t\t# enables protocols modification module support\n"
"options    IPDIVERT\t\t\t# enables NAT through natd(8)\n"
msgstr ""
"options    IPFIREWALL\t\t\t# enables IPFW\n"
"options    IPFIREWALL_VERBOSE\t\t# enables logging for rules with log keyword to syslogd(8)\n"
"options    IPFIREWALL_VERBOSE_LIMIT=5\t# limits number of logged packets per-entry\n"
"options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied\n"
"options    IPFIREWALL_NAT\t\t# enables basic in-kernel NAT support\n"
"options    LIBALIAS\t\t\t# enables full in-kernel NAT support\n"
"options    IPFIREWALL_NAT64\t\t# enables in-kernel NAT64 support\n"
"options    IPFIREWALL_NPTV6\t\t# enables in-kernel IPv6 NPT support\n"
"options    IPFIREWALL_PMOD\t\t# enables protocols modification module support\n"
"options    IPDIVERT\t\t\t# enables NAT through natd(8)\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1838
msgid ""
"IPFW can be loaded as a kernel module: options above are built by default as "
"modules or can be set at runtime using tunables."
msgstr ""
"위의 옵션은 기본적으로 모듈로 빌드되거나 튜너블을 사용하여 런타임에 설정할 "
"수 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1841
#, no-wrap
msgid "IPFILTER (IPF)"
msgstr "IPFILTER (IPF)"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1844
msgid ""
"IPFILTER, also known as IPF, is a cross-platform, open source firewall which "
"has been ported to several operating systems, including FreeBSD, NetBSD, "
"OpenBSD, and Solaris(TM)."
msgstr ""
"IPF라고도 하는 IPFILTER는 크로스 플랫폼 오픈 소스 방화벽으로, FreeBSD, "
"NetBSD, OpenBSD, Solaris(TM) 등 여러 운영 체제에 포팅되어 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1847
msgid ""
"IPFILTER is a kernel-side firewall and NAT mechanism that can be controlled "
"and monitored by userland programs.  Firewall rules can be set or deleted "
"using ipf, NAT rules can be set or deleted using ipnat, run-time statistics "
"for the kernel parts of IPFILTER can be printed using ipfstat, and ipmon can "
"be used to log IPFILTER actions to the system log files."
msgstr ""
"IPFILTER는 사용자 프로그램에서 제어 및 모니터링할 수 있는 커널 측 방화벽 및 "
"NAT 메커니즘입니다.  방화벽 규칙은 ipf를 사용하여 설정하거나 삭제할 수 있고, "
"NAT 규칙은 ipnat를 사용하여 설정하거나 삭제할 수 있으며, IPFILTER의 커널 부분"
"에 대한 런타임 통계는 ipfstat를 사용하여 인쇄할 수 있고, ipmon을 사용하여 시"
"스템 로그 파일에 IPFILTER 동작을 기록할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1850
msgid ""
"IPF was originally written using a rule processing logic of \"the last "
"matching rule wins\" and only used stateless rules.  Since then, IPF has "
"been enhanced to include the `quick` and `keep state` options."
msgstr ""
"IPF는 원래 “마지막으로 일치하는 규칙이 승리”는 규칙 처리 로직을 사용하여 작성"
"되었으며 상태 stateless 규칙만 사용했습니다.  그 이후로 IPF는 `quick` 및 "
"`keep state` 옵션을 포함하도록 개선되었습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1853
msgid ""
"The IPF FAQ is at http://www.phildev.net/ipf/index.html[http://www.phildev."
"net/ipf/index.html].  A searchable archive of the IPFilter mailing list is "
"available at http://marc.info/?l=ipfilter[http://marc.info/?l=ipfilter]."
msgstr ""
"IPF FAQ는 http://www.phildev.net/ipf/index.html[http://www.phildev.net/ipf/"
"index.html]에서 확인할 수 있습니다.  IPFilter 메일링 리스트의 검색 가능한 아"
"카이브는 http://marc.info/?l=ipfilter[http://marc.info/?l=ipfilter]에서 확인"
"할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1856
msgid ""
"This section of the Handbook focuses on IPF as it pertains to FreeBSD.  It "
"provides examples of rules that contain the `quick` and `keep state` options."
msgstr ""
"핸드북의 이 섹션에서는 FreeBSD와 관련된 IPF에 초점을 맞춥니다.  여기서는 "
"`quick` 및 `keep state` 옵션이 포함된 규칙의 예를 제공합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1857
#, no-wrap
msgid "Enabling IPF"
msgstr "IPF 활성화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1860
msgid ""
"IPF is included in the basic FreeBSD install as a kernel loadable module, "
"meaning that a custom kernel is not needed in order to enable IPF."
msgstr ""
"IPF는 커널 로딩이 가능한 모듈로 기본 FreeBSD 설치에 포함되어 있으므로 IPF를 "
"활성화하기 위해 커스텀 커널이 필요하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1863
msgid ""
"For users who prefer to statically compile IPF support into a custom kernel, "
"refer to the instructions in crossref:kernelconfig[kernelconfig,Configuring "
"the FreeBSD Kernel].  The following kernel options are available:"
msgstr ""
"커스텀 커널에 IPF 지원을 정적으로 컴파일하는 것을 선호하는 사용자는 crossref:"
"kernelconfig[kernelconfig,FreeBSD 커널 구성하기]의 지침을 참조하십시오.  다"
"음 커널 옵션을 사용할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1870
#, no-wrap
msgid ""
"options IPFILTER\n"
"options IPFILTER_LOG\n"
"options IPFILTER_LOOKUP\n"
"options IPFILTER_DEFAULT_BLOCK\n"
msgstr ""
"options IPFILTER\n"
"options IPFILTER_LOG\n"
"options IPFILTER_LOOKUP\n"
"options IPFILTER_DEFAULT_BLOCK\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1873
msgid ""
"where `options IPFILTER` enables support for IPFILTER, `options "
"IPFILTER_LOG` enables IPF logging using the [.filename]#ipl# packet logging "
"pseudo-device for every rule that has the `log` keyword, `IPFILTER_LOOKUP` "
"enables IP pools in order to speed up IP lookups, and `options "
"IPFILTER_DEFAULT_BLOCK` changes the default behavior so that any packet not "
"matching a firewall `pass` rule gets blocked."
msgstr ""
"여기서 `options IPFILTER` 는 IPFILTER 지원을 활성화하고, `options "
"IPFILTER_LOG` 는 `log` 키워드가 있는 모든 규칙에 대해 [.filename]#ipl# 패킷 "
"로깅 의사 장치를 사용하여 IPF 로깅을 활성화하며, `IPFILTER_LOOKUP` 은 IP 조"
"회 속도를 높이기 위해 IP 풀을 사용하고, `options IPFILTER_DEFAULT_BLOCK` 은 "
"방화벽 `pass` 규칙에 맞지 않는 모든 패킷이 차단되도록 기본 동작을 변경합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1877
msgid ""
"To configure the system to enable IPF at boot time, add the following "
"entries to [.filename]#/etc/rc.conf#.  These entries will also enable "
"logging and `default pass all`.  To change the default policy to `block all` "
"without compiling a custom kernel, remember to add a `block all` rule at the "
"end of the ruleset."
msgstr ""
"부팅 시 IPF를 사용하도록 시스템을 구성하려면 [.filename]#/etc/rc.conf# 에 다"
"음 항목을 추가합니다.  이 항목은 로깅과 `default pass all` 도 활성화합니다.  "
"사용자 정의 커널을 컴파일하지 않고 기본 정책을 `block all` 으로 변경하려면 규"
"칙 집합 끝에 `block all` 규칙을 추가하는 것을 잊지 마세요."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1888
#, no-wrap
msgid ""
"ipfilter_enable=\"YES\"             # Start ipf firewall\n"
"ipfilter_rules=\"/etc/ipf.rules\"   # loads rules definition text file\n"
"ipv6_ipfilter_rules=\"/etc/ipf6.rules\" # loads rules definition text file for IPv6\n"
"ipmon_enable=\"YES\"                # Start IP monitor log\n"
"ipmon_flags=\"-Ds\"                 # D = start as daemon\n"
"                                  # s = log to syslog\n"
"                                  # v = log tcp window, ack, seq\n"
"                                  # n = map IP & port to names\n"
msgstr ""
"ipfilter_enable=\"YES\"             # Start ipf firewall\n"
"ipfilter_rules=\"/etc/ipf.rules\"   # loads rules definition text file\n"
"ipv6_ipfilter_rules=\"/etc/ipf6.rules\" # loads rules definition text file for IPv6\n"
"ipmon_enable=\"YES\"                # Start IP monitor log\n"
"ipmon_flags=\"-Ds\"                 # D = start as daemon\n"
"                                  # s = log to syslog\n"
"                                  # v = log tcp window, ack, seq\n"
"                                  # n = map IP & port to names\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1891
msgid "If NAT functionality is needed, also add these lines:"
msgstr "NAT 기능이 필요한 경우 다음 줄도 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1897
#, no-wrap
msgid ""
"gateway_enable=\"YES\"              # Enable as LAN gateway\n"
"ipnat_enable=\"YES\"                # Start ipnat function\n"
"ipnat_rules=\"/etc/ipnat.rules\"    # rules definition file for ipnat\n"
msgstr ""
"gateway_enable=\"YES\"              # Enable as LAN gateway\n"
"ipnat_enable=\"YES\"                # Start ipnat function\n"
"ipnat_rules=\"/etc/ipnat.rules\"    # rules definition file for ipnat\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1900
msgid "Then, to start IPF now:"
msgstr "이제 IPF를 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1904
#, no-wrap
msgid "#  service ipfilter start\n"
msgstr "#  service ipfilter start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1908
msgid ""
"To load the firewall rules, specify the name of the ruleset file using "
"`ipf`.  The following command can be used to replace the currently running "
"firewall rules:"
msgstr ""
"방화벽 규칙을 로드하려면 `ipf` 를 사용하여 규칙 집합 파일의 이름을 지정합니"
"다.  다음 명령을 사용하여 현재 실행 중인 방화벽 규칙을 바꿀 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1912
#, no-wrap
msgid "# ipf -Fa -f /etc/ipf.rules\n"
msgstr "# ipf -Fa -f /etc/ipf.rules\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1915
msgid ""
"where `-Fa` flushes all the internal rules tables and `-f` specifies the "
"file containing the rules to load."
msgstr ""
"여기서 `-Fa` 는 모든 내부 규칙 테이블을 플러시하고 `-f` 는 로드할 규칙이 포함"
"된 파일을 지정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1918
msgid ""
"This provides the ability to make changes to a custom ruleset and update the "
"running firewall with a fresh copy of the rules without having to reboot the "
"system.  This method is convenient for testing new rules as the procedure "
"can be executed as many times as needed."
msgstr ""
"이렇게 하면 시스템을 재부팅하지 않고도 사용자 지정 규칙 집합을 변경하고 실행 "
"중인 방화벽을 규칙의 새 복사본으로 업데이트할 수 있습니다.  이 방법은 필요한 "
"만큼 얼마든지 절차를 실행할 수 있으므로 새 규칙을 테스트할 때 편리합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1920
msgid ""
"Refer to man:ipf[8] for details on the other flags available with this "
"command."
msgstr ""
"이 명령으로 사용할 수 있는 다른 플래그에 대한 자세한 내용은 man:ipf[8]을 참조"
"하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1921
#, no-wrap
msgid "IPF Rule Syntax"
msgstr "IPF 규칙 문법"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1927
msgid ""
"This section describes the IPF rule syntax used to create stateful rules.  "
"When creating rules, keep in mind that unless the `quick` keyword appears in "
"a rule, every rule is read in order, with the _last matching rule_ being the "
"one that is applied.  This means that even if the first rule to match a "
"packet is a `pass`, if there is a later matching rule that is a `block`, the "
"packet will be dropped.  Sample rulesets can be found in [.filename]#/usr/"
"share/examples/ipfilter#."
msgstr ""
"이 섹션에서는 상태분석형(Stateful) 규칙을 만드는 데 사용되는 IPF 규칙 구문에 "
"대해 설명합니다.  규칙을 만들 때, 규칙에 ‘quick’ 키워드가 나타나지 않는 한, "
"모든 규칙은 순서대로 읽혀지며, _마지막에 매칭되는 규칙이 적용_ 되는 규칙이라"
"는 점에 유의하세요.  즉, 패킷을 일치시키는 첫 번째 규칙이 `pass` 라 하더라도 "
"나중에 일치하는 규칙이 `block` 인 경우 패킷이 삭제됩니다.  샘플 규칙 세트는 "
"[.filename]#/usr/share/examples/ipfilter# 에서 찾을 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1930
msgid ""
"When creating rules, a `+#+` character is used to mark the start of a "
"comment and may appear at the end of a rule, to explain that rule's "
"function, or on its own line.  Any blank lines are ignored."
msgstr ""
"규칙을 만들 때 `+#+` 문자는 주석의 시작을 표시하는 데 사용되며, 규칙의 끝이"
"나 해당 규칙의 기능을 설명하기 위해, 또는 그 자체 줄에 표시될 수 있습니다.  "
"빈 줄은 무시됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1935
msgid ""
"The keywords which are used in rules must be written in a specific order, "
"from left to right.  Some keywords are mandatory while others are optional.  "
"Some keywords have sub-options which may be keywords themselves and also "
"include more sub-options.  The keyword order is as follows, where the words "
"shown in uppercase represent a variable and the words shown in lowercase "
"must precede the variable that follows it:"
msgstr ""
"규칙에 사용되는 키워드는 왼쪽에서 오른쪽으로 특정 순서로 작성해야 합니다.  일"
"부 키워드는 필수인 반면 다른 키워드는 선택 사항입니다.  일부 키워드에는 키워"
"드 자체가 될 수도 있고 더 많은 하위 옵션이 포함될 수도 있는 하위 옵션이 있습"
"니다.  키워드 순서는 다음과 같으며, 대문자로 표시된 단어는 변수를 나타내고 소"
"문자로 표시된 단어는 그 뒤에 오는 변수 앞에 와야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1937
msgid ""
"`_ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to "
"DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE_`"
msgstr ""
"`_ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to "
"DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE_`"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1941
msgid ""
"This section describes each of these keywords and their options.  It is not "
"an exhaustive list of every possible option.  Refer to man:ipf[5] for a "
"complete description of the rule syntax that can be used when creating IPF "
"rules and examples for using each keyword."
msgstr ""
"이 섹션에서는 이러한 각 키워드와 해당 옵션에 대해 설명합니다.  가능한 모든 옵"
"션의 전체 목록은 아닙니다.  IPF 규칙을 만들 때 사용할 수 있는 규칙 구문과 각 "
"키워드 사용 예제에 대한 자세한 설명은 man:ipf[5]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1946
msgid ""
"The action keyword indicates what to do with the packet if it matches that "
"rule.  Every rule _must_ have an action.  The following actions are "
"recognized:"
msgstr ""
"액션 키워드는 해당 규칙과 일치하는 패킷이 있을 경우 수행할 작업을 나타냅니"
"다.  모든 규칙에는 _반드시_ 액션이 있어야 합니다.  다음과 같은 액션이 인식됩"
"니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1948
msgid "`block`: drops the packet."
msgstr "`block` : 패킷을 폐기함."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1950
msgid "`pass`: allows the packet."
msgstr "`pass` : 패킹의 통과를 허용함."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1952
msgid "`log`: generates a log record."
msgstr "`log` : 로그를 기록함."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1954
msgid ""
"`count`: counts the number of packets and bytes which can provide an "
"indication of how often a rule is used."
msgstr ""
"`count` : 규칙이 얼마나 자주 사용되는지 지표로 사용할 수 있는 패킷과 바이트"
"의 수를 계산함."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1956
msgid "`auth`: queues the packet for further processing by another program."
msgstr "`auth` : 다른 프로그램에서 추가 처리를 위해 패킷을 대기열에 넣음."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1958
msgid ""
"`call`: provides access to functions built into IPF that allow more complex "
"actions."
msgstr ""
"`call` : 보다 복잡한 작업을 허용하는 IPF에 내장된 함수에 대한 액세스를 제공."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1960
msgid ""
"`decapsulate`: removes any headers in order to process the contents of the "
"packet."
msgstr "`decapsulate` : 패킷의 내용을 처리하기 위해 모든 헤더를 제거함."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1961
#, no-wrap
msgid "DIRECTION"
msgstr "DIRECTION"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1963
msgid ""
"Next, each rule must explicitly state the direction of traffic using one of "
"these keywords:"
msgstr ""
"다음으로, 각 규칙은 아래의 키워드 중 하나를 사용하여 트래픽의 방향을 명시적으"
"로 지정해야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1965
msgid "`in`: the rule is applied against an inbound packet."
msgstr "`in` : 인바운드 패킷에 대해 규칙이 적용."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1967
msgid "`out`: the rule is applied against an outbound packet."
msgstr "`out` : 아웃바운드 패킷에 대해 규칙이 적용."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1969
msgid "`all`: the rule applies to either direction."
msgstr "`all` : 양방향 모두 규칙이 적용."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1971
msgid ""
"If the system has multiple interfaces, the interface can be specified along "
"with the direction. An example would be `in on fxp0`."
msgstr ""
"시스템에 여러 인터페이스가 있는 경우 방향과 함께 인터페이스를 지정할 수 있습"
"니다. 예를 들어 `in on fxp0` 이 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1975
msgid ""
"Options are optional.  However, if multiple options are specified, they must "
"be used in the order shown here."
msgstr ""
"옵션은 선택 사항입니다.  그러나 여러 옵션을 지정하는 경우 여기에 표시된 순서"
"대로 사용해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1977
msgid ""
"`log`: when performing the specified ACTION, the contents of the packet's "
"headers will be written to the man:ipl[4] packet log pseudo-device."
msgstr ""
"`log` : 지정된 ACTION을 수행할 때 패킷 헤더의 내용이 man:ipl[4] 패킷 로그 의"
"사 장치에 기록됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1979
msgid ""
"`quick`: if a packet matches this rule, the ACTION specified by the rule "
"occurs and no further processing of any following rules will occur for this "
"packet."
msgstr ""
"`quick` : 패킷이 이 규칙과 일치하면 규칙에 지정된 ACTION이 발생하고 이 패킷"
"에 대해 다음 규칙의 추가 처리가 수행되지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1982
msgid ""
"`on`: must be followed by the interface name as displayed by man:"
"ifconfig[8].  The rule will only match if the packet is going through the "
"specified interface in the specified direction."
msgstr ""
"`on` : 뒤에는 man:ifconfig[8]에 표시된 인터페이스 이름이 와야 합니다.  이 규"
"칙은 패킷이 지정된 인터페이스를 지정된 방향으로 통과하는 경우에만 일치합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1984
msgid ""
"When using the `log` keyword, the following qualifiers may be used in this "
"order:"
msgstr "`log` 키워드를 사용할 때는 다음 한정자를 순서대로 사용할 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1986
msgid ""
"`body`: indicates that the first 128 bytes of the packet contents will be "
"logged after the headers."
msgstr "`body` : 패킷 내용의 첫 128바이트가 헤더 뒤에 기록됨을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1988
msgid ""
"`first`: if the `log` keyword is being used in conjunction with a `keep "
"state` option, this option is recommended so that only the triggering packet "
"is logged and not every packet which matches the stateful connection."
msgstr ""
"`first` : `log` 키워드가 `keep state` 옵션과 함께 사용되는 경우 상태 분석형 "
"연결과 일치하는 모든 패킷이 아니라, 트리거 패킷만 기록되도록 이 옵션을 사용하"
"는 것이 좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1991
msgid ""
"Additional options are available to specify error return messages.  Refer to "
"man:ipf[5] for more details."
msgstr ""
"오류 반환 메시지를 지정하는 추가 옵션을 사용할 수 있습니다.  자세한 내용은 "
"man:ipf[5]를 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1992
#, no-wrap
msgid "PROTO_TYPE"
msgstr "PROTO_TYPE"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1998
msgid ""
"The protocol type is optional.  However, it is mandatory if the rule needs "
"to specify a SRC_PORT or a DST_PORT as it defines the type of protocol.  "
"When specifying the type of protocol, use the `proto` keyword followed by "
"either a protocol number or name from [.filename]#/etc/protocols#.  Example "
"protocol names include `tcp`, `udp`, or `icmp`.  If PROTO_TYPE is specified "
"but no SRC_PORT or DST_PORT is specified, all port numbers for that protocol "
"will match that rule."
msgstr ""
"프로토콜 유형은 선택 사항입니다.  그러나 규칙이 프로토콜 유형을 정의하기 때문"
"에 SRC_PORT 또는 DST_PORT를 지정해야 하는 경우 필수입니다.  프로토콜 유형을 "
"지정할 때는 `proto` 키워드 뒤에 프로토콜 번호 또는 [.filename]#/etc/"
"protocols# 의 이름을 사용합니다.  프로토콜 이름의 예로는 `tcp`, `udp`, "
"`icmp` 등이 있습니다.  만약 PROTO_TYPE이 지정되었지만 SRC_PORT 또는 DST_PORT"
"가 지정되지 않은 경우, 해당 프로토콜에 대해 모든 포트 번호가 적용됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:1999
#, no-wrap
msgid "SRC_ADDR"
msgstr "SRC_ADDR"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2003
msgid ""
"The `from` keyword is mandatory and is followed by a keyword which "
"represents the source of the packet.  The source can be a hostname, an IP "
"address followed by the CIDR mask, an address pool, or the keyword `all`.  "
"Refer to man:ipf[5] for examples."
msgstr ""
"‘from` 키워드는 필수이며 그 뒤에 패킷의 소스를 나타내는 키워드가 이어집니"
"다.  소스는 호스트 이름, IP 주소 뒤에 CIDR 마스크, 주소 풀 또는 키워드 `all` "
"이 될 수 있습니다.  예제는 man:ipf[5]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2007
msgid ""
"There is no way to match ranges of IP addresses which do not express "
"themselves easily using the dotted numeric form / mask-length notation.  The "
"package:net-mgmt/ipcalc[] package or port may be used to ease the "
"calculation of the CIDR mask.  Additional information is available at the "
"utility's web page: http://jodies.de/ipcalc[http://jodies.de/ipcalc]."
msgstr ""
"점 숫자 형식이나 마스크 길이 표기법과 같이 쉽게 표현되지 않는 IP 주소 범위를 "
"일치시킬 수 있는 방법은 지원되지 않습니다.  package:net-mgmt/ipcalc[] 패키지 "
"또는 포트를 사용하면 CIDR 마스크 계산을 쉽게 할 수 있습니다.  추가 정보는 유"
"틸리티 웹 페이지(http://jodies.de/ipcalc[http://jodies.de/ipcalc])에서 확인"
"할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2012
msgid ""
"The port number of the source is optional.  However, if it is used, it "
"requires PROTO_TYPE to be first defined in the rule.  The port number must "
"also be preceded by the `proto` keyword."
msgstr ""
"소스의 포트 번호는 선택 사항입니다.  그러나 포트 번호를 사용하는 경우 규칙에 "
"PROTO_TYPE을 먼저 정의해야 합니다.  또한 포트 번호 앞에는 `proto` 키워드가 와"
"야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2014
msgid ""
"A number of different comparison operators are supported: `=` (equal to), `!"
"=` (not equal to), `<` (less than), `>` (greater than), `<=` (less than or "
"equal to), and `>=` (greater than or equal to)."
msgstr ""
"다양한 비교 연산자가 지원됩니다: `=` (같음), `!=` (같지 않음), `<` (보다 작"
"음), `>` (보다 큼), `<=` (작거나 같음), `>=` (크거나 같음) 등 다양한 비교 연"
"산자가 지원됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2016
msgid ""
"To specify port ranges, place the two port numbers between `<>` (less than "
"and greater than ), `><` (greater than and less than ), or `:` (greater than "
"or equal to and less than or equal to)."
msgstr ""
"포트 범위를 지정하려면 두 포트 번호를 `<>` (보다 작거나 큰 ), `><` (보다 크거"
"나 작은) 또는 `:` (보다 크거나 같은, 보다 작거나 같은) 사이에 넣습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2017
#, no-wrap
msgid "DST_ADDR"
msgstr "DST_ADDR"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2020
msgid ""
"The `to` keyword is mandatory and is followed by a keyword which represents "
"the destination of the packet.  Similar to SRC_ADDR, it can be a hostname, "
"an IP address followed by the CIDR mask, an address pool, or the keyword "
"`all`."
msgstr ""
"`to` 키워드는 필수이며 그 뒤에 패킷의 목적지를 나타내는 키워드가 이어집니"
"다.  SRC_ADDR과 유사하게 호스트 이름, IP 주소 뒤에 CIDR 마스크, 주소 풀 또는 "
"키워드 `all` 을 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2025
msgid ""
"Similar to SRC_PORT, the port number of the destination is optional.  "
"However, if it is used, it requires PROTO_TYPE to be first defined in the "
"rule.  The port number must also be preceded by the `proto` keyword."
msgstr ""
"SRC_PORT와 마찬가지로 목적지의 포트 번호는 선택 사항입니다.  그러나 이 포트 "
"번호를 사용하는 경우 규칙에 PROTO_TYPE을 먼저 정의해야 합니다.  또한 포트 번"
"호 앞에는 `proto` 키워드가 와야 합니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2026
#, no-wrap
msgid "TCP_FLAG|ICMP_TYPE"
msgstr "TCP_FLAG|ICMP_TYPE"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2029
msgid ""
"If `tcp` is specified as the PROTO_TYPE, flags can be specified as letters, "
"where each letter represents one of the possible TCP flags used to determine "
"the state of a connection.  Possible values are: `S` (SYN), `A` (ACK), `P` "
"(PSH), `F` (FIN), `U` (URG), `R` (RST), `C` (CWN), and `E` (ECN)."
msgstr ""
"`tcp` 가 PROTO_TYPE으로 지정되면 플래그를 문자로 지정할 수 있으며, 각 문자는 "
"연결 상태를 결정하는 데 사용되는 가능한 TCP 플래그 중 하나를 나타냅니다.  가"
"능한 값은 다음과 같습니다: `S` (SYN), `A` (ACK), `P` (PSH), `F` (FIN), `U` "
"(URG), `R` (RST), `C` (CWN), `E` (ECN)."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2032
msgid ""
"If `icmp` is specified as the PROTO_TYPE, the ICMP type to match can be "
"specified.  Refer to man:ipf[5] for the allowable types."
msgstr ""
"‘icmp’ 가 PROTO_TYPE으로 지정되면 일치할 ICMP 유형을 지정할 수 있습니다.  허"
"용되는 유형은 man:ipf[5]를 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2033
#, no-wrap
msgid "STATE"
msgstr "STATE"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2037
msgid ""
"If a `pass` rule contains `keep state`, IPF will add an entry to its dynamic "
"state table and allow subsequent packets that match the connection.  IPF can "
"track state for TCP, UDP, and ICMP sessions.  Any packet that IPF can be "
"certain is part of an active session, even if it is a different protocol, "
"will be allowed."
msgstr ""
"`pass` 규칙이 `keep state` 를 가지고 있는 IPF는 동적 상태 테이블에 항목을 추"
"가하고 연결과 일치하는 후속 패킷을 허용합니다.  IPF는 TCP, UDP 및 ICMP 세션"
"의 상태를 추적할 수 있습니다.  IPF가 활성 세션의 일부라고 확신할 수 있는 패킷"
"은 프로토콜이 다르더라도 모두 허용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2044
msgid ""
"In IPF, packets destined to go out through the interface connected to the "
"public Internet are first checked against the dynamic state table.  If the "
"packet matches the next expected packet comprising an active session "
"conversation, it exits the firewall and the state of the session "
"conversation flow is updated in the dynamic state table.  Packets that do "
"not belong to an already active session are checked against the outbound "
"ruleset.  Packets coming in from the interface connected to the public "
"Internet are first checked against the dynamic state table.  If the packet "
"matches the next expected packet comprising an active session, it exits the "
"firewall and the state of the session conversation flow is updated in the "
"dynamic state table.  Packets that do not belong to an already active "
"session are checked against the inbound ruleset."
msgstr ""
"IPF에서는 공용 인터넷에 연결된 인터페이스를 통해 나가려는 패킷을 먼저 동적 상"
"태 테이블에서 확인합니다.  패킷이 활성 세션 대화를 구성한 다음 예상 패킷과 일"
"치하면 방화벽을 종료하고 세션 대화 흐름의 상태가 동적 상태 테이블에서 업데이"
"트됩니다.  이미 활성화된 세션에 속하지 않은 패킷은 아웃바운드 규칙 집합에 대"
"해 확인됩니다.  공용 인터넷에 연결된 인터페이스에서 들어오는 패킷은 먼저 동"
"적 상태 테이블을 이용해 확인합니다.  패킷이 활성 세션을 구성하는 다음 예상 패"
"킷과 일치하면 방화벽을 종료하고 세션 대화 흐름의 상태가 동적 상태 테이블에서 "
"업데이트됩니다.  이미 활성화된 세션에 속하지 않는 패킷은 인바운드 규칙 집합"
"을 써서 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2048
msgid ""
"Several keywords can be added after `keep state`.  If used, these keywords "
"set various options that control stateful filtering, such as setting "
"connection limits or connection age.  Refer to man:ipf[5] for the list of "
"available options and their descriptions."
msgstr ""
"`keep state` 뒤에 여러 키워드를 추가할 수 있습니다.  키워드를 사용하면 연결 "
"제한 또는 연결 기간 설정 등 상태 저장 필터링을 제어하는 다양한 옵션을 설정할 "
"수 있습니다.  사용 가능한 옵션 목록과 설명은 man:ipf[5]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2052
msgid ""
"This section demonstrates how to create an example ruleset which only allows "
"services matching `pass` rules and blocks all others."
msgstr ""
"이 섹션에서는 ‘pass’ 규칙과 일치하는 서비스만 허용하고 다른 모든 서비스는 차"
"단하는 예제 규칙 집합을 만드는 방법을 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2055
msgid ""
"FreeBSD uses the loopback interface ([.filename]#lo0#) and the IP address "
"`127.0.0.1` for internal communication.  The firewall ruleset must contain "
"rules to allow free movement of these internally used packets:"
msgstr ""
"FreeBSD는 내부 통신을 위해 루프백 인터페이스( [.filename]#lo0# )와 IP 주소 "
"`127.0.0.1` 을 사용합니다.  방화벽 규칙 집합에는 이러한 내부적으로 사용되는 "
"패킷의 자유로운 이동을 허용하는 규칙이 포함되어야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2061
#, no-wrap
msgid ""
"# no restrictions on loopback interface\n"
"pass in quick on lo0 all\n"
"pass out quick on lo0 all\n"
msgstr ""
"# no restrictions on loopback interface\n"
"pass in quick on lo0 all\n"
"pass out quick on lo0 all\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2066
msgid ""
"The public interface connected to the Internet is used to authorize and "
"control access of all outbound and inbound connections.  If one or more "
"interfaces are cabled to private networks, those internal interfaces may "
"require rules to allow packets originating from the LAN to flow between the "
"internal networks or to the interface attached to the Internet.  The ruleset "
"should be organized into three major sections: any trusted internal "
"interfaces, outbound connections through the public interface, and inbound "
"connections through the public interface."
msgstr ""
"인터넷에 연결된 공용 인터페이스는 모든 아웃바운드 및 인바운드 연결의 액세스"
"를 승인하고 제어하는 데 사용됩니다.  하나 이상의 인터페이스가 개인 네트워크"
"에 연결되어 있는 경우, 이러한 내부 인터페이스에는 LAN에서 시작된 패킷이 내부 "
"네트워크 간 또는 인터넷에 연결된 인터페이스로 흐르도록 허용하는 규칙이 필요"
"할 수 있습니다.  규칙 집합은 신뢰할 수 있는 내부 인터페이스, 공용 인터페이스"
"를 통한 아웃바운드 연결, 공용 인터페이스를 통한 인바운드 연결의 세 가지 주요 "
"섹션으로 구성되어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2068
msgid ""
"These two rules allow all traffic to pass through a trusted LAN interface "
"named [.filename]#xl0#:"
msgstr ""
"이 두 가지 규칙은 모든 트래픽이 [.filename]#xl0# 이라는 신뢰할 수 있는 LAN 인"
"터페이스를 통과하도록 허용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2074
#, no-wrap
msgid ""
"# no restrictions on inside LAN interface for private network\n"
"pass out quick on xl0 all\n"
"pass in quick on xl0 all\n"
msgstr ""
"# no restrictions on inside LAN interface for private network\n"
"pass out quick on xl0 all\n"
"pass in quick on xl0 all\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2077
msgid ""
"The rules for the public interface's outbound and inbound sections should "
"have the most frequently matched rules placed before less commonly matched "
"rules, with the last rule in the section blocking and logging all packets "
"for that interface and direction."
msgstr ""
"공용 인터페이스의 아웃바운드 및 인바운드 섹션에 대한 규칙은 가장 자주 일치하"
"는 규칙이 덜 자주 일치하는 규칙 앞에 배치되어야 하며, 섹션의 마지막 규칙이 해"
"당 인터페이스 및 방향에 대한 모든 패킷을 차단하고 로깅해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2081
msgid ""
"This set of rules defines the outbound section of the public interface named "
"[.filename]#dc0#.  These rules keep state and identify the specific services "
"that internal systems are authorized for public Internet access.  All the "
"rules use `quick` and specify the appropriate port numbers and, where "
"applicable, destination addresses."
msgstr ""
"이 규칙 집합은 [.filename]#dc0# 이라는 공용 인터페이스의 아웃바운드 섹션을 정"
"의합니다.  이러한 규칙은 내부 시스템이 공용 인터넷 액세스를 위해 승인된 특정 "
"서비스를 식별하고 상태를 유지합니다.  모든 규칙은 `quick` 을 사용하며 적절한 "
"포트 번호와 해당되는 경우 대상 주소를 지정합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2087
#, no-wrap
msgid ""
"# interface facing Internet (outbound)\n"
"# Matches session start requests originating from or behind the\n"
"# firewall, destined for the Internet.\n"
msgstr ""
"# interface facing Internet (outbound)\n"
"# Matches session start requests originating from or behind the\n"
"# firewall, destined for the Internet.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2093
#, no-wrap
msgid ""
"# Allow outbound access to public DNS servers.\n"
"# Replace x.x.x.x with address listed in /etc/resolv.conf.\n"
"# Repeat for each DNS server.\n"
"pass out quick on dc0 proto tcp from any to x.x.x.x port = 53 flags S keep state\n"
"pass out quick on dc0 proto udp from any to x.x.x.x port = 53 keep state\n"
msgstr ""
"# Allow outbound access to public DNS servers.\n"
"# Replace x.x.x.x with address listed in /etc/resolv.conf.\n"
"# Repeat for each DNS server.\n"
"pass out quick on dc0 proto tcp from any to x.x.x.x port = 53 flags S keep state\n"
"pass out quick on dc0 proto udp from any to x.x.x.x port = 53 keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2100
#, no-wrap
msgid ""
"# Allow access to ISP's specified DHCP server for cable or DSL networks.\n"
"# Use the first rule, then check log for the IP address of DHCP server.\n"
"# Then, uncomment the second rule, replace z.z.z.z with the IP address,\n"
"# and comment out the first rule\n"
"pass out log quick on dc0 proto udp from any to any port = 67 keep state\n"
"#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state\n"
msgstr ""
"# Allow access to ISP's specified DHCP server for cable or DSL networks.\n"
"# Use the first rule, then check log for the IP address of DHCP server.\n"
"# Then, uncomment the second rule, replace z.z.z.z with the IP address,\n"
"# and comment out the first rule\n"
"pass out log quick on dc0 proto udp from any to any port = 67 keep state\n"
"#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2104
#, no-wrap
msgid ""
"# Allow HTTP and HTTPS\n"
"pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state\n"
"pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state\n"
msgstr ""
"# Allow HTTP and HTTPS\n"
"pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state\n"
"pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2108
#, no-wrap
msgid ""
"# Allow email\n"
"pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state\n"
"pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state\n"
msgstr ""
"# Allow email\n"
"pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state\n"
"pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2111
#, no-wrap
msgid ""
"# Allow NTP\n"
"pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state\n"
msgstr ""
"# Allow NTP\n"
"pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2114
#, no-wrap
msgid ""
"# Allow FTP\n"
"pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state\n"
msgstr ""
"# Allow FTP\n"
"pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2117
#, no-wrap
msgid ""
"# Allow SSH\n"
"pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state\n"
msgstr ""
"# Allow SSH\n"
"pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2120
#, no-wrap
msgid ""
"# Allow ping\n"
"pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state\n"
msgstr ""
"# Allow ping\n"
"pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2123
#, no-wrap
msgid ""
"# Block and log everything else\n"
"block out log first quick on dc0 all\n"
msgstr ""
"# Block and log everything else\n"
"block out log first quick on dc0 all\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2127
msgid ""
"This example of the rules in the inbound section of the public interface "
"blocks all undesirable packets first.  This reduces the number of packets "
"that are logged by the last rule."
msgstr ""
"퍼블릭 인터페이스의 인바운드 섹션에 대한 이 규칙 예시는 바람직하지 않은 패킷"
"을 모두 먼저 차단합니다.  이렇게 하면 마지막 규칙에 의해 기록되는 패킷 수가 "
"줄어듭니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2141
#, no-wrap
msgid ""
"# interface facing Internet (inbound)\n"
"# Block all inbound traffic from non-routable or reserved address spaces\n"
"block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP\n"
"block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP\n"
"block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP\n"
"block in quick on dc0 from 127.0.0.0/8 to any       #loopback\n"
"block in quick on dc0 from 0.0.0.0/8 to any         #loopback\n"
"block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config\n"
"block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs\n"
"block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect\n"
"block in quick on dc0 from 224.0.0.0/3 to any       #Class D & E multicast\n"
msgstr ""
"# interface facing Internet (inbound)\n"
"# Block all inbound traffic from non-routable or reserved address spaces\n"
"block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP\n"
"block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP\n"
"block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP\n"
"block in quick on dc0 from 127.0.0.0/8 to any       #loopback\n"
"block in quick on dc0 from 0.0.0.0/8 to any         #loopback\n"
"block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config\n"
"block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs\n"
"block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect\n"
"block in quick on dc0 from 224.0.0.0/3 to any       #Class D & E multicast\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2145
#, no-wrap
msgid ""
"# Block fragments and too short tcp packets\n"
"block in quick on dc0 all with frags\n"
"block in quick on dc0 proto tcp all with short\n"
msgstr ""
"# Block fragments and too short tcp packets\n"
"block in quick on dc0 all with frags\n"
"block in quick on dc0 proto tcp all with short\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2149
#, no-wrap
msgid ""
"# block source routed packets\n"
"block in quick on dc0 all with opt lsrr\n"
"block in quick on dc0 all with opt ssrr\n"
msgstr ""
"# block source routed packets\n"
"block in quick on dc0 all with opt lsrr\n"
"block in quick on dc0 all with opt ssrr\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2152
#, no-wrap
msgid ""
"# Block OS fingerprint attempts and log first occurrence\n"
"block in log first quick on dc0 proto tcp from any to any flags FUP\n"
msgstr ""
"# Block OS fingerprint attempts and log first occurrence\n"
"block in log first quick on dc0 proto tcp from any to any flags FUP\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2155
#, no-wrap
msgid ""
"# Block anything with special options\n"
"block in quick on dc0 all with ipopts\n"
msgstr ""
"# Block anything with special options\n"
"block in quick on dc0 all with ipopts\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2159
#, no-wrap
msgid ""
"# Block public pings and ident\n"
"block in quick on dc0 proto icmp all icmp-type 8\n"
"block in quick on dc0 proto tcp from any to any port = 113\n"
msgstr ""
"# Block public pings and ident\n"
"block in quick on dc0 proto icmp all icmp-type 8\n"
"block in quick on dc0 proto tcp from any to any port = 113\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2165
#, no-wrap
msgid ""
"# Block incoming Netbios services\n"
"block in log first quick on dc0 proto tcp/udp from any to any port = 137\n"
"block in log first quick on dc0 proto tcp/udp from any to any port = 138\n"
"block in log first quick on dc0 proto tcp/udp from any to any port = 139\n"
"block in log first quick on dc0 proto tcp/udp from any to any port = 81\n"
msgstr ""
"# Block incoming Netbios services\n"
"block in log first quick on dc0 proto tcp/udp from any to any port = 137\n"
"block in log first quick on dc0 proto tcp/udp from any to any port = 138\n"
"block in log first quick on dc0 proto tcp/udp from any to any port = 139\n"
"block in log first quick on dc0 proto tcp/udp from any to any port = 81\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2169
msgid ""
"Any time there are logged messages on a rule with the `log first` option, "
"run `ipfstat -hio` to evaluate how many times the rule has been matched.  A "
"large number of matches may indicate that the system is under attack."
msgstr ""
"`log first` 옵션이 있는 규칙에 기록된 메시지가 있을 때마다 `ipfstat -hio` 를 "
"실행하여 규칙이 일치한 횟수를 평가합니다.  일치하는 횟수가 많으면 시스템이 공"
"격을 받고 있음을 나타낼 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2172
msgid ""
"The rest of the rules in the inbound section define which connections are "
"allowed to be initiated from the Internet.  The last rule denies all "
"connections which were not explicitly allowed by previous rules in this "
"section."
msgstr ""
"인바운드 섹션의 나머지 규칙은 인터넷에서 시작할 수 있는 연결을 정의합니다.  "
"마지막 규칙은 이 섹션의 이전 규칙에서 명시적으로 허용되지 않은 모든 연결을 거"
"부합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2178
#, no-wrap
msgid ""
"# Allow traffic in from ISP's DHCP server. Replace z.z.z.z with\n"
"# the same IP address used in the outbound section.\n"
"pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state\n"
msgstr ""
"# Allow traffic in from ISP's DHCP server. Replace z.z.z.z with\n"
"# the same IP address used in the outbound section.\n"
"pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2181
#, no-wrap
msgid ""
"# Allow public connections to specified internal web server\n"
"pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state\n"
msgstr ""
"# Allow public connections to specified internal web server\n"
"pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2184
#, no-wrap
msgid ""
"# Block and log only first occurrence of all remaining traffic.\n"
"block in log first quick on dc0 all\n"
msgstr ""
"# Block and log only first occurrence of all remaining traffic.\n"
"block in log first quick on dc0 all\n"

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2186
#, no-wrap
msgid "Configuring NAT"
msgstr "NAT 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2189
msgid ""
"To enable NAT, add these statements to [.filename]#/etc/rc.conf# and specify "
"the name of the file containing the NAT rules:"
msgstr ""
"NAT를 사용하려면 [.filename]#/etc/rc.conf# 에 다음 구문을 추가하고 NAT 규칙"
"이 포함된 파일 이름을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2195
#, no-wrap
msgid ""
"gateway_enable=\"YES\"\n"
"ipnat_enable=\"YES\"\n"
"ipnat_rules=\"/etc/ipnat.rules\"\n"
msgstr ""
"gateway_enable=\"YES\"\n"
"ipnat_enable=\"YES\"\n"
"ipnat_rules=\"/etc/ipnat.rules\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2200
msgid ""
"NAT rules are flexible and can accomplish many different things to fit the "
"needs of both commercial and home users.  The rule syntax presented here has "
"been simplified to demonstrate common usage.  For a complete rule syntax "
"description, refer to man:ipnat[5]."
msgstr ""
"NAT 규칙은 유연하며 상업용 및 가정용 사용자 모두의 요구에 맞게 다양한 기능을 "
"수행할 수 있습니다.  여기에 제시된 규칙 구문은 일반적인 사용법을 보여주기 위"
"해 단순화되었습니다.  전체 규칙 구문에 대한 설명은 man:ipnat[5]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2202
msgid ""
"The basic syntax for a NAT rule is as follows, where `map` starts the rule "
"and _IF_ should be replaced with the name of the external interface:"
msgstr ""
"NAT 규칙의 기본 구문은 다음과 같으며, 여기서 `map` 은 규칙을 시작하고 _IF_ "
"는 외부 인터페이스의 이름으로 대체해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2206
#, no-wrap
msgid "map IF LAN_IP_RANGE -> PUBLIC_ADDRESS\n"
msgstr "map IF LAN_IP_RANGE -> PUBLIC_ADDRESS\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2211
msgid ""
"The _LAN_IP_RANGE_ is the range of IP addresses used by internal clients.  "
"Usually, it is a private address range such as `192.168.1.0/24`.  The "
"_PUBLIC_ADDRESS_ can either be the static external IP address or the keyword "
"`0/32` which represents the IP address assigned to _IF_."
msgstr ""
"_LAN_IP_RANGE_ 는 내부 클라이언트에서 사용하는 IP 주소의 범위입니다.  일반적"
"으로 `192.168.1.0/24` 와 같은 개인 주소 범위입니다.  _PUBLIC_ADDRESS_ 는 정"
"적 외부 IP 주소이거나 _IF_ 에 할당된 IP 주소를 나타내는 키워드 `0/32` 일 수 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2218
msgid ""
"In IPF, when a packet arrives at the firewall from the LAN with a public "
"destination, it first passes through the outbound rules of the firewall "
"ruleset.  Then, the packet is passed to the NAT ruleset which is read from "
"the top down, where the first matching rule wins.  IPF tests each NAT rule "
"against the packet's interface name and source IP address.  When a packet's "
"interface name matches a NAT rule, the packet's source IP address in the "
"private LAN is checked to see if it falls within the IP address range "
"specified in _LAN_IP_RANGE_.  On a match, the packet has its source IP "
"address rewritten with the public IP address specified by _PUBLIC_ADDRESS_.  "
"IPF posts an entry in its internal NAT table so that when the packet returns "
"from the Internet, it can be mapped back to its original private IP address "
"before being passed to the firewall rules for further processing."
msgstr ""
"IPF에서는 패킷이 공용 목적지를 가지고 LAN을 통해 방화벽에 도착하면, 먼저 방화"
"벽 규칙 집합의 아웃바운드 규칙을 통과합니다.  그런 다음 패킷은 위에서 아래로 "
"읽혀지는 NAT 규칙 집합으로 전달되며, 여기서 가장 먼저 일치하는 규칙이 승리합"
"니다.  IPF는 패킷의 인터페이스 이름과 소스 IP 주소에 대해 각 NAT 규칙을 테스"
"트합니다.  패킷의 인터페이스 이름이 NAT 규칙과 일치하면, 개인 LAN에서 패킷의 "
"소스 IP 주소가 _LAN_IP_RANGE_ 에 지정된 IP 주소 범위에 속하는지 확인합니다.  "
"일치하는 경우 패킷의 소스 IP 주소는 _PUBLIC_ADDRESS_ 에 지정된 공용 IP 주소"
"로 재작성됩니다.  IPF는 패킷이 인터넷에서 반환될 때, 추가 처리를 위해 방화벽 "
"규칙으로 전달되기 전에 원래의 개인 IP 주소로 다시 매핑될 수 있도록 내부 NAT "
"테이블에 항목을 게시합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2221
msgid ""
"For networks that have large numbers of internal systems or multiple "
"subnets, the process of funneling every private IP address into a single "
"public IP address becomes a resource problem.  Two methods are available to "
"relieve this issue."
msgstr ""
"내부 시스템이 많거나 서브넷이 여러개인 네트워크의 경우, 모든 사설 IP 주소를 "
"하나의 공용 IP 주소로 퍼널링하는 과정에서 리소스 문제가 발생할 수 있습니다.  "
"이 문제를 해결하기 위해 두 가지 방법을 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2224
msgid ""
"The first method is to assign a range of ports to use as source ports.  By "
"adding the `portmap` keyword, NAT can be directed to only use source ports "
"in the specified range:"
msgstr ""
"첫 번째 방법은 소스 포트로 사용할 포트 범위를 지정하는 것입니다.  `portmap` "
"키워드를 추가하면 NAT가 지정된 범위의 소스 포트만 사용하도록 지시할 수 있습니"
"다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2228
#, no-wrap
msgid "map dc0 192.168.1.0/24 -> 0/32 portmap tcp/udp 20000:60000\n"
msgstr "map dc0 192.168.1.0/24 -> 0/32 portmap tcp/udp 20000:60000\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2231
msgid ""
"Alternately, use the `auto` keyword which tells NAT to determine the ports "
"that are available for use:"
msgstr ""
"또는 `auto` 키워드를 사용하여 NAT가 사용 가능한 포트를 결정하도록 지시합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2235
#, no-wrap
msgid "map dc0 192.168.1.0/24 -> 0/32 portmap tcp/udp auto\n"
msgstr "map dc0 192.168.1.0/24 -> 0/32 portmap tcp/udp auto\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2240
msgid ""
"The second method is to use a pool of public addresses.  This is useful when "
"there are too many LAN addresses to fit into a single public address and a "
"block of public IP addresses is available.  These public addresses can be "
"used as a pool from which NAT selects an IP address as a packet's address is "
"mapped on its way out."
msgstr ""
"두 번째 방법은 공개 주소 풀을 사용하는 것입니다.  이 방법은 LAN 주소가 너무 "
"많아서 하나의 공용 주소에 넣을 수 없고 공용 IP 주소 블록을 사용할 수 있는 경"
"우에 유용합니다.  이러한 공용 주소는 패킷의 주소가 나가는 도중 매핑될 때 NAT"
"가 IP 주소를 선택하는 풀로 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2243
msgid ""
"The range of public IP addresses can be specified using a netmask or CIDR "
"notation.  These two rules are equivalent:"
msgstr ""
"공인 IP 주소의 범위는 넷마스크 또는 CIDR 표기법을 사용하여 지정할 수 있습니"
"다.  이 두 규칙은 동일합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2248
#, no-wrap
msgid ""
"map dc0 192.168.1.0/24 -> 204.134.75.0/255.255.255.0\n"
"map dc0 192.168.1.0/24 -> 204.134.75.0/24\n"
msgstr ""
"map dc0 192.168.1.0/24 -> 204.134.75.0/255.255.255.0\n"
"map dc0 192.168.1.0/24 -> 204.134.75.0/24\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2253
#, fuzzy
#| msgid ""
#| "A common practice is to have a publically accessible web server or mail "
#| "server segregated to an internal network segment.  The traffic from these "
#| "servers still has to undergo NAT, but port redirection is needed to "
#| "direct inbound traffic to the correct server.  For example, to map a web "
#| "server using the internal address `10.0.10.25` to its public IP address "
#| "of `20.20.20.5`, use this rule:"
msgid ""
"A common practice is to have a publicly accessible web server or mail server "
"segregated to an internal network segment.  The traffic from these servers "
"still has to undergo NAT, but port redirection is needed to direct inbound "
"traffic to the correct server.  For example, to map a web server using the "
"internal address `10.0.10.25` to its public IP address of `20.20.20.5`, use "
"this rule:"
msgstr ""
"공개적으로 액세스할 수 있는 웹 서버 또는 메일 서버는 내부 네트워크 세그먼트"
"로 분리하는 것이 일반적입니다.  이러한 서버의 트래픽은 여전히 NAT를 거쳐야 하"
"지만 인바운드 트래픽을 올바른 서버로 보내려면 포트 리디렉션이 필요합니다.  예"
"를 들어 내부 주소 `10.0.10.25` 를 사용하는 웹 서버를 공용 IP 주소인 "
"`20.20.20.5` 에 매핑하려면 이 규칙을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2257
#, no-wrap
msgid "rdr dc0 20.20.20.5/32 port 80 -> 10.0.10.25 port 80\n"
msgstr "rdr dc0 20.20.20.5/32 port 80 -> 10.0.10.25 port 80\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2260
msgid ""
"If it is the only web server, this rule would also work as it redirects all "
"external HTTP requests to `10.0.10.25`:"
msgstr ""
"유일한 웹 서버인 경우, 이 규칙은 모든 외부 HTTP 요청을 `10.0.10.25` 로 리디렉"
"션하므로 이 규칙도 작동합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2264
#, no-wrap
msgid "rdr dc0 0.0.0.0/0 port 80 -> 10.0.10.25 port 80\n"
msgstr "rdr dc0 0.0.0.0/0 port 80 -> 10.0.10.25 port 80\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2269
msgid ""
"IPF has a built in FTP proxy which can be used with NAT.  It monitors all "
"outbound traffic for active or passive FTP connection requests and "
"dynamically creates temporary filter rules containing the port number used "
"by the FTP data channel.  This eliminates the need to open large ranges of "
"high order ports for FTP connections."
msgstr ""
"IPF에는 NAT와 함께 사용할 수 있는 FTP 프록시가 내장되어 있습니다.  이 프록시"
"는 모든 아웃바운드 트래픽에서 액티브 또는 패시브 FTP 연결 요청을 모니터링하"
"고 FTP 데이터 채널에서 사용하는 포트 번호가 포함된 임시 필터 규칙을 동적으로 "
"생성합니다.  따라서 FTP 연결을 위해 높은 수준의 포트를 광범위하게 열 필요가 "
"없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2272
msgid ""
"In this example, the first rule calls the proxy for outbound FTP traffic "
"from the internal LAN.  The second rule passes the FTP traffic from the "
"firewall to the Internet, and the third rule handles all non-FTP traffic "
"from the internal LAN:"
msgstr ""
"이 예에서 첫 번째 규칙은 내부 LAN에서 아웃바운드 FTP 트래픽에 대해 프록시를 "
"호출합니다.  두 번째 규칙은 방화벽에서 인터넷으로 FTP 트래픽을 전달하고, 세 "
"번째 규칙은 내부 LAN의 모든 비-FTP 트래픽을 처리합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2278
#, no-wrap
msgid ""
"map dc0 10.0.10.0/29 -> 0/32 proxy port 21 ftp/tcp\n"
"map dc0 0.0.0.0/0 -> 0/32 proxy port 21 ftp/tcp\n"
"map dc0 10.0.10.0/29 -> 0/32\n"
msgstr ""
"map dc0 10.0.10.0/29 -> 0/32 proxy port 21 ftp/tcp\n"
"map dc0 0.0.0.0/0 -> 0/32 proxy port 21 ftp/tcp\n"
"map dc0 10.0.10.0/29 -> 0/32\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2282
msgid ""
"The FTP `map` rules go before the NAT rule so that when a packet matches an "
"FTP rule, the FTP proxy creates temporary filter rules to let the FTP "
"session packets pass and undergo NAT.  All LAN packets that are not FTP will "
"not match the FTP rules but will undergo NAT if they match the third rule."
msgstr ""
"FTP `map` 규칙은 NAT 규칙보다 먼저 적용되므로 패킷이 FTP 규칙과 일치하면 FTP "
"프록시는 임시 필터 규칙을 생성하여 FTP 세션 패킷을 통과시키고 NAT를 거치게 합"
"니다.  FTP가 아닌 모든 LAN 패킷은 FTP 규칙과 일치하지 않지만 세 번째 규칙과 "
"일치하는 경우 NAT를 거칩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2285
msgid ""
"Without the FTP proxy, the following firewall rules would instead be "
"needed.  Note that without the proxy, all ports above `1024` need to be "
"allowed:"
msgstr ""
"FTP 프록시가 없으면 대신 다음 방화벽 규칙이 필요합니다.  프록시가 없으면 "
"`1024` 이상의 모든 포트를 허용해야 한다는 점에 유의하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2291
#, no-wrap
msgid ""
"# Allow out LAN PC client FTP to public Internet\n"
"# Active and passive modes\n"
"pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state\n"
msgstr ""
"# Allow out LAN PC client FTP to public Internet\n"
"# Active and passive modes\n"
"pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2294
#, no-wrap
msgid ""
"# Allow out passive mode data channel high order port numbers\n"
"pass out quick on rl0 proto tcp from any to any port > 1024 flags S keep state\n"
msgstr ""
"# Allow out passive mode data channel high order port numbers\n"
"pass out quick on rl0 proto tcp from any to any port > 1024 flags S keep state\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2297
#, no-wrap
msgid ""
"# Active mode let data channel in from FTP server\n"
"pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state\n"
msgstr ""
"# Active mode let data channel in from FTP server\n"
"pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2301
msgid ""
"Whenever the file containing the NAT rules is edited, run `ipnat` with `-CF` "
"to delete the current NAT rules and flush the contents of the dynamic "
"translation table.  Include `-f` and specify the name of the NAT ruleset to "
"load:"
msgstr ""
"NAT 규칙이 포함된 파일을 편집할 때마다 `-CF` 와 함께 `ipnat` 를 실행하여 현"
"재 NAT 규칙을 삭제하고 동적 번역 테이블의 내용을 플러시합니다.  `-f` 를 포함"
"하고 로드할 NAT 규칙 집합의 이름을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2305
#, no-wrap
msgid "# ipnat -CF -f /etc/ipnat.rules\n"
msgstr "# ipnat -CF -f /etc/ipnat.rules\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2308
msgid "To display the NAT statistics:"
msgstr "NAT 통계를 화면에 표시하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2312
#, no-wrap
msgid "# ipnat -s\n"
msgstr "# ipnat -s\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2315
msgid "To list the NAT table's current mappings:"
msgstr "현재 NAT 매핑 테이블을 확인하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2319
#, no-wrap
msgid "# ipnat -l\n"
msgstr "# ipnat -l\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2322
msgid ""
"To turn verbose mode on and display information relating to rule processing "
"and active rules and table entries:"
msgstr ""
"자세한 설명 모드를 켜고 규칙 처리, 활성 규칙 및 테이블 항목과 관련된 정보를 "
"표시하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2326
#, no-wrap
msgid "# ipnat -v\n"
msgstr "# ipnat -v\n"

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2328
#, no-wrap
msgid "Viewing IPF Statistics"
msgstr "IPF 통계보기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2332
msgid ""
"IPF includes man:ipfstat[8] which can be used to retrieve and display "
"statistics which are gathered as packets match rules as they go through the "
"firewall.  Statistics are accumulated since the firewall was last started or "
"since the last time they were reset to zero using `ipf -Z`."
msgstr ""
"IPF에는 방화벽을 통과할 때 패킷 일치 규칙으로 수집된 통계를 검색하고 표시하"
"는 데 사용할 수 있는 man:ipfstat[8]이 포함되어 있습니다.  통계는 방화벽이 마"
"지막으로 시작된 이후 또는 `ipf -Z` 를 사용하여 가장 최근 0으로 재설정된 이후"
"를 집계합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2334
msgid "The default `ipfstat` output looks like this:"
msgstr "기본 `ipfstat` 출력은 다음과 같이 표시됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2354
#, no-wrap
msgid ""
"input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0\n"
" output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0\n"
" input packets logged: blocked 99286 passed 0\n"
" output packets logged: blocked 0 passed 0\n"
" packets logged: input 0 output 0\n"
" log failures: input 3898 output 0\n"
" fragment state(in): kept 0 lost 0\n"
" fragment state(out): kept 0 lost 0\n"
" packet state(in): kept 169364 lost 0\n"
" packet state(out): kept 431395 lost 0\n"
" ICMP replies: 0 TCP RSTs sent: 0\n"
" Result cache hits(in): 1215208 (out): 1098963\n"
" IN Pullups succeeded: 2 failed: 0\n"
" OUT Pullups succeeded: 0 failed: 0\n"
" Fastroute successes: 0 failures: 0\n"
" TCP cksum fails(in): 0 (out): 0\n"
" Packet log flags set: (0)\n"
msgstr ""
"input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0\n"
" output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0\n"
" input packets logged: blocked 99286 passed 0\n"
" output packets logged: blocked 0 passed 0\n"
" packets logged: input 0 output 0\n"
" log failures: input 3898 output 0\n"
" fragment state(in): kept 0 lost 0\n"
" fragment state(out): kept 0 lost 0\n"
" packet state(in): kept 169364 lost 0\n"
" packet state(out): kept 431395 lost 0\n"
" ICMP replies: 0 TCP RSTs sent: 0\n"
" Result cache hits(in): 1215208 (out): 1098963\n"
" IN Pullups succeeded: 2 failed: 0\n"
" OUT Pullups succeeded: 0 failed: 0\n"
" Fastroute successes: 0 failures: 0\n"
" TCP cksum fails(in): 0 (out): 0\n"
" Packet log flags set: (0)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2360
msgid ""
"Several options are available.  When supplied with either `-i` for inbound "
"or `-o` for outbound, the command will retrieve and display the appropriate "
"list of filter rules currently installed and in use by the kernel.  To also "
"see the rule numbers, include `-n`.  For example, `ipfstat -on` displays the "
"outbound rules table with rule numbers:"
msgstr ""
"몇 가지 옵션을 사용할 수 있습니다.  인바운드의 경우 `-i`, 또는 아웃바운드의 "
"경우 `-o` 와 함께 사용하면 명령어는 현재 설치되어 커널에서 사용 중인 적절한 "
"필터 규칙 목록을 검색하여 표시합니다.  규칙 번호도 보려면 `-n` 을 포함하세"
"요.  예를 들어 `ipfstat -on` 은 규칙 번호와 함께 아웃바운드 규칙 테이블을 표"
"시합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2366
#, no-wrap
msgid ""
"@1 pass out on xl0 from any to any\n"
"@2 block out on dc0 from any to any\n"
"@3 pass out quick on dc0 proto tcp/udp from any to any keep state\n"
msgstr ""
"@1 pass out on xl0 from any to any\n"
"@2 block out on dc0 from any to any\n"
"@3 pass out quick on dc0 proto tcp/udp from any to any keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2370
msgid ""
"Include `-h` to prefix each rule with a count of how many times the rule was "
"matched.  For example, `ipfstat -oh` displays the outbound internal rules "
"table, prefixing each rule with its usage count:"
msgstr ""
"각 규칙 앞에 `-h` 를 포함하면 규칙이 일치한 횟수를 계산하여 표시합니다.  예"
"를 들어, `ipfstat -oh` 는 아웃바운드 내부 규칙 테이블을 표시하며, 각 규칙 앞"
"에 사용 횟수를 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2376
#, no-wrap
msgid ""
"2451423 pass out on xl0 from any to any\n"
"354727 block out on dc0 from any to any\n"
"430918 pass out quick on dc0 proto tcp/udp from any to any keep state\n"
msgstr ""
"2451423 pass out on xl0 from any to any\n"
"354727 block out on dc0 from any to any\n"
"430918 pass out quick on dc0 proto tcp/udp from any to any keep state\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2382
msgid ""
"To display the state table in a format similar to man:top[1], use `ipfstat -"
"t`.  When the firewall is under attack, this option provides the ability to "
"identify and see the attacking packets.  The optional sub-flags give the "
"ability to select the destination or source IP, port, or protocol to be "
"monitored in real time.  Refer to man:ipfstat[8] for details."
msgstr ""
"man:top[1]과 유사한 형식으로 상태 테이블을 표시하려면 `ipfstat -t` 를 사용합"
"니다.  방화벽이 공격을 받고 있는 경우 이 옵션을 사용하면 공격 패킷을 식별하"
"고 확인할 수 있습니다.  선택적 하위 플래그를 사용하면 실시간으로 모니터링할 "
"대상 또는 소스 IP, 포트 또는 프로토콜을 선택할 수 있습니다.  자세한 내용은 "
"man:ipfstat[8]을 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2383
#, no-wrap
msgid "IPF Logging"
msgstr "IPF 로깅"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2387
msgid ""
"IPF provides `ipmon`, which can be used to write the firewall's logging "
"information in a human readable format.  It requires that `options "
"IPFILTER_LOG` be first added to a custom kernel using the instructions in "
"crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]."
msgstr ""
"IPF는 방화벽의 로깅 정보를 사람이 읽을 수 있는 형식으로 작성하는 데 사용할 "
"수 있는 `ipmon` 을 제공합니다.  이를 사용하려면 먼저 `options IPFILTER_LOG` "
"를 crossref:kernelconfig[kernelconfig,FreeBSD 커널 구성]의 지침에 따라 커스"
"텀 커널에 추가해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2390
msgid ""
"This command is typically run in daemon mode in order to provide a "
"continuous system log file so that logging of past events may be reviewed.  "
"Since FreeBSD has a built in man:syslogd[8] facility to automatically rotate "
"system logs, the default [.filename]#rc.conf# `ipmon_flags` statement uses `-"
"Ds`:"
msgstr ""
"이 명령은 일반적으로 과거 이벤트의 로그를 검토할 수 있도록 지속적인 시스템 로"
"그 파일을 제공하기 위해 데몬 모드에서 실행됩니다.  FreeBSD에는 시스템 로그를 "
"자동으로 순환하는 man:syslogd[8] 기능이 내장되어 있기 때문에, 기본 [."
"filename]#rc.conf# 의 `ipmon_flags` 문은 `-Ds` 를 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2397
#, no-wrap
msgid ""
"ipmon_flags=\"-Ds\" # D = start as daemon\n"
"                  # s = log to syslog\n"
"                  # v = log tcp window, ack, seq\n"
"                  # n = map IP & port to names\n"
msgstr ""
"ipmon_flags=\"-Ds\" # D = start as daemon\n"
"                  # s = log to syslog\n"
"                  # v = log tcp window, ack, seq\n"
"                  # n = map IP & port to names\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2401
msgid ""
"Logging provides the ability to review, after the fact, information such as "
"which packets were dropped, what addresses they came from, and where they "
"were going.  This information is useful in tracking down attackers."
msgstr ""
"로깅은 어떤 패킷이 삭제되었는지, 어떤 주소에서 왔는지, 어디로 이동했는지 등"
"의 정보를 사후에 검토할 수 있는 기능을 제공합니다.  이 정보는 공격자를 추적하"
"는 데 유용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2406
msgid ""
"Once the logging facility is enabled in [.filename]#rc.conf# and started "
"with `service ipmon start`, IPF will only log the rules which contain the "
"`log` keyword.  The firewall administrator decides which rules in the "
"ruleset should be logged and normally only deny rules are logged.  It is "
"customary to include the `log` keyword in the last rule in the ruleset.  "
"This makes it possible to see all the packets that did not match any of the "
"rules in the ruleset."
msgstr ""
"[.filename]#rc.conf# 에서 로깅 기능을 활성화하고 `service ipmon start` 로 시"
"작하면, IPF는 `log` 키워드가 포함된 규칙만 로깅합니다.  방화벽 관리자는 규칙 "
"집합에서 어떤 규칙을 기록할지 결정하며 일반적으로 거부 규칙만 기록합니다.  규"
"칙 집합의 마지막 규칙에 `log` 키워드를 포함하는 것이 일반적입니다.  이렇게 하"
"면 규칙 집합의 규칙과 일치하지 않는 모든 패킷을 볼 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2409
msgid ""
"By default, `ipmon -Ds` mode uses `local0` as the logging facility.  The "
"following logging levels can be used to further segregate the logged data:"
msgstr ""
"기본적으로 `ipmon -Ds` 모드는 `local0` 을 로깅 도구로 사용합니다.  다음 로깅 "
"수준을 사용하여 로깅된 데이터를 더 분리할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2416
#, no-wrap
msgid ""
"LOG_INFO - packets logged using the \"log\" keyword as the action rather than pass or block.\n"
"LOG_NOTICE - packets logged which are also passed\n"
"LOG_WARNING - packets logged which are also blocked\n"
"LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header\n"
msgstr ""
"LOG_INFO - packets logged using the \"log\" keyword as the action rather than pass or block.\n"
"LOG_NOTICE - packets logged which are also passed\n"
"LOG_WARNING - packets logged which are also blocked\n"
"LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2419
msgid ""
"In order to setup IPF to log all data to [.filename]#/var/log/ipfilter.log#, "
"first create the empty file:"
msgstr ""
"모든 데이터를 [.filename]#/var/log/ipfilter.log# 에 기록하도록 IPF를 설정하려"
"면 먼저 빈 파일을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2423
#, no-wrap
msgid "# touch /var/log/ipfilter.log\n"
msgstr "# touch /var/log/ipfilter.log\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2426
msgid ""
"Then, to write all logged messages to the specified file, add the following "
"statement to [.filename]#/etc/syslog.conf#:"
msgstr ""
"그런 다음 모든 로깅된 메시지를 지정된 파일에 쓰려면 [.filename]#/etc/syslog."
"conf# 에 다음 명령을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2430
#, no-wrap
msgid "local0.* /var/log/ipfilter.log\n"
msgstr "local0.* /var/log/ipfilter.log\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2433
msgid ""
"To activate the changes and instruct man:syslogd[8] to read the modified [."
"filename]#/etc/syslog.conf#, run `service syslogd reload`."
msgstr ""
"변경 사항을 활성화하고 man:syslogd[8]가 수정된 [.filename]#/etc/syslog.conf# "
"를 읽도록 지시하려면 `service syslogd reload` 를 실행합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2435
msgid ""
"Do not forget to edit [.filename]#/etc/newsyslog.conf# to rotate the new log "
"file."
msgstr ""
"새 로그 파일을 회전시키기 위해 [.filename]#/etc/newsyslog.conf# 를 편집하는 "
"것을 잊지 마세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2438
msgid ""
"Messages generated by `ipmon` consist of data fields separated by white "
"space.  Fields common to all messages are:"
msgstr ""
"`ipmon` 에서 생성된 메시지는 공백으로 구분된 데이터 필드로 구성됩니다.  모든 "
"메시지에 공통으로 사용되는 필드는 다음과 같습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2440
msgid "The date of packet receipt."
msgstr "The date of packet receipt."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2441
msgid ""
"The time of packet receipt. This is in the form HH:MM:SS.F, for hours, "
"minutes, seconds, and fractions of a second."
msgstr ""
"The time of packet receipt. 시간, 분, 초, 분초 단위의 HH:MM:SS.F 형식입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2442
msgid "The name of the interface that processed the packet."
msgstr "패킷을 처리한 인터페이스의 이름."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2443
msgid "The group and rule number of the rule in the format `@0:17`."
msgstr "`@0:17` 형식으로 된 그룹과 규칙의 규칙번호."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2444
msgid ""
"The action: `p` for passed, `b` for blocked, `S` for a short packet, `n` did "
"not match any rules, and `L` for a log rule."
msgstr ""
"The action: `p` 는 통과됨, `b` 는 차단됨, `S` 는 짧은 패킷, `n` 은 규칙과 일"
"치하지 않음, `L` 은 로그 규칙."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2445
msgid ""
"The addresses written as three fields: the source address and port separated "
"by a comma, the -> symbol, and the destination address and port. For "
"example: `209.53.17.22,80 -> 198.73.220.17,1722`."
msgstr ""
"쉼표로 구분된 소스 주소와 포트 -> 기호, 대상 주소와 포트의 세 가지 필드로 작"
"성된 주소. 예: `209.53.17.22,80 -> 198.73.220.17,1722`."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2446
msgid "`PR` followed by the protocol name or number: for example, `PR tcp`."
msgstr "프로토콜의 이름이나 번호 다음에 오는 `PR`. 예: `PR tcp`."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2447
msgid ""
"`len` followed by the header length and total length of the packet: for "
"example, `len 20 40`."
msgstr "헤더 길이와 패킷의 총 길이 다음에 오는 `len`. 예: `len 20 40`."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2450
msgid ""
"If the packet is a TCP packet, there will be an additional field starting "
"with a hyphen followed by letters corresponding to any flags that were set.  "
"Refer to man:ipf[5] for a list of letters and their flags."
msgstr ""
"패킷이 TCP 패킷인 경우, 하이픈으로 시작하는 추가 필드에 설정된 플래그에 해당"
"하는 문자가 이어집니다.  문자와 해당 플래그 목록은 man:ipf[5]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2453
msgid ""
"If the packet is an ICMP packet, there will be two fields at the end: the "
"first always being \"icmp\" and the next being the ICMP message and sub-"
"message type, separated by a slash.  For example: `icmp 3/3` for a port "
"unreachable message."
msgstr ""
"패킷이 ICMP 패킷인 경우 마지막에 두 개의 필드가 있는데, 첫 번째는 항상 "
"“icmp”이고 그 다음에는 슬래시로 구분된 ICMP 메시지 및 하위 메시지 유형이 있습"
"니다.  예: 연결할 수 없는 포트 메시지의 경우 `icmp 3/3`."

#. type: Title ==
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2455
#, no-wrap
msgid "Blacklistd"
msgstr "Blacklistd"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2462
msgid ""
"Blacklistd is a daemon listening to sockets awaiting to receive "
"notifications from other daemons about connection attempts that failed or "
"were successful.  It is most widely used in blocking too many connection "
"attempts on open ports.  A prime example is SSH running on the internet "
"getting a lot of requests from bots or scripts trying to guess passwords and "
"gain access.  Using blacklistd, the daemon can notify the firewall to create "
"a filter rule to block excessive connection attempts from a single source "
"after a number of tries. Blacklistd was first developed on NetBSD and "
"appeared there in version 7.  FreeBSD 11 imported blacklistd from NetBSD."
msgstr ""
"blacklistd는 소켓을 수신 대기하면서 다른 데몬으로부터 연결 시도가 실패했거나 "
"성공했다는 알림을 받는 데몬입니다.  열린 포트에서 너무 많은 연결 시도를 차단"
"하는 데 가장 널리 사용됩니다.  대표적인 예로 인터넷에서 실행되는 SSH가 비밀번"
"호를 추측하고 액세스 권한을 얻으려는 봇이나 스크립트로부터 많은 요청을 받는 "
"경우를 들 수 있습니다.  blacklistd를 사용하면 데몬이 방화벽에 알림을 보내 여"
"러 번 시도한 후 단일 소스에서 과도한 연결 시도를 차단하는 필터 규칙을 만들 "
"수 있습니다. blacklistd는 NetBSD에서 처음 개발되어 버전 7에 등장했습니다.  "
"FreeBSD 11은 NetBSD에서 blacklistd를 가져왔습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2467
msgid ""
"This chapter describes how to set up blacklistd, configure it, and provides "
"examples on how to use it.  Readers should be familiar with basic firewall "
"concepts like rules.  For details, refer to the firewall chapter.  PF is "
"used in the examples, but other firewalls available on FreeBSD should be "
"able to work with blacklistd, too."
msgstr ""
"이 장에서는 blacklistd를 설정하고 구성하는 방법을 설명하고 사용 방법에 대한 "
"예제를 제공합니다.  독자는 규칙과 같은 기본 방화벽 개념에 익숙해야 합니다.  "
"자세한 내용은 방화벽 챕터를 참조하세요.  예제에서는 PF가 사용되었지만, "
"FreeBSD에서 사용할 수 있는 다른 방화벽도 blacklistd와 함께 작동할 수 있어야 "
"합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2468
#, no-wrap
msgid "Enabling Blacklistd"
msgstr "blacklistd 활성화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2474
msgid ""
"The main configuration for blacklistd is stored in man:blacklistd.conf[5].  "
"Various command line options are also available to change blacklistd's run-"
"time behavior.  Persistent configuration across reboots should be stored in "
"[.filename]#/etc/blacklistd.conf#.  To enable the daemon during system boot, "
"add a `blacklistd_enable` line to [.filename]#/etc/rc.conf# like this:"
msgstr ""
"blacklistd의 기본 구성은 man:blacklistd.conf[5]에 저장됩니다.  blacklistd의 "
"런타임 동작을 변경하기 위해 다양한 명령줄 옵션도 사용할 수 있습니다.  재부팅 "
"시에도 지속되는 구성은 [.filename]#/etc/blacklistd.conf# 에 저장해야 합니"
"다.  시스템 부팅 시 데몬을 활성화하려면 다음과 같이 [.filename]#/etc/rc."
"conf# 에 `blacklistd_enable` 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2478
#, no-wrap
msgid "# sysrc blacklistd_enable=yes\n"
msgstr "# sysrc blacklistd_enable=yes\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2481
msgid "To start the service manually, run this command:"
msgstr "서비스를 수동으로 시작하려면 다음 명령을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2485
#, no-wrap
msgid "# service blacklistd start\n"
msgstr "# service blacklistd start\n"

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2487
#, no-wrap
msgid "Creating a Blacklistd Ruleset"
msgstr "Blacklistd 규칙 집합 만들기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2492
msgid ""
"Rules for blacklistd are configured in man:blacklistd.conf[5] with one entry "
"per line.  Each rule contains a tuple separated by spaces or tabs.  Rules "
"either belong to a `local` or a `remote`, which applies to the machine where "
"blacklistd is running or an outside source, respectively."
msgstr ""
"Blacklistd에 대한 규칙은 한 줄당 하나의 항목으로 man:blacklistd.conf[5]에 구"
"성됩니다.  각 규칙은 공백 또는 탭으로 구분된 튜플을 포함합니다.  규칙은 "
"`local` 또는 `remote` 에 속하며, 각각 blacklistd가 실행 중인 머신 또는 외부 "
"소스에 적용됩니다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2493
#, no-wrap
msgid "Local Rules"
msgstr "로컬 규칙"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2496
msgid "An example blacklistd.conf entry for a local rule looks like this:"
msgstr "로컬 규칙에 대한 blacklistd.conf 항목의 예는 다음과 같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2501
#, no-wrap
msgid ""
"[local]\n"
"ssh             stream  *       *               *       3       24h\n"
msgstr ""
"[local]\n"
"ssh             stream  *       *               *       3       24h\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2505
msgid ""
"All rules that follow the `[local]` section are treated as local rules "
"(which is the default), applying to the local machine.  When a `[remote]` "
"section is encountered, all rules that follow it are handled as remote "
"machine rules."
msgstr ""
"`[local]` 섹션 뒤에 오는 모든 규칙은 로컬 규칙(기본값)으로 처리되어 로컬 머신"
"에 적용됩니다.  `[remote]` 섹션을 발견하면 그 뒤에 오는 모든 규칙은 원격 컴퓨"
"터 규칙으로 처리됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2513
msgid ""
"Seven fields separated by either tabs or spaces define a rule.  The first "
"four fields identify the traffic that should be blocklisted.  The three "
"fields that follow define backlistd's behavior.  Wildcards are denoted as "
"asterisks (`*`), matching anything in this field.  The first field defines "
"the location.  In local rules, these are the network ports.  The syntax for "
"the location field is as follows:"
msgstr ""
"탭 또는 공백으로 구분된 7개의 필드가 규칙을 정의합니다.  처음 4개의 필드는 차"
"단 목록에 추가해야 하는 트래픽을 식별합니다.  그 뒤에 나오는 세 개의 필드는 "
"backlistd의 동작을 정의합니다.  와일드카드는 별표( `*` )로 표시되며 이 필드"
"에 있는 모든 항목과 일치합니다.  첫 번째 필드는 위치를 정의합니다.  로컬 규칙"
"에서는 네트워크 포트입니다.  위치 필드의 구문은 다음과 같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2517
#, no-wrap
msgid "[address|interface][/mask][:port]\n"
msgstr "[address|interface][/mask][:port]\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2521
msgid ""
"Addresses can be specified as IPv4 in numeric format or IPv6 in square "
"brackets.  An interface name like `_em0_` can also be used."
msgstr ""
"주소는 숫자 형식의 IPv4 또는 대괄호 안의 IPv6로 지정할 수 있습니다.  `_em0_` "
"와 같은 인터페이스 이름도 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2525
msgid ""
"The socket type is defined by the second field.  TCP sockets are of type "
"`stream`, whereas UDP is denoted as `dgram`.  The example above uses TCP, "
"since SSH is using that protocol."
msgstr ""
"소켓 유형은 두 번째 필드에 의해 정의됩니다.  TCP 소켓은 `stream` 유형인 반"
"면, UDP는 `dgram` 으로 표시됩니다.  위의 예에서는 SSH가 해당 프로토콜을 사용"
"하기 때문에 TCP를 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2529
msgid ""
"A protocol can be used in the third field of a blacklistd rule.  The "
"following protocols can be used: `tcp`, `udp`, `tcp6`, `udp6`, or numeric.  "
"A wildcard, like in the example, is typically used to match all protocols "
"unless there is a reason to distinguish traffic by a certain protocol."
msgstr ""
"프로토콜은 blacklistd 규칙의 세 번째 필드에 사용할 수 있습니다.  다음 프로토"
"콜을 사용할 수 있습니다: `tcp`, `udp`, `tcp6`, `udp6` 또는 숫자.  예제에서와 "
"같이 와일드카드는 특정 프로토콜로 트래픽을 구분할 이유가 없는 한 일반적으로 "
"모든 프로토콜을 일치시키는 데 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2532
msgid ""
"In the fourth field, the effective user or owner of the daemon process that "
"is reporting the event is defined.  The username or UID can be used here, as "
"well as a wildcard (see example rule above)."
msgstr ""
"네 번째 필드에는 이벤트를 보고하는 데몬 프로세스의 유효 사용자 또는 소유자가 "
"정의됩니다.  여기에는 와일드카드뿐만 아니라 사용자 이름 또는 UID도 사용할 수 "
"있습니다(위의 규칙 예시 참조)."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2535
msgid ""
"The packet filter rule name is declared by the fifth field, which starts the "
"behavior part of the rule.  By default, blacklistd puts all blocks under a "
"pf anchor called `blacklistd` in [.filename]#pf.conf# like this:"
msgstr ""
"패킷 필터 규칙 이름은 규칙의 동작 부분을 시작하는 다섯 번째 필드에서 선언됩니"
"다.  기본적으로 blacklistd는 다음과 같이 모든 블록을 [.filename]#pf.conf# 의 "
"`blacklistd` 라는 pf 앵커 아래에 배치합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2541
#, no-wrap
msgid ""
"anchor \"blacklistd/*\" in on $ext_if\n"
"block in\n"
"pass out\n"
msgstr ""
"anchor \"blacklistd/*\" in on $ext_if\n"
"block in\n"
"pass out\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2547
msgid ""
"For separate blocklists, an anchor name can be used in this field.  In other "
"cases, the wildcard will suffice.  When a name starts with a hyphen (`-`) it "
"means that an anchor with the default rule name prepended should be used.  A "
"modified example from the above using the hyphen would look like this:"
msgstr ""
"별도의 차단 목록의 경우 이 필드에 앵커 이름을 사용할 수 있습니다.  다른 경우"
"에는 와일드카드로 충분합니다.  이름이 하이픈( `-` )으로 시작하면 기본 규칙 이"
"름이 앞에 붙은 앵커를 사용해야 한다는 의미입니다.  위의 예에서 하이픈을 사용"
"하여 수정한 예는 다음과 같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2551
#, no-wrap
msgid "ssh             stream  *       *               -ssh       3       24h\n"
msgstr "ssh             stream  *       *               -ssh       3       24h\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2554
msgid ""
"With such a rule, any new blocklist rules are added to an anchor called "
"`blacklistd-ssh`."
msgstr ""
"이러한 규칙을 사용하면 새 blocklist 규칙이 `blacklistd-ssh` 라는 앵커에 추가"
"됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2558
msgid ""
"To block whole subnets for a single rule violation, a `/` in the rule name "
"can be used.  This causes the remaining portion of the name to be "
"interpreted as the mask to be applied to the address specified in the rule.  "
"For example, this rule would block every address adjoining `/24`."
msgstr ""
"단일 규칙 위반에 대해 전체 서브넷을 차단하려면 규칙 이름에 `/` 를 사용할 수 "
"있습니다.  이렇게 하면 이름의 나머지 부분이 규칙에 지정된 주소에 적용되는 마"
"스크로 해석됩니다.  예를 들어, 이 규칙은 `/24` 에 인접한 모든 주소를 차단합니"
"다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2562
#, no-wrap
msgid "22              stream  tcp       *               */24    3       24h\n"
msgstr "22              stream  tcp       *               */24    3       24h\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2568
msgid ""
"It is important to specify the proper protocol here.  IPv4 and IPv6 "
"treat /24 differently, that is the reason why `*` cannot be used in the "
"third field for this rule."
msgstr ""
"여기에 적절한 프로토콜을 지정하는 것이 중요합니다.  IPv4와 IPv6는 /24를 다르"
"게 처리하기 때문에 이 규칙의 세 번째 필드에 `*` 를 사용할 수 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2571
msgid ""
"This rule defines that if any one host in that network is misbehaving, "
"everything else on that network will be blocked, too."
msgstr ""
"이 규칙은 해당 네트워크의 호스트 중 하나라도 잘못 동작하면 해당 네트워크의 다"
"른 모든 호스트도 차단되도록 정의합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2575
msgid ""
"The sixth field, called `nfail`, sets the number of login failures required "
"to blocklist the remote IP in question.  When a wildcard is used at this "
"position, it means that blocks will never happen.  In the example rule "
"above, a limit of three is defined meaning that after three attempts to log "
"into SSH on one connection, the IP is blocked."
msgstr ""
"여섯 번째 필드인 `nfail` 은 해당 원격 IP를 차단 목록에 올리는 데 필요한 로그"
"인 실패 횟수를 설정합니다.  이 위치에 와일드카드를 사용하면 차단이 발생하지 "
"않습니다.  위의 예제 규칙에서는 3번의 제한이 정의되어 있는데, 이는 한 연결에"
"서 SSH 로그인을 세 번 시도하면 해당 IP가 차단된다는 의미입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2578
msgid ""
"The last field in a blacklistd rule definition specifies how long a host is "
"blocklisted.  The default unit is seconds, but suffixes like `m`, `h`, and "
"`d` can also be specified for minutes, hours, and days, respectively."
msgstr ""
"Blacklistd 규칙 정의의 마지막 필드는 호스트가 차단 목록에 포함되는 시간을 지"
"정합니다.  기본 단위는 초이지만 `m`, `h`, `d` 와 같은 접미사를 사용하여 각각 "
"분, 시간, 일 단위로 지정할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2582
msgid ""
"The example rule in its entirety means that after three times authenticating "
"to SSH will result in a new PF block rule for that host.  Rule matches are "
"performed by first checking local rules one after another, from most "
"specific to least specific.  When a match occurs, the `remote` rules are "
"applied and the name, `nfail`, and disable fields are changed by the "
"`remote` rule that matched."
msgstr ""
"이 예제 규칙을 전체적으로 보면 SSH에 세 번 인증하면 해당 호스트에 대한 새로"
"운 PF 차단 규칙이 적용됩니다.  규칙 일치는 먼저 로컬 규칙을 가장 구체적인 것"
"부터 가장 덜 구체적인 것까지 차례로 확인하여 수행됩니다.  일치하는 규칙이 발"
"생하면 `remote` 규칙이 적용되고 일치하는 `remote` 규칙에 의해 이름, `nfail` "
"및 비활성화 필드가 변경됩니다."

#. type: Title ====
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2583
#, no-wrap
msgid "Remote Rules"
msgstr "원격 규칙"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2589
msgid ""
"Remote rules are used to specify how blacklistd changes its behavior "
"depending on the remote host currently being evaluated.  Each field in a "
"remote rule is the same as in a local rule.  The only difference is in the "
"way blacklistd is using them.  To explain it, this example rule is used:"
msgstr ""
"원격 규칙은 현재 평가 중인 원격 호스트에 따라 blacklistd가 동작방법을 변경하"
"는데 사용됩니다.  원격 규칙의 각 필드는 로컬 규칙과 동일합니다.  유일한 차이"
"점은 blacklistd가 이를 사용하는 방식입니다.  이를 설명하기 위해 다음 예제 규"
"칙을 보세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2594
#, no-wrap
msgid ""
"[remote]\n"
"203.0.113.128/25 *      *       *               =/25    =       48h\n"
msgstr ""
"[remote]\n"
"203.0.113.128/25 *      *       *               =/25    =       48h\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2599
msgid ""
"The address field can be an IP address (either v4 or v6), a port or both.  "
"This allows setting special rules for a specific remote address range like "
"in this example.  The fields for socket type, protocol and owner are "
"identically interpreted as in the local rule."
msgstr ""
"주소 필드는 IP 주소(v4 또는 v6), 포트 또는 둘 다일 수 있습니다.  이를 통해 "
"이 예제에서와 같이 특정 원격 주소 범위에 대한 특수 규칙을 설정할 수 있습니"
"다.  소켓 유형, 프로토콜 및 소유자 필드는 로컬 규칙에서와 동일하게 해석됩니"
"다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2605
msgid ""
"The name fields is different though: the equal sign (`=`) in a remote rule "
"tells blacklistd to use the value from the matching local rule.  It means "
"that the firewall rule entry is taken and the `/25` prefix (a netmask of "
"`255.255.255.128`) is added.  When a connection from that address range is "
"blocklisted, the entire subnet is affected.  A PF anchor name can also be "
"used here, in which case blacklistd will add rules for this address block to "
"the anchor of that name.  The default table is used when a wildcard is "
"specified."
msgstr ""
"이름 필드는 다르지만 원격 규칙의 등호( `=` )는 일치하는 로컬 규칙의 값을 사용"
"하도록 blacklistd에 지시합니다.  즉, 방화벽 규칙 항목을 가져와서 `/25` 접두사"
"( 넷마스크 `255.255.255.128` )를 추가합니다.  해당 주소 범위의 연결이 차단 목"
"록에 추가되면 전체 서브넷이 영향을 받습니다.  여기에 PF 앵커 이름을 사용할 수"
"도 있으며, 이 경우 blacklistd는 해당 이름의 앵커에 이 주소 블록에 대한 규칙"
"을 추가합니다.  와일드카드가 지정되면 기본 테이블이 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2609
msgid ""
"A custom number of failures in the `nfail` column can be defined for an "
"address.  This is useful for exceptions to a specific rule, to maybe allow "
"someone a less strict application of rules or a bit more leniency in login "
"tries.  Blocking is disabled when an asterisk is used in this sixth field."
msgstr ""
"`nfail` 열에 주소에 대한 사용자 지정 실패 횟수를 정의할 수 있습니다.  이는 특"
"정 규칙에 대한 예외를 허용하거나 규칙을 덜 엄격하게 적용하거나 로그인 시도를 "
"조금 더 관대하게 허용할 때 유용합니다.  이 여섯 번째 필드에 별표가 사용되면 "
"차단이 비활성화됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2611
msgid ""
"Remote rules allow a stricter enforcement of limits on attempts to log in "
"compared to attempts coming from a local network like an office."
msgstr ""
"원격 규칙을 사용하면 사무실과 같은 로컬 네트워크에서 발생하는 로그인 시도에 "
"비해 로그인을 더 엄격하게 제한할 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2612
#, no-wrap
msgid "Blacklistd Client Configuration"
msgstr "blacklistd 클라이언트 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2617
msgid ""
"There are a few software packages in FreeBSD that can utilize blacklistd's "
"functionality.  The two most prominent ones are man:ftpd[8] and man:sshd[8] "
"to block excessive connection attempts.  To activate blacklistd in the SSH "
"daemon, add the following line to [.filename]#/etc/ssh/sshd_config#:"
msgstr ""
"FreeBSD에는 blacklistd의 기능을 활용할 수 있는 몇 가지 소프트웨어 패키지가 있"
"습니다.  가장 눈에 띄는 두 패키지는 과도한 연결 시도를 차단하는 man:ftpd[8] "
"및 man:sshd[8]입니다.  SSH 데몬에서 blacklistd를 활성화하려면 [.filename]#/"
"etc/ssh/sshd_config# 에 다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2621
#, no-wrap
msgid "UseBlacklist yes\n"
msgstr "UseBlacklist yes\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2624
msgid "Restart sshd afterwards to make these changes take effect."
msgstr "변경 사항을 적용하려면 나중에 sshd를 다시 시작하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2626
msgid ""
"Blacklisting for man:ftpd[8] is enabled using `-B`, either in [.filename]#/"
"etc/inetd.conf# or as a flag in [.filename]#/etc/rc.conf# like this:"
msgstr ""
"man:ftpd[8]에 대한 블랙리스트는 [.filename]#/etc/inetd.conf# 에서 `-B` 를 사"
"용하거나 다음과 같이 [.filename]#/etc/rc.conf# 에서 플래그로 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2630
#, no-wrap
msgid "ftpd_flags=\"-B\"\n"
msgstr "ftpd_flags=\"-B\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2633
msgid "That is all that is needed to make these programs talk to blacklistd."
msgstr "프로그램이 blacklistd와 통신하는 데 필요한 것은 이것뿐입니다."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2634
#, no-wrap
msgid "Blacklistd Management"
msgstr "blacklistd 관리"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2639
msgid ""
"Blacklistd provides the user with a management utility called man:"
"blacklistctl[8].  It displays blocked addresses and networks that are "
"blocklisted by the rules defined in man:blacklistd.conf[5].  To see the list "
"of currently blocked hosts, use `dump` combined with `-b` like this."
msgstr ""
"Blacklistd는 사용자에게 man:blacklistctl[8]이라는 관리 유틸리티를 제공합니"
"다.  이 유틸리티는 man:blacklistd.conf[5]에 정의된 규칙에 따라 차단된 주소와 "
"네트워크를 표시합니다.  현재 차단된 호스트 목록을 보려면 다음과 같이 `dump` "
"와 `-b` 를 결합하여 사용합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2645
#, no-wrap
msgid ""
"# blacklistctl dump -b\n"
"      address/ma:port id      nfail   last access\n"
"213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19\n"
msgstr ""
"# blacklistctl dump -b\n"
"      address/ma:port id      nfail   last access\n"
"213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2651
msgid ""
"This example shows that there were 6 out of three permitted attempts on port "
"22 coming from the address range `213.0.123.128/25`.  There are more "
"attempts listed than are allowed because SSH allows a client to try multiple "
"logins on a single TCP connection.  A connection that is currently going on "
"is not stopped by blacklistd.  The last connection attempt is listed in the "
"`last access` column of the output."
msgstr ""
"이 예에서는 `213.0.123.128/25` 주소 범위에서 포트 22에 허용된 3번의 시도에 대"
"해 6번의 시도가 있었음을 보여줍니다.  허용된 시도보다 더 많은 시도가 나열된 "
"이유는 SSH를 사용하면 클라이언트가 단일 TCP 연결에서 여러 번 로그인을 시도할 "
"수 있기 때문입니다.  현재 진행 중인 연결은 블랙리스트에 의해 중지되지 않습니"
"다.  마지막 연결 시도는 출력의 `last access` 열에 나열됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2653
msgid ""
"To see the remaining time that this host will be on the blocklist, add `-r` "
"to the previous command."
msgstr ""
"이 호스트가 차단 목록에 남아있는 남은 시간을 확인하려면 이전 명령에 `-r` 을 "
"추가합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2659
#, no-wrap
msgid ""
"# blacklistctl dump -br\n"
"      address/ma:port id      nfail   remaining time\n"
"213.0.123.128/25:22   OK      6/3     36s\n"
msgstr ""
"# blacklistctl dump -br\n"
"      address/ma:port id      nfail   remaining time\n"
"213.0.123.128/25:22   OK      6/3     36s\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2662
msgid ""
"In this example, there are 36s seconds left until this host will not be "
"blocked any more."
msgstr ""
"이 예에서는 이 호스트가 더 이상 차단되지 않을 때까지 36초가 남았습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2663
#, no-wrap
msgid "Removing Hosts from the Block List"
msgstr "Block List에서 호스트 제거하기"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2674
msgid ""
"Sometimes it is necessary to remove a host from the block list before the "
"remaining time expires.  Unfortunately, there is no functionality in "
"blacklistd to do that.  However, it is possible to remove the address from "
"the PF table using pfctl.  For each blocked port, there is a child anchor "
"inside the blacklistd anchor defined in [.filename]#/etc/pf.conf#.  For "
"example, if there is a child anchor for blocking port 22 it is called "
"`blacklistd/22`.  There is a table inside that child anchor that contains "
"the blocked addresses.  This table is called port followed by the port "
"number.  In this example, it would be called `port22`.  With that "
"information at hand, it is now possible to use man:pfctl[8] to display all "
"addresses listed like this:"
msgstr ""
"남은 시간이 만료되기 전에 차단 목록에서 호스트를 제거해야 하는 경우가 있습니"
"다.  안타깝게도 블랙리스트에는 이를 수행할 수 있는 기능이 없습니다.  그러나 "
"pfctl을 사용하여 PF 테이블에서 주소를 제거할 수 있습니다.  차단된 각 포트에 "
"대해 [.filename]#/etc/pf.conf# 에 정의된 blacklistd 앵커 내부에 하위 앵커가 "
"있습니다.  예를 들어, 포트 22를 차단하는 자식 앵커가 있으면 `blacklistd/22` "
"라고 합니다.  해당 하위 앵커 내부에는 차단된 주소가 포함된 테이블이 있습니"
"다.  이 테이블은 포트 뒤에 포트 번호가 붙습니다.  이 예제에서는 `port22` 라"
"고 합니다.  이 정보가 있으면 이제 man:pfctl[8]을 사용하여 이와 같이 나열된 모"
"든 주소를 표시할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2681
#, no-wrap
msgid ""
"# pfctl -a blacklistd/22 -t port22 -T show\n"
"...\n"
"213.0.123.128/25\n"
"...\n"
msgstr ""
"# pfctl -a blacklistd/22 -t port22 -T show\n"
"...\n"
"213.0.123.128/25\n"
"...\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2684
msgid ""
"After identifying the address to be unblocked from the list, the following "
"command removes it from the list:"
msgstr ""
"목록에서 차단을 해제할 주소를 식별한 후 다음 명령을 실행하면 목록에서 해당 주"
"소가 삭제됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2688
#, no-wrap
msgid "# pfctl -a blacklistd/22 -t port22 -T delete 213.0.123.128/25\n"
msgstr "# pfctl -a blacklistd/22 -t port22 -T delete 213.0.123.128/25\n"

#. type: Plain text
#: documentation/content/en/books/handbook/firewalls/_index.adoc:2692
msgid ""
"The address is now removed from PF, but will still show up in the "
"blacklistctl list, since it does not know about any changes made in PF.  The "
"entry in blacklistd's database will eventually expire and be removed from "
"its output.  The entry will be added again if the host is matching one of "
"the block rules in blacklistd again."
msgstr ""
"이제 해당 주소는 PF에서 제거되었지만 PF에서 변경된 내용을 알지 못하므로 "
"blacklistctl 목록에는 계속 표시됩니다.  blacklistd의 데이터베이스 항목은 결"
"국 만료되어 출력에서 제거됩니다.  호스트가 blacklistd의 차단 규칙 중 하나와 "
"일치하는 경우 해당 항목이 다시 추가됩니다."
